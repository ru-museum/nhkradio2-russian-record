
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var check = function (it) {
	  return it && it.Math === Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global$l =
	  // eslint-disable-next-line es/no-global-this -- safe
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  // eslint-disable-next-line no-restricted-globals -- safe
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || commonjsGlobal || Function('return this')();

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var documentAll$2 = typeof document == 'object' && document.all;

	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
	// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
	var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;

	var documentAll_1 = {
	  all: documentAll$2,
	  IS_HTMLDDA: IS_HTMLDDA
	};

	var $documentAll$1 = documentAll_1;

	var documentAll$1 = $documentAll$1.all;

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable$k = $documentAll$1.IS_HTMLDDA ? function (argument) {
	  return typeof argument == 'function' || argument === documentAll$1;
	} : function (argument) {
	  return typeof argument == 'function';
	};

	var isCallable$j = isCallable$k;
	var $documentAll = documentAll_1;

	var documentAll = $documentAll.all;

	var isObject$b = $documentAll.IS_HTMLDDA ? function (it) {
	  return typeof it == 'object' ? it !== null : isCallable$j(it) || it === documentAll;
	} : function (it) {
	  return typeof it == 'object' ? it !== null : isCallable$j(it);
	};

	var global$k = global$l;
	var isObject$a = isObject$b;

	var document$1 = global$k.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS$1 = isObject$a(document$1) && isObject$a(document$1.createElement);

	var documentCreateElement$2 = function (it) {
	  return EXISTS$1 ? document$1.createElement(it) : {};
	};

	// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
	var documentCreateElement$1 = documentCreateElement$2;

	var classList = documentCreateElement$1('span').classList;
	var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;

	var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;

	var fails$l = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	var fails$k = fails$l;

	var functionBindNative = !fails$k(function () {
	  // eslint-disable-next-line es/no-function-prototype-bind -- safe
	  var test = (function () { /* empty */ }).bind();
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return typeof test != 'function' || test.hasOwnProperty('prototype');
	});

	var NATIVE_BIND$3 = functionBindNative;

	var FunctionPrototype$2 = Function.prototype;
	var call$e = FunctionPrototype$2.call;
	var uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$2.bind.bind(call$e, call$e);

	var functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function (fn) {
	  return function () {
	    return call$e.apply(fn, arguments);
	  };
	};

	var uncurryThis$l = functionUncurryThis;

	var toString$5 = uncurryThis$l({}.toString);
	var stringSlice$5 = uncurryThis$l(''.slice);

	var classofRaw$2 = function (it) {
	  return stringSlice$5(toString$5(it), 8, -1);
	};

	var uncurryThis$k = functionUncurryThis;
	var fails$j = fails$l;
	var classof$a = classofRaw$2;

	var $Object$4 = Object;
	var split = uncurryThis$k(''.split);

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails$j(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !$Object$4('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classof$a(it) === 'String' ? split(it, '') : $Object$4(it);
	} : $Object$4;

	// we can't use just `it == null` since of `document.all` special case
	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
	var isNullOrUndefined$4 = function (it) {
	  return it === null || it === undefined;
	};

	var isNullOrUndefined$3 = isNullOrUndefined$4;

	var $TypeError$b = TypeError;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible$4 = function (it) {
	  if (isNullOrUndefined$3(it)) throw $TypeError$b("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings
	var IndexedObject$1 = indexedObject;
	var requireObjectCoercible$3 = requireObjectCoercible$4;

	var toIndexedObject$6 = function (it) {
	  return IndexedObject$1(requireObjectCoercible$3(it));
	};

	var shared$4 = {exports: {}};

	var global$j = global$l;

	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var defineProperty$5 = Object.defineProperty;

	var defineGlobalProperty$3 = function (key, value) {
	  try {
	    defineProperty$5(global$j, key, { value: value, configurable: true, writable: true });
	  } catch (error) {
	    global$j[key] = value;
	  } return value;
	};

	var global$i = global$l;
	var defineGlobalProperty$2 = defineGlobalProperty$3;

	var SHARED = '__core-js_shared__';
	var store$3 = global$i[SHARED] || defineGlobalProperty$2(SHARED, {});

	var sharedStore = store$3;

	var store$2 = sharedStore;

	(shared$4.exports = function (key, value) {
	  return store$2[key] || (store$2[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.32.2',
	  mode: 'global',
	  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.32.2/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});

	var sharedExports = shared$4.exports;

	var requireObjectCoercible$2 = requireObjectCoercible$4;

	var $Object$3 = Object;

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject$6 = function (argument) {
	  return $Object$3(requireObjectCoercible$2(argument));
	};

	var uncurryThis$j = functionUncurryThis;
	var toObject$5 = toObject$6;

	var hasOwnProperty = uncurryThis$j({}.hasOwnProperty);

	// `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty
	// eslint-disable-next-line es/no-object-hasown -- safe
	var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
	  return hasOwnProperty(toObject$5(it), key);
	};

	var uncurryThis$i = functionUncurryThis;

	var id = 0;
	var postfix = Math.random();
	var toString$4 = uncurryThis$i(1.0.toString);

	var uid$3 = function (key) {
	  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$4(++id + postfix, 36);
	};

	var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

	var global$h = global$l;
	var userAgent$2 = engineUserAgent;

	var process = global$h.process;
	var Deno = global$h.Deno;
	var versions = process && process.versions || Deno && Deno.version;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us
	  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}

	// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0
	if (!version && userAgent$2) {
	  match = userAgent$2.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent$2.match(/Chrome\/(\d+)/);
	    if (match) version = +match[1];
	  }
	}

	var engineV8Version = version;

	/* eslint-disable es/no-symbol -- required for testing */
	var V8_VERSION = engineV8Version;
	var fails$i = fails$l;
	var global$g = global$l;

	var $String$5 = global$g.String;

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
	var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$i(function () {
	  var symbol = Symbol('symbol detection');
	  // Chrome 38 Symbol has incorrect toString conversion
	  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
	  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
	  // of course, fail.
	  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) ||
	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
	});

	/* eslint-disable es/no-symbol -- required for testing */
	var NATIVE_SYMBOL$1 = symbolConstructorDetection;

	var useSymbolAsUid = NATIVE_SYMBOL$1
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var global$f = global$l;
	var shared$3 = sharedExports;
	var hasOwn$a = hasOwnProperty_1;
	var uid$2 = uid$3;
	var NATIVE_SYMBOL = symbolConstructorDetection;
	var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;

	var Symbol$1 = global$f.Symbol;
	var WellKnownSymbolsStore = shared$3('wks');
	var createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1['for'] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;

	var wellKnownSymbol$g = function (name) {
	  if (!hasOwn$a(WellKnownSymbolsStore, name)) {
	    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$a(Symbol$1, name)
	      ? Symbol$1[name]
	      : createWellKnownSymbol('Symbol.' + name);
	  } return WellKnownSymbolsStore[name];
	};

	var isObject$9 = isObject$b;

	var $String$4 = String;
	var $TypeError$a = TypeError;

	// `Assert: Type(argument) is Object`
	var anObject$9 = function (argument) {
	  if (isObject$9(argument)) return argument;
	  throw $TypeError$a($String$4(argument) + ' is not an object');
	};

	var objectDefineProperties = {};

	var fails$h = fails$l;

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails$h(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
	});

	var DESCRIPTORS$c = descriptors;
	var fails$g = fails$l;

	// V8 ~ Chrome 36-
	// https://bugs.chromium.org/p/v8/issues/detail?id=3334
	var v8PrototypeDefineBug = DESCRIPTORS$c && fails$g(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
	    value: 42,
	    writable: false
	  }).prototype !== 42;
	});

	var objectDefineProperty = {};

	var DESCRIPTORS$b = descriptors;
	var fails$f = fails$l;
	var createElement = documentCreateElement$2;

	// Thanks to IE8 for its funny defineProperty
	var ie8DomDefine = !DESCRIPTORS$b && !fails$f(function () {
	  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
	  return Object.defineProperty(createElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a !== 7;
	});

	var NATIVE_BIND$2 = functionBindNative;

	var call$d = Function.prototype.call;

	var functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function () {
	  return call$d.apply(call$d, arguments);
	};

	var global$e = global$l;
	var isCallable$i = isCallable$k;

	var aFunction = function (argument) {
	  return isCallable$i(argument) ? argument : undefined;
	};

	var getBuiltIn$5 = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(global$e[namespace]) : global$e[namespace] && global$e[namespace][method];
	};

	var uncurryThis$h = functionUncurryThis;

	var objectIsPrototypeOf = uncurryThis$h({}.isPrototypeOf);

	var getBuiltIn$4 = getBuiltIn$5;
	var isCallable$h = isCallable$k;
	var isPrototypeOf$3 = objectIsPrototypeOf;
	var USE_SYMBOL_AS_UID = useSymbolAsUid;

	var $Object$2 = Object;

	var isSymbol$3 = USE_SYMBOL_AS_UID ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  var $Symbol = getBuiltIn$4('Symbol');
	  return isCallable$h($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$2(it));
	};

	var $String$3 = String;

	var tryToString$4 = function (argument) {
	  try {
	    return $String$3(argument);
	  } catch (error) {
	    return 'Object';
	  }
	};

	var isCallable$g = isCallable$k;
	var tryToString$3 = tryToString$4;

	var $TypeError$9 = TypeError;

	// `Assert: IsCallable(argument) is true`
	var aCallable$5 = function (argument) {
	  if (isCallable$g(argument)) return argument;
	  throw $TypeError$9(tryToString$3(argument) + ' is not a function');
	};

	var aCallable$4 = aCallable$5;
	var isNullOrUndefined$2 = isNullOrUndefined$4;

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod
	var getMethod$3 = function (V, P) {
	  var func = V[P];
	  return isNullOrUndefined$2(func) ? undefined : aCallable$4(func);
	};

	var call$c = functionCall;
	var isCallable$f = isCallable$k;
	var isObject$8 = isObject$b;

	var $TypeError$8 = TypeError;

	// `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive
	var ordinaryToPrimitive$1 = function (input, pref) {
	  var fn, val;
	  if (pref === 'string' && isCallable$f(fn = input.toString) && !isObject$8(val = call$c(fn, input))) return val;
	  if (isCallable$f(fn = input.valueOf) && !isObject$8(val = call$c(fn, input))) return val;
	  if (pref !== 'string' && isCallable$f(fn = input.toString) && !isObject$8(val = call$c(fn, input))) return val;
	  throw $TypeError$8("Can't convert object to primitive value");
	};

	var call$b = functionCall;
	var isObject$7 = isObject$b;
	var isSymbol$2 = isSymbol$3;
	var getMethod$2 = getMethod$3;
	var ordinaryToPrimitive = ordinaryToPrimitive$1;
	var wellKnownSymbol$f = wellKnownSymbol$g;

	var $TypeError$7 = TypeError;
	var TO_PRIMITIVE = wellKnownSymbol$f('toPrimitive');

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	var toPrimitive$2 = function (input, pref) {
	  if (!isObject$7(input) || isSymbol$2(input)) return input;
	  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
	  var result;
	  if (exoticToPrim) {
	    if (pref === undefined) pref = 'default';
	    result = call$b(exoticToPrim, input, pref);
	    if (!isObject$7(result) || isSymbol$2(result)) return result;
	    throw $TypeError$7("Can't convert object to primitive value");
	  }
	  if (pref === undefined) pref = 'number';
	  return ordinaryToPrimitive(input, pref);
	};

	var toPrimitive$1 = toPrimitive$2;
	var isSymbol$1 = isSymbol$3;

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey
	var toPropertyKey$4 = function (argument) {
	  var key = toPrimitive$1(argument, 'string');
	  return isSymbol$1(key) ? key : key + '';
	};

	var DESCRIPTORS$a = descriptors;
	var IE8_DOM_DEFINE$1 = ie8DomDefine;
	var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
	var anObject$8 = anObject$9;
	var toPropertyKey$3 = toPropertyKey$4;

	var $TypeError$6 = TypeError;
	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var $defineProperty = Object.defineProperty;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable';

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	objectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
	  anObject$8(O);
	  P = toPropertyKey$3(P);
	  anObject$8(Attributes);
	  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
	    var current = $getOwnPropertyDescriptor$1(O, P);
	    if (current && current[WRITABLE]) {
	      O[P] = Attributes.value;
	      Attributes = {
	        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
	        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
	        writable: false
	      };
	    }
	  } return $defineProperty(O, P, Attributes);
	} : $defineProperty : function defineProperty(O, P, Attributes) {
	  anObject$8(O);
	  P = toPropertyKey$3(P);
	  anObject$8(Attributes);
	  if (IE8_DOM_DEFINE$1) try {
	    return $defineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$6('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var ceil = Math.ceil;
	var floor$4 = Math.floor;

	// `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc
	// eslint-disable-next-line es/no-math-trunc -- safe
	var mathTrunc = Math.trunc || function trunc(x) {
	  var n = +x;
	  return (n > 0 ? floor$4 : ceil)(n);
	};

	var trunc$1 = mathTrunc;

	// `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity
	var toIntegerOrInfinity$7 = function (argument) {
	  var number = +argument;
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return number !== number || number === 0 ? 0 : trunc$1(number);
	};

	var toIntegerOrInfinity$6 = toIntegerOrInfinity$7;

	var max$2 = Math.max;
	var min$2 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex$3 = function (index, length) {
	  var integer = toIntegerOrInfinity$6(index);
	  return integer < 0 ? max$2(integer + length, 0) : min$2(integer, length);
	};

	var toIntegerOrInfinity$5 = toIntegerOrInfinity$7;

	var min$1 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength$5 = function (argument) {
	  return argument > 0 ? min$1(toIntegerOrInfinity$5(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var toLength$4 = toLength$5;

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike
	var lengthOfArrayLike$6 = function (obj) {
	  return toLength$4(obj.length);
	};

	var toIndexedObject$5 = toIndexedObject$6;
	var toAbsoluteIndex$2 = toAbsoluteIndex$3;
	var lengthOfArrayLike$5 = lengthOfArrayLike$6;

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$2 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject$5($this);
	    var length = lengthOfArrayLike$5(O);
	    var index = toAbsoluteIndex$2(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (IS_INCLUDES && el !== el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare -- NaN check
	      if (value !== value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$2(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$2(false)
	};

	var hiddenKeys$4 = {};

	var uncurryThis$g = functionUncurryThis;
	var hasOwn$9 = hasOwnProperty_1;
	var toIndexedObject$4 = toIndexedObject$6;
	var indexOf$1 = arrayIncludes.indexOf;
	var hiddenKeys$3 = hiddenKeys$4;

	var push$2 = uncurryThis$g([].push);

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject$4(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !hasOwn$9(hiddenKeys$3, key) && hasOwn$9(O, key) && push$2(result, key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (hasOwn$9(O, key = names[i++])) {
	    ~indexOf$1(result, key) || push$2(result, key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys$3 = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var internalObjectKeys$1 = objectKeysInternal;
	var enumBugKeys$2 = enumBugKeys$3;

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe
	var objectKeys$1 = Object.keys || function keys(O) {
	  return internalObjectKeys$1(O, enumBugKeys$2);
	};

	var DESCRIPTORS$9 = descriptors;
	var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
	var definePropertyModule$5 = objectDefineProperty;
	var anObject$7 = anObject$9;
	var toIndexedObject$3 = toIndexedObject$6;
	var objectKeys = objectKeys$1;

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe
	objectDefineProperties.f = DESCRIPTORS$9 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject$7(O);
	  var props = toIndexedObject$3(Properties);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) definePropertyModule$5.f(O, key = keys[index++], props[key]);
	  return O;
	};

	var getBuiltIn$3 = getBuiltIn$5;

	var html$1 = getBuiltIn$3('document', 'documentElement');

	var shared$2 = sharedExports;
	var uid$1 = uid$3;

	var keys$1 = shared$2('keys');

	var sharedKey$3 = function (key) {
	  return keys$1[key] || (keys$1[key] = uid$1(key));
	};

	/* global ActiveXObject -- old IE, WSH */
	var anObject$6 = anObject$9;
	var definePropertiesModule = objectDefineProperties;
	var enumBugKeys$1 = enumBugKeys$3;
	var hiddenKeys$2 = hiddenKeys$4;
	var html = html$1;
	var documentCreateElement = documentCreateElement$2;
	var sharedKey$2 = sharedKey$3;

	var GT = '>';
	var LT = '<';
	var PROTOTYPE$1 = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey$2('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    activeXDocument = new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = typeof document != 'undefined'
	    ? document.domain && activeXDocument
	      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
	      : NullProtoObjectViaIFrame()
	    : NullProtoObjectViaActiveX(activeXDocument); // WSH
	  var length = enumBugKeys$1.length;
	  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];
	  return NullProtoObject();
	};

	hiddenKeys$2[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	// eslint-disable-next-line es/no-object-create -- safe
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE$1] = anObject$6(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE$1] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
	};

	var wellKnownSymbol$e = wellKnownSymbol$g;
	var create$3 = objectCreate;
	var defineProperty$4 = objectDefineProperty.f;

	var UNSCOPABLES = wellKnownSymbol$e('unscopables');
	var ArrayPrototype$1 = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype$1[UNSCOPABLES] === undefined) {
	  defineProperty$4(ArrayPrototype$1, UNSCOPABLES, {
	    configurable: true,
	    value: create$3(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables$2 = function (key) {
	  ArrayPrototype$1[UNSCOPABLES][key] = true;
	};

	var iterators = {};

	var global$d = global$l;
	var isCallable$e = isCallable$k;

	var WeakMap$2 = global$d.WeakMap;

	var weakMapBasicDetection = isCallable$e(WeakMap$2) && /native code/.test(String(WeakMap$2));

	var createPropertyDescriptor$5 = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var DESCRIPTORS$8 = descriptors;
	var definePropertyModule$4 = objectDefineProperty;
	var createPropertyDescriptor$4 = createPropertyDescriptor$5;

	var createNonEnumerableProperty$8 = DESCRIPTORS$8 ? function (object, key, value) {
	  return definePropertyModule$4.f(object, key, createPropertyDescriptor$4(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var NATIVE_WEAK_MAP = weakMapBasicDetection;
	var global$c = global$l;
	var isObject$6 = isObject$b;
	var createNonEnumerableProperty$7 = createNonEnumerableProperty$8;
	var hasOwn$8 = hasOwnProperty_1;
	var shared$1 = sharedStore;
	var sharedKey$1 = sharedKey$3;
	var hiddenKeys$1 = hiddenKeys$4;

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$2 = global$c.TypeError;
	var WeakMap$1 = global$c.WeakMap;
	var set$1, get$1, has;

	var enforce = function (it) {
	  return has(it) ? get$1(it) : set$1(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject$6(it) || (state = get$1(it)).type !== TYPE) {
	      throw TypeError$2('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (NATIVE_WEAK_MAP || shared$1.state) {
	  var store$1 = shared$1.state || (shared$1.state = new WeakMap$1());
	  /* eslint-disable no-self-assign -- prototype methods protection */
	  store$1.get = store$1.get;
	  store$1.has = store$1.has;
	  store$1.set = store$1.set;
	  /* eslint-enable no-self-assign -- prototype methods protection */
	  set$1 = function (it, metadata) {
	    if (store$1.has(it)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    store$1.set(it, metadata);
	    return metadata;
	  };
	  get$1 = function (it) {
	    return store$1.get(it) || {};
	  };
	  has = function (it) {
	    return store$1.has(it);
	  };
	} else {
	  var STATE = sharedKey$1('state');
	  hiddenKeys$1[STATE] = true;
	  set$1 = function (it, metadata) {
	    if (hasOwn$8(it, STATE)) throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
	    metadata.facade = it;
	    createNonEnumerableProperty$7(it, STATE, metadata);
	    return metadata;
	  };
	  get$1 = function (it) {
	    return hasOwn$8(it, STATE) ? it[STATE] : {};
	  };
	  has = function (it) {
	    return hasOwn$8(it, STATE);
	  };
	}

	var internalState = {
	  set: set$1,
	  get: get$1,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var objectGetOwnPropertyDescriptor = {};

	var objectPropertyIsEnumerable = {};

	var $propertyIsEnumerable = {}.propertyIsEnumerable;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor$1(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : $propertyIsEnumerable;

	var DESCRIPTORS$7 = descriptors;
	var call$a = functionCall;
	var propertyIsEnumerableModule = objectPropertyIsEnumerable;
	var createPropertyDescriptor$3 = createPropertyDescriptor$5;
	var toIndexedObject$2 = toIndexedObject$6;
	var toPropertyKey$2 = toPropertyKey$4;
	var hasOwn$7 = hasOwnProperty_1;
	var IE8_DOM_DEFINE = ie8DomDefine;

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject$2(O);
	  P = toPropertyKey$2(P);
	  if (IE8_DOM_DEFINE) try {
	    return $getOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (hasOwn$7(O, P)) return createPropertyDescriptor$3(!call$a(propertyIsEnumerableModule.f, O, P), O[P]);
	};

	var makeBuiltIn$3 = {exports: {}};

	var DESCRIPTORS$6 = descriptors;
	var hasOwn$6 = hasOwnProperty_1;

	var FunctionPrototype$1 = Function.prototype;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getDescriptor = DESCRIPTORS$6 && Object.getOwnPropertyDescriptor;

	var EXISTS = hasOwn$6(FunctionPrototype$1, 'name');
	// additional protection from minified / mangled / dropped function names
	var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS$6 || (DESCRIPTORS$6 && getDescriptor(FunctionPrototype$1, 'name').configurable));

	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var uncurryThis$f = functionUncurryThis;
	var isCallable$d = isCallable$k;
	var store = sharedStore;

	var functionToString = uncurryThis$f(Function.toString);

	// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
	if (!isCallable$d(store.inspectSource)) {
	  store.inspectSource = function (it) {
	    return functionToString(it);
	  };
	}

	var inspectSource$2 = store.inspectSource;

	var uncurryThis$e = functionUncurryThis;
	var fails$e = fails$l;
	var isCallable$c = isCallable$k;
	var hasOwn$5 = hasOwnProperty_1;
	var DESCRIPTORS$5 = descriptors;
	var CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;
	var inspectSource$1 = inspectSource$2;
	var InternalStateModule$4 = internalState;

	var enforceInternalState$2 = InternalStateModule$4.enforce;
	var getInternalState$4 = InternalStateModule$4.get;
	var $String$2 = String;
	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var defineProperty$3 = Object.defineProperty;
	var stringSlice$4 = uncurryThis$e(''.slice);
	var replace$2 = uncurryThis$e(''.replace);
	var join = uncurryThis$e([].join);

	var CONFIGURABLE_LENGTH = DESCRIPTORS$5 && !fails$e(function () {
	  return defineProperty$3(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
	});

	var TEMPLATE = String(String).split('String');

	var makeBuiltIn$2 = makeBuiltIn$3.exports = function (value, name, options) {
	  if (stringSlice$4($String$2(name), 0, 7) === 'Symbol(') {
	    name = '[' + replace$2($String$2(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
	  }
	  if (options && options.getter) name = 'get ' + name;
	  if (options && options.setter) name = 'set ' + name;
	  if (!hasOwn$5(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {
	    if (DESCRIPTORS$5) defineProperty$3(value, 'name', { value: name, configurable: true });
	    else value.name = name;
	  }
	  if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, 'arity') && value.length !== options.arity) {
	    defineProperty$3(value, 'length', { value: options.arity });
	  }
	  try {
	    if (options && hasOwn$5(options, 'constructor') && options.constructor) {
	      if (DESCRIPTORS$5) defineProperty$3(value, 'prototype', { writable: false });
	    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
	    } else if (value.prototype) value.prototype = undefined;
	  } catch (error) { /* empty */ }
	  var state = enforceInternalState$2(value);
	  if (!hasOwn$5(state, 'source')) {
	    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
	  } return value;
	};

	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	// eslint-disable-next-line no-extend-native -- required
	Function.prototype.toString = makeBuiltIn$2(function toString() {
	  return isCallable$c(this) && getInternalState$4(this).source || inspectSource$1(this);
	}, 'toString');

	var makeBuiltInExports = makeBuiltIn$3.exports;

	var isCallable$b = isCallable$k;
	var definePropertyModule$3 = objectDefineProperty;
	var makeBuiltIn$1 = makeBuiltInExports;
	var defineGlobalProperty$1 = defineGlobalProperty$3;

	var defineBuiltIn$6 = function (O, key, value, options) {
	  if (!options) options = {};
	  var simple = options.enumerable;
	  var name = options.name !== undefined ? options.name : key;
	  if (isCallable$b(value)) makeBuiltIn$1(value, name, options);
	  if (options.global) {
	    if (simple) O[key] = value;
	    else defineGlobalProperty$1(key, value);
	  } else {
	    try {
	      if (!options.unsafe) delete O[key];
	      else if (O[key]) simple = true;
	    } catch (error) { /* empty */ }
	    if (simple) O[key] = value;
	    else definePropertyModule$3.f(O, key, {
	      value: value,
	      enumerable: false,
	      configurable: !options.nonConfigurable,
	      writable: !options.nonWritable
	    });
	  } return O;
	};

	var objectGetOwnPropertyNames = {};

	var internalObjectKeys = objectKeysInternal;
	var enumBugKeys = enumBugKeys$3;

	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	// eslint-disable-next-line es/no-object-getownpropertynames -- safe
	objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return internalObjectKeys(O, hiddenKeys);
	};

	var objectGetOwnPropertySymbols = {};

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
	objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

	var getBuiltIn$2 = getBuiltIn$5;
	var uncurryThis$d = functionUncurryThis;
	var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
	var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
	var anObject$5 = anObject$9;

	var concat$1 = uncurryThis$d([].concat);

	// all object keys, includes non-enumerable and symbols
	var ownKeys$1 = getBuiltIn$2('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = getOwnPropertyNamesModule.f(anObject$5(it));
	  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
	  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;
	};

	var hasOwn$4 = hasOwnProperty_1;
	var ownKeys = ownKeys$1;
	var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
	var definePropertyModule$2 = objectDefineProperty;

	var copyConstructorProperties$1 = function (target, source, exceptions) {
	  var keys = ownKeys(source);
	  var defineProperty = definePropertyModule$2.f;
	  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!hasOwn$4(target, key) && !(exceptions && hasOwn$4(exceptions, key))) {
	      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	    }
	  }
	};

	var fails$d = fails$l;
	var isCallable$a = isCallable$k;

	var replacement = /#|\.prototype\./;

	var isForced$1 = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value === POLYFILL ? true
	    : value === NATIVE ? false
	    : isCallable$a(detection) ? fails$d(detection)
	    : !!detection;
	};

	var normalize = isForced$1.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced$1.data = {};
	var NATIVE = isForced$1.NATIVE = 'N';
	var POLYFILL = isForced$1.POLYFILL = 'P';

	var isForced_1 = isForced$1;

	var global$b = global$l;
	var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var createNonEnumerableProperty$6 = createNonEnumerableProperty$8;
	var defineBuiltIn$5 = defineBuiltIn$6;
	var defineGlobalProperty = defineGlobalProperty$3;
	var copyConstructorProperties = copyConstructorProperties$1;
	var isForced = isForced_1;

	/*
	  options.target         - name of the target object
	  options.global         - target is the global object
	  options.stat           - export as static methods of target
	  options.proto          - export as prototype methods of target
	  options.real           - real prototype method for the `pure` version
	  options.forced         - export even if the native feature is available
	  options.bind           - bind methods to the target, required for the `pure` version
	  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
	  options.sham           - add a flag to not completely full polyfills
	  options.enumerable     - export as enumerable property
	  options.dontCallGetSet - prevent calling a getter on target
	  options.name           - the .name of the function if it does not match the key
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global$b;
	  } else if (STATIC) {
	    target = global$b[TARGET] || defineGlobalProperty(TARGET, {});
	  } else {
	    target = (global$b[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.dontCallGetSet) {
	      descriptor = getOwnPropertyDescriptor(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty == typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty$6(sourceProperty, 'sham', true);
	    }
	    defineBuiltIn$5(target, key, sourceProperty, options);
	  }
	};

	var fails$c = fails$l;

	var correctPrototypeGetter = !fails$c(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var hasOwn$3 = hasOwnProperty_1;
	var isCallable$9 = isCallable$k;
	var toObject$4 = toObject$6;
	var sharedKey = sharedKey$3;
	var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

	var IE_PROTO = sharedKey('IE_PROTO');
	var $Object$1 = Object;
	var ObjectPrototype$2 = $Object$1.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	// eslint-disable-next-line es/no-object-getprototypeof -- safe
	var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function (O) {
	  var object = toObject$4(O);
	  if (hasOwn$3(object, IE_PROTO)) return object[IE_PROTO];
	  var constructor = object.constructor;
	  if (isCallable$9(constructor) && object instanceof constructor) {
	    return constructor.prototype;
	  } return object instanceof $Object$1 ? ObjectPrototype$2 : null;
	};

	var fails$b = fails$l;
	var isCallable$8 = isCallable$k;
	var isObject$5 = isObject$b;
	var getPrototypeOf$3 = objectGetPrototypeOf;
	var defineBuiltIn$4 = defineBuiltIn$6;
	var wellKnownSymbol$d = wellKnownSymbol$g;

	var ITERATOR$5 = wellKnownSymbol$d('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

	/* eslint-disable es/no-array-prototype-keys -- safe */
	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = !isObject$5(IteratorPrototype$2) || fails$b(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype$2[ITERATOR$5].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};

	// `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
	if (!isCallable$8(IteratorPrototype$2[ITERATOR$5])) {
	  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$5, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	var defineProperty$2 = objectDefineProperty.f;
	var hasOwn$2 = hasOwnProperty_1;
	var wellKnownSymbol$c = wellKnownSymbol$g;

	var TO_STRING_TAG$4 = wellKnownSymbol$c('toStringTag');

	var setToStringTag$3 = function (target, TAG, STATIC) {
	  if (target && !STATIC) target = target.prototype;
	  if (target && !hasOwn$2(target, TO_STRING_TAG$4)) {
	    defineProperty$2(target, TO_STRING_TAG$4, { configurable: true, value: TAG });
	  }
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
	var create$2 = objectCreate;
	var createPropertyDescriptor$2 = createPropertyDescriptor$5;
	var setToStringTag$2 = setToStringTag$3;
	var Iterators$4 = iterators;

	var returnThis$1 = function () { return this; };

	var iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });
	  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);
	  Iterators$4[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var uncurryThis$c = functionUncurryThis;
	var aCallable$3 = aCallable$5;

	var functionUncurryThisAccessor = function (object, key, method) {
	  try {
	    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	    return uncurryThis$c(aCallable$3(Object.getOwnPropertyDescriptor(object, key)[method]));
	  } catch (error) { /* empty */ }
	};

	var isCallable$7 = isCallable$k;

	var $String$1 = String;
	var $TypeError$5 = TypeError;

	var aPossiblePrototype$1 = function (argument) {
	  if (typeof argument == 'object' || isCallable$7(argument)) return argument;
	  throw $TypeError$5("Can't set " + $String$1(argument) + ' as a prototype');
	};

	/* eslint-disable no-proto -- safe */
	var uncurryThisAccessor = functionUncurryThisAccessor;
	var anObject$4 = anObject$9;
	var aPossiblePrototype = aPossiblePrototype$1;

	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es/no-object-setprototypeof -- safe
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
	    setter(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject$4(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var $$3 = _export;
	var call$9 = functionCall;
	var FunctionName$1 = functionName;
	var isCallable$6 = isCallable$k;
	var createIteratorConstructor = iteratorCreateConstructor;
	var getPrototypeOf$2 = objectGetPrototypeOf;
	var setPrototypeOf$4 = objectSetPrototypeOf;
	var setToStringTag$1 = setToStringTag$3;
	var createNonEnumerableProperty$5 = createNonEnumerableProperty$8;
	var defineBuiltIn$3 = defineBuiltIn$6;
	var wellKnownSymbol$b = wellKnownSymbol$g;
	var Iterators$3 = iterators;
	var IteratorsCore = iteratorsCore;

	var PROPER_FUNCTION_NAME$1 = FunctionName$1.PROPER;
	var CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;
	var IteratorPrototype = IteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol$b('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    }

	    return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));
	    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
	      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {
	        if (setPrototypeOf$4) {
	          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);
	        } else if (!isCallable$6(CurrentIteratorPrototype[ITERATOR$4])) {
	          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$4, returnThis);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
	  if (PROPER_FUNCTION_NAME$1 && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    if (CONFIGURABLE_FUNCTION_NAME$1) {
	      createNonEnumerableProperty$5(IterablePrototype, 'name', VALUES);
	    } else {
	      INCORRECT_VALUES_NAME = true;
	      defaultIterator = function values() { return call$9(nativeIterator, this); };
	    }
	  }

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else $$3({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
	  }

	  // define iterator
	  if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    defineBuiltIn$3(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });
	  }
	  Iterators$3[NAME] = defaultIterator;

	  return methods;
	};

	// `CreateIterResultObject` abstract operation
	// https://tc39.es/ecma262/#sec-createiterresultobject
	var createIterResultObject$1 = function (value, done) {
	  return { value: value, done: done };
	};

	var toIndexedObject$1 = toIndexedObject$6;
	var addToUnscopables$1 = addToUnscopables$2;
	var Iterators$2 = iterators;
	var InternalStateModule$3 = internalState;
	var defineProperty$1 = objectDefineProperty.f;
	var defineIterator = iteratorDefine;
	var createIterResultObject = createIterResultObject$1;
	var DESCRIPTORS$4 = descriptors;

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = InternalStateModule$3.set;
	var getInternalState$3 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$2(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject$1(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$3(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return createIterResultObject(undefined, true);
	  }
	  switch (kind) {
	    case 'keys': return createIterResultObject(index, false);
	    case 'values': return createIterResultObject(target[index], false);
	  } return createIterResultObject([index, target[index]], false);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	var values = Iterators$2.Arguments = Iterators$2.Array;

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables$1('keys');
	addToUnscopables$1('values');
	addToUnscopables$1('entries');

	// V8 ~ Chrome 45- bug
	if (DESCRIPTORS$4 && values.name !== 'values') try {
	  defineProperty$1(values, 'name', { value: 'values' });
	} catch (error) { /* empty */ }

	var global$a = global$l;
	var DOMIterables = domIterables;
	var DOMTokenListPrototype = domTokenListPrototype;
	var ArrayIteratorMethods = es_array_iterator;
	var createNonEnumerableProperty$4 = createNonEnumerableProperty$8;
	var wellKnownSymbol$a = wellKnownSymbol$g;

	var ITERATOR$3 = wellKnownSymbol$a('iterator');
	var TO_STRING_TAG$3 = wellKnownSymbol$a('toStringTag');
	var ArrayValues = ArrayIteratorMethods.values;

	var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
	  if (CollectionPrototype) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype[ITERATOR$3] !== ArrayValues) try {
	      createNonEnumerableProperty$4(CollectionPrototype, ITERATOR$3, ArrayValues);
	    } catch (error) {
	      CollectionPrototype[ITERATOR$3] = ArrayValues;
	    }
	    if (!CollectionPrototype[TO_STRING_TAG$3]) {
	      createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
	    }
	    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
	        createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
	      }
	    }
	  }
	};

	for (var COLLECTION_NAME in DOMIterables) {
	  handlePrototype(global$a[COLLECTION_NAME] && global$a[COLLECTION_NAME].prototype, COLLECTION_NAME);
	}

	handlePrototype(DOMTokenListPrototype, 'DOMTokenList');

	/** @returns {void} */
	function noop$1() {}

	/** @returns {void} */
	function add_location(element, file, line, column, char) {
	  element.__svelte_meta = {
	    loc: {
	      file,
	      line,
	      column,
	      char
	    }
	  };
	}
	function run(fn) {
	  return fn();
	}
	function blank_object() {
	  return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
	  fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
	  return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
	  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
	}
	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
	  if (element_src === url) return true;
	  if (!src_url_equal_anchor) {
	    src_url_equal_anchor = document.createElement('a');
	  }
	  // This is actually faster than doing URL(..).href
	  src_url_equal_anchor.href = url;
	  return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
	  return Object.keys(obj).length === 0;
	}

	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, _typeof(o);
	}

	function _toPrimitive(input, hint) {
	  if (_typeof(input) !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (_typeof(res) !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}

	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return _typeof(key) === "symbol" ? key : String(key);
	}

	function _defineProperty(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}

	var typedArrayConstructor = {exports: {}};

	var wellKnownSymbol$9 = wellKnownSymbol$g;

	var ITERATOR$2 = wellKnownSymbol$9('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {
	  try {
	    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	// eslint-disable-next-line es/no-typed-arrays -- safe
	var arrayBufferBasicDetection = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';

	var wellKnownSymbol$8 = wellKnownSymbol$g;

	var TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag');
	var test = {};

	test[TO_STRING_TAG$2] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG_SUPPORT = toStringTagSupport;
	var isCallable$5 = isCallable$k;
	var classofRaw$1 = classofRaw$2;
	var wellKnownSymbol$7 = wellKnownSymbol$g;

	var TO_STRING_TAG$1 = wellKnownSymbol$7('toStringTag');
	var $Object = Object;

	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw$1(function () { return arguments; }()) === 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw$1 : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$1)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw$1(O)
	    // ES3 arguments fallback
	    : (result = classofRaw$1(O)) === 'Object' && isCallable$5(O.callee) ? 'Arguments' : result;
	};

	var makeBuiltIn = makeBuiltInExports;
	var defineProperty = objectDefineProperty;

	var defineBuiltInAccessor$4 = function (target, name, descriptor) {
	  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
	  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
	  return defineProperty.f(target, name, descriptor);
	};

	var NATIVE_ARRAY_BUFFER$1 = arrayBufferBasicDetection;
	var DESCRIPTORS$3 = descriptors;
	var global$9 = global$l;
	var isCallable$4 = isCallable$k;
	var isObject$4 = isObject$b;
	var hasOwn$1 = hasOwnProperty_1;
	var classof$8 = classof$9;
	var tryToString$2 = tryToString$4;
	var createNonEnumerableProperty$3 = createNonEnumerableProperty$8;
	var defineBuiltIn$2 = defineBuiltIn$6;
	var defineBuiltInAccessor$3 = defineBuiltInAccessor$4;
	var isPrototypeOf$2 = objectIsPrototypeOf;
	var getPrototypeOf$1 = objectGetPrototypeOf;
	var setPrototypeOf$3 = objectSetPrototypeOf;
	var wellKnownSymbol$6 = wellKnownSymbol$g;
	var uid = uid$3;
	var InternalStateModule$2 = internalState;

	var enforceInternalState$1 = InternalStateModule$2.enforce;
	var getInternalState$2 = InternalStateModule$2.get;
	var Int8Array$3 = global$9.Int8Array;
	var Int8ArrayPrototype$1 = Int8Array$3 && Int8Array$3.prototype;
	var Uint8ClampedArray$1 = global$9.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;
	var TypedArray$1 = Int8Array$3 && getPrototypeOf$1(Int8Array$3);
	var TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);
	var ObjectPrototype$1 = Object.prototype;
	var TypeError$1 = global$9.TypeError;

	var TO_STRING_TAG = wellKnownSymbol$6('toStringTag');
	var TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');
	var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
	// Fixing native typed arrays in Opera Presto crashes the browser, see #595
	var NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$8(global$9.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQUIRED = false;
	var NAME, Constructor, Prototype;

	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};

	var BigIntArrayConstructorsList = {
	  BigInt64Array: 8,
	  BigUint64Array: 8
	};

	var isView = function isView(it) {
	  if (!isObject$4(it)) return false;
	  var klass = classof$8(it);
	  return klass === 'DataView'
	    || hasOwn$1(TypedArrayConstructorsList, klass)
	    || hasOwn$1(BigIntArrayConstructorsList, klass);
	};

	var getTypedArrayConstructor = function (it) {
	  var proto = getPrototypeOf$1(it);
	  if (!isObject$4(proto)) return;
	  var state = getInternalState$2(proto);
	  return (state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
	};

	var isTypedArray$1 = function (it) {
	  if (!isObject$4(it)) return false;
	  var klass = classof$8(it);
	  return hasOwn$1(TypedArrayConstructorsList, klass)
	    || hasOwn$1(BigIntArrayConstructorsList, klass);
	};

	var aTypedArray$3 = function (it) {
	  if (isTypedArray$1(it)) return it;
	  throw TypeError$1('Target is not a typed array');
	};

	var aTypedArrayConstructor$2 = function (C) {
	  if (isCallable$4(C) && (!setPrototypeOf$3 || isPrototypeOf$2(TypedArray$1, C))) return C;
	  throw TypeError$1(tryToString$2(C) + ' is not a typed array constructor');
	};

	var exportTypedArrayMethod$3 = function (KEY, property, forced, options) {
	  if (!DESCRIPTORS$3) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global$9[ARRAY];
	    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {
	      delete TypedArrayConstructor.prototype[KEY];
	    } catch (error) {
	      // old WebKit bug - some methods are non-configurable
	      try {
	        TypedArrayConstructor.prototype[KEY] = property;
	      } catch (error2) { /* empty */ }
	    }
	  }
	  if (!TypedArrayPrototype$1[KEY] || forced) {
	    defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property
	      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);
	  }
	};

	var exportTypedArrayStaticMethod = function (KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!DESCRIPTORS$3) return;
	  if (setPrototypeOf$3) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global$9[ARRAY];
	      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {
	        delete TypedArrayConstructor[KEY];
	      } catch (error) { /* empty */ }
	    }
	    if (!TypedArray$1[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);
	      } catch (error) { /* empty */ }
	    } else return;
	  }
	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global$9[ARRAY];
	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      defineBuiltIn$2(TypedArrayConstructor, KEY, property);
	    }
	  }
	};

	for (NAME in TypedArrayConstructorsList) {
	  Constructor = global$9[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
	  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
	}

	for (NAME in BigIntArrayConstructorsList) {
	  Constructor = global$9[NAME];
	  Prototype = Constructor && Constructor.prototype;
	  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
	}

	// WebKit bug - typed arrays constructors prototype is Object.prototype
	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$4(TypedArray$1) || TypedArray$1 === Function.prototype) {
	  // eslint-disable-next-line no-shadow -- safe
	  TypedArray$1 = function TypedArray() {
	    throw TypeError$1('Incorrect invocation');
	  };
	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
	    if (global$9[NAME]) setPrototypeOf$3(global$9[NAME], TypedArray$1);
	  }
	}

	if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {
	  TypedArrayPrototype$1 = TypedArray$1.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {
	    if (global$9[NAME]) setPrototypeOf$3(global$9[NAME].prototype, TypedArrayPrototype$1);
	  }
	}

	// WebKit bug - one more object in Uint8ClampedArray prototype chain
	if (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {
	  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
	}

	if (DESCRIPTORS$3 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {
	  TYPED_ARRAY_TAG_REQUIRED = true;
	  defineBuiltInAccessor$3(TypedArrayPrototype$1, TO_STRING_TAG, {
	    configurable: true,
	    get: function () {
	      return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;
	    }
	  });
	  for (NAME in TypedArrayConstructorsList) if (global$9[NAME]) {
	    createNonEnumerableProperty$3(global$9[NAME], TYPED_ARRAY_TAG$1, NAME);
	  }
	}

	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,
	  aTypedArray: aTypedArray$3,
	  aTypedArrayConstructor: aTypedArrayConstructor$2,
	  exportTypedArrayMethod: exportTypedArrayMethod$3,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  getTypedArrayConstructor: getTypedArrayConstructor,
	  isView: isView,
	  isTypedArray: isTypedArray$1,
	  TypedArray: TypedArray$1,
	  TypedArrayPrototype: TypedArrayPrototype$1
	};

	/* eslint-disable no-new -- required for testing */
	var global$8 = global$l;
	var fails$a = fails$l;
	var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	var ArrayBuffer$2 = global$8.ArrayBuffer;
	var Int8Array$2 = global$8.Int8Array;

	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$a(function () {
	  Int8Array$2(1);
	}) || !fails$a(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails$a(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$2(2), 1, undefined).length !== 1;
	});

	var defineBuiltIn$1 = defineBuiltIn$6;

	var defineBuiltIns$1 = function (target, src, options) {
	  for (var key in src) defineBuiltIn$1(target, key, src[key], options);
	  return target;
	};

	var isPrototypeOf$1 = objectIsPrototypeOf;

	var $TypeError$4 = TypeError;

	var anInstance$2 = function (it, Prototype) {
	  if (isPrototypeOf$1(Prototype, it)) return it;
	  throw $TypeError$4('Incorrect invocation');
	};

	var toIntegerOrInfinity$4 = toIntegerOrInfinity$7;
	var toLength$3 = toLength$5;

	var $RangeError$2 = RangeError;

	// `ToIndex` abstract operation
	// https://tc39.es/ecma262/#sec-toindex
	var toIndex$2 = function (it) {
	  if (it === undefined) return 0;
	  var number = toIntegerOrInfinity$4(it);
	  var length = toLength$3(number);
	  if (number !== length) throw $RangeError$2('Wrong length or index');
	  return length;
	};

	// `Math.sign` method implementation
	// https://tc39.es/ecma262/#sec-math.sign
	// eslint-disable-next-line es/no-math-sign -- safe
	var mathSign = Math.sign || function sign(x) {
	  var n = +x;
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	var sign = mathSign;
	var trunc = mathTrunc;

	var $Array$2 = Array;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor$3 = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;

	var roundToEven = function (number) {
	  var truncated = trunc(number);
	  var delta = abs(number - truncated);
	  if (delta > 0.5 || delta === 0.5 && truncated % 2 !== 0) {
	    return truncated + sign(number);
	  } return truncated;
	};

	var pack = function (number, mantissaLength, bytes) {
	  var buffer = $Array$2(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var s = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs(number);
	  // eslint-disable-next-line no-self-compare -- NaN check
	  if (number !== number || number === Infinity) {
	    // eslint-disable-next-line no-self-compare -- NaN check
	    mantissa = number !== number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$3(log(number) / LN2);
	    c = pow(2, -exponent);
	    if (number * c < 1) {
	      exponent--;
	      c *= 2;
	    }
	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow(2, 1 - eBias);
	    }
	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }
	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = roundToEven((number * c - 1) * pow(2, mantissaLength));
	      exponent += eBias;
	    } else {
	      mantissa = roundToEven(number * pow(2, eBias - 1) * pow(2, mantissaLength));
	      exponent = 0;
	    }
	  }
	  while (mantissaLength >= 8) {
	    buffer[index++] = mantissa & 255;
	    mantissa /= 256;
	    mantissaLength -= 8;
	  }
	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;
	  while (exponentLength > 0) {
	    buffer[index++] = exponent & 255;
	    exponent /= 256;
	    exponentLength -= 8;
	  }
	  buffer[--index] |= s * 128;
	  return buffer;
	};

	var unpack = function (buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var s = buffer[index--];
	  var exponent = s & 127;
	  var mantissa;
	  s >>= 7;
	  while (nBits > 0) {
	    exponent = exponent * 256 + buffer[index--];
	    nBits -= 8;
	  }
	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;
	  while (nBits > 0) {
	    mantissa = mantissa * 256 + buffer[index--];
	    nBits -= 8;
	  }
	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : s ? -Infinity : Infinity;
	  } else {
	    mantissa += pow(2, mantissaLength);
	    exponent -= eBias;
	  } return (s ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
	};

	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var toObject$3 = toObject$6;
	var toAbsoluteIndex$1 = toAbsoluteIndex$3;
	var lengthOfArrayLike$4 = lengthOfArrayLike$6;

	// `Array.prototype.fill` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.fill
	var arrayFill$1 = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject$3(this);
	  var length = lengthOfArrayLike$4(O);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex$1(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex$1(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	var toPropertyKey$1 = toPropertyKey$4;
	var definePropertyModule$1 = objectDefineProperty;
	var createPropertyDescriptor$1 = createPropertyDescriptor$5;

	var createProperty$1 = function (object, key, value) {
	  var propertyKey = toPropertyKey$1(key);
	  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));
	  else object[propertyKey] = value;
	};

	var toAbsoluteIndex = toAbsoluteIndex$3;
	var lengthOfArrayLike$3 = lengthOfArrayLike$6;
	var createProperty = createProperty$1;

	var $Array$1 = Array;
	var max$1 = Math.max;

	var arraySliceSimple = function (O, start, end) {
	  var length = lengthOfArrayLike$3(O);
	  var k = toAbsoluteIndex(start, length);
	  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	  var result = $Array$1(max$1(fin - k, 0));
	  var n = 0;
	  for (; k < fin; k++, n++) createProperty(result, n, O[k]);
	  result.length = n;
	  return result;
	};

	var global$7 = global$l;
	var uncurryThis$b = functionUncurryThis;
	var DESCRIPTORS$2 = descriptors;
	var NATIVE_ARRAY_BUFFER = arrayBufferBasicDetection;
	var FunctionName = functionName;
	var createNonEnumerableProperty$2 = createNonEnumerableProperty$8;
	var defineBuiltInAccessor$2 = defineBuiltInAccessor$4;
	var defineBuiltIns = defineBuiltIns$1;
	var fails$9 = fails$l;
	var anInstance$1 = anInstance$2;
	var toIntegerOrInfinity$3 = toIntegerOrInfinity$7;
	var toLength$2 = toLength$5;
	var toIndex$1 = toIndex$2;
	var IEEE754 = ieee754;
	var getPrototypeOf = objectGetPrototypeOf;
	var setPrototypeOf$2 = objectSetPrototypeOf;
	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var arrayFill = arrayFill$1;
	var arraySlice$1 = arraySliceSimple;
	var setToStringTag = setToStringTag$3;
	var InternalStateModule$1 = internalState;

	var PROPER_FUNCTION_NAME = FunctionName.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH$1 = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var getInternalArrayBufferState = InternalStateModule$1.getterFor(ARRAY_BUFFER);
	var getInternalDataViewState = InternalStateModule$1.getterFor(DATA_VIEW);
	var setInternalState$1 = InternalStateModule$1.set;
	var NativeArrayBuffer = global$7[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
	var $DataView = global$7[DATA_VIEW];
	var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
	var ObjectPrototype = Object.prototype;
	var Array$1 = global$7.Array;
	var RangeError$3 = global$7.RangeError;
	var fill = uncurryThis$b(arrayFill);
	var reverse = uncurryThis$b([].reverse);

	var packIEEE754 = IEEE754.pack;
	var unpackIEEE754 = IEEE754.unpack;

	var packInt8 = function (number) {
	  return [number & 0xFF];
	};

	var packInt16 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};

	var packInt32 = function (number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};

	var unpackInt32 = function (buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};

	var packFloat32 = function (number) {
	  return packIEEE754(number, 23, 4);
	};

	var packFloat64 = function (number) {
	  return packIEEE754(number, 52, 8);
	};

	var addGetter$1 = function (Constructor, key, getInternalState) {
	  defineBuiltInAccessor$2(Constructor[PROTOTYPE], key, {
	    configurable: true,
	    get: function () {
	      return getInternalState(this)[key];
	    }
	  });
	};

	var get = function (view, count, index, isLittleEndian) {
	  var store = getInternalDataViewState(view);
	  var intIndex = toIndex$1(index);
	  var boolIsLittleEndian = !!isLittleEndian;
	  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
	  var bytes = store.bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = arraySlice$1(bytes, start, start + count);
	  return boolIsLittleEndian ? pack : reverse(pack);
	};

	var set = function (view, count, index, conversion, value, isLittleEndian) {
	  var store = getInternalDataViewState(view);
	  var intIndex = toIndex$1(index);
	  var pack = conversion(+value);
	  var boolIsLittleEndian = !!isLittleEndian;
	  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);
	  var bytes = store.bytes;
	  var start = intIndex + store.byteOffset;
	  for (var i = 0; i < count; i++) bytes[start + i] = pack[boolIsLittleEndian ? i : count - i - 1];
	};

	if (!NATIVE_ARRAY_BUFFER) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance$1(this, ArrayBufferPrototype$1);
	    var byteLength = toIndex$1(length);
	    setInternalState$1(this, {
	      type: ARRAY_BUFFER,
	      bytes: fill(Array$1(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!DESCRIPTORS$2) {
	      this.byteLength = byteLength;
	      this.detached = false;
	    }
	  };

	  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];

	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance$1(this, DataViewPrototype);
	    anInstance$1(buffer, ArrayBufferPrototype$1);
	    var bufferState = getInternalArrayBufferState(buffer);
	    var bufferLength = bufferState.byteLength;
	    var offset = toIntegerOrInfinity$3(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength$2(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);
	    setInternalState$1(this, {
	      type: DATA_VIEW,
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset,
	      bytes: bufferState.bytes
	    });
	    if (!DESCRIPTORS$2) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };

	  DataViewPrototype = $DataView[PROTOTYPE];

	  if (DESCRIPTORS$2) {
	    addGetter$1($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
	    addGetter$1($DataView, 'buffer', getInternalDataViewState);
	    addGetter$1($DataView, 'byteLength', getInternalDataViewState);
	    addGetter$1($DataView, 'byteOffset', getInternalDataViewState);
	  }

	  defineBuiltIns(DataViewPrototype, {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : false);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : false), 23);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : false), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : false);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : false);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : false);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : false);
	    }
	  });
	} else {
	  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
	  /* eslint-disable no-new -- required for testing */
	  if (!fails$9(function () {
	    NativeArrayBuffer(1);
	  }) || !fails$9(function () {
	    new NativeArrayBuffer(-1);
	  }) || fails$9(function () {
	    new NativeArrayBuffer();
	    new NativeArrayBuffer(1.5);
	    new NativeArrayBuffer(NaN);
	    return NativeArrayBuffer.length !== 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
	  })) {
	    /* eslint-enable no-new -- required for testing */
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance$1(this, ArrayBufferPrototype$1);
	      return new NativeArrayBuffer(toIndex$1(length));
	    };

	    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;

	    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);
	      }
	    }

	    ArrayBufferPrototype$1.constructor = $ArrayBuffer;
	  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
	    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);
	  }

	  // WebKit bug - the same parent prototype for typed arrays and data view
	  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
	    setPrototypeOf$2(DataViewPrototype, ObjectPrototype);
	  }

	  // iOS Safari 7.x bug
	  var testView = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = uncurryThis$b(DataViewPrototype.setInt8);
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8(this, byteOffset, value << 24 >> 24);
	    }
	  }, { unsafe: true });
	}

	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);

	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var isObject$3 = isObject$b;

	var floor$2 = Math.floor;

	// `IsIntegralNumber` abstract operation
	// https://tc39.es/ecma262/#sec-isintegralnumber
	// eslint-disable-next-line es/no-number-isinteger -- safe
	var isIntegralNumber$1 = Number.isInteger || function isInteger(it) {
	  return !isObject$3(it) && isFinite(it) && floor$2(it) === it;
	};

	var toIntegerOrInfinity$2 = toIntegerOrInfinity$7;

	var $RangeError$1 = RangeError;

	var toPositiveInteger$1 = function (it) {
	  var result = toIntegerOrInfinity$2(it);
	  if (result < 0) throw $RangeError$1("The argument can't be less than 0");
	  return result;
	};

	var toPositiveInteger = toPositiveInteger$1;

	var $RangeError = RangeError;

	var toOffset$2 = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw $RangeError('Wrong offset');
	  return offset;
	};

	var round = Math.round;

	var toUint8Clamped$1 = function (it) {
	  var value = round(it);
	  return value < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	};

	var classofRaw = classofRaw$2;
	var uncurryThis$a = functionUncurryThis;

	var functionUncurryThisClause = function (fn) {
	  // Nashorn bug:
	  //   https://github.com/zloirock/core-js/issues/1128
	  //   https://github.com/zloirock/core-js/issues/1130
	  if (classofRaw(fn) === 'Function') return uncurryThis$a(fn);
	};

	var uncurryThis$9 = functionUncurryThisClause;
	var aCallable$2 = aCallable$5;
	var NATIVE_BIND$1 = functionBindNative;

	var bind$2 = uncurryThis$9(uncurryThis$9.bind);

	// optional / simple context binding
	var functionBindContext = function (fn, that) {
	  aCallable$2(fn);
	  return that === undefined ? fn : NATIVE_BIND$1 ? bind$2(fn, that) : function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var uncurryThis$8 = functionUncurryThis;
	var fails$8 = fails$l;
	var isCallable$3 = isCallable$k;
	var classof$7 = classof$9;
	var getBuiltIn$1 = getBuiltIn$5;
	var inspectSource = inspectSource$2;

	var noop = function () { /* empty */ };
	var empty$1 = [];
	var construct = getBuiltIn$1('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec$1 = uncurryThis$8(constructorRegExp.exec);
	var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

	var isConstructorModern = function isConstructor(argument) {
	  if (!isCallable$3(argument)) return false;
	  try {
	    construct(noop, empty$1, argument);
	    return true;
	  } catch (error) {
	    return false;
	  }
	};

	var isConstructorLegacy = function isConstructor(argument) {
	  if (!isCallable$3(argument)) return false;
	  switch (classof$7(argument)) {
	    case 'AsyncFunction':
	    case 'GeneratorFunction':
	    case 'AsyncGeneratorFunction': return false;
	  }
	  try {
	    // we can't check .prototype since constructors produced by .bind haven't it
	    // `Function#toString` throws on some built-it function in some legacy engines
	    // (for example, `DOMQuad` and similar in FF41-)
	    return INCORRECT_TO_STRING || !!exec$1(constructorRegExp, inspectSource(argument));
	  } catch (error) {
	    return true;
	  }
	};

	isConstructorLegacy.sham = true;

	// `IsConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-isconstructor
	var isConstructor$2 = !construct || fails$8(function () {
	  var called;
	  return isConstructorModern(isConstructorModern.call)
	    || !isConstructorModern(Object)
	    || !isConstructorModern(function () { called = true; })
	    || called;
	}) ? isConstructorLegacy : isConstructorModern;

	var isConstructor$1 = isConstructor$2;
	var tryToString$1 = tryToString$4;

	var $TypeError$3 = TypeError;

	// `Assert: IsConstructor(argument) is true`
	var aConstructor$1 = function (argument) {
	  if (isConstructor$1(argument)) return argument;
	  throw $TypeError$3(tryToString$1(argument) + ' is not a constructor');
	};

	var classof$6 = classof$9;
	var getMethod$1 = getMethod$3;
	var isNullOrUndefined$1 = isNullOrUndefined$4;
	var Iterators$1 = iterators;
	var wellKnownSymbol$5 = wellKnownSymbol$g;

	var ITERATOR$1 = wellKnownSymbol$5('iterator');

	var getIteratorMethod$2 = function (it) {
	  if (!isNullOrUndefined$1(it)) return getMethod$1(it, ITERATOR$1)
	    || getMethod$1(it, '@@iterator')
	    || Iterators$1[classof$6(it)];
	};

	var call$8 = functionCall;
	var aCallable$1 = aCallable$5;
	var anObject$3 = anObject$9;
	var tryToString = tryToString$4;
	var getIteratorMethod$1 = getIteratorMethod$2;

	var $TypeError$2 = TypeError;

	var getIterator$1 = function (argument, usingIterator) {
	  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
	  if (aCallable$1(iteratorMethod)) return anObject$3(call$8(iteratorMethod, argument));
	  throw $TypeError$2(tryToString(argument) + ' is not iterable');
	};

	var wellKnownSymbol$4 = wellKnownSymbol$g;
	var Iterators = iterators;

	var ITERATOR = wellKnownSymbol$4('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod$1 = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
	};

	var classof$5 = classof$9;

	var isBigIntArray$1 = function (it) {
	  var klass = classof$5(it);
	  return klass === 'BigInt64Array' || klass === 'BigUint64Array';
	};

	var toPrimitive = toPrimitive$2;

	var $TypeError$1 = TypeError;

	// `ToBigInt` abstract operation
	// https://tc39.es/ecma262/#sec-tobigint
	var toBigInt$2 = function (argument) {
	  var prim = toPrimitive(argument, 'number');
	  if (typeof prim == 'number') throw $TypeError$1("Can't convert number to bigint");
	  // eslint-disable-next-line es/no-bigint -- safe
	  return BigInt(prim);
	};

	var bind$1 = functionBindContext;
	var call$7 = functionCall;
	var aConstructor = aConstructor$1;
	var toObject$2 = toObject$6;
	var lengthOfArrayLike$2 = lengthOfArrayLike$6;
	var getIterator = getIterator$1;
	var getIteratorMethod = getIteratorMethod$2;
	var isArrayIteratorMethod = isArrayIteratorMethod$1;
	var isBigIntArray = isBigIntArray$1;
	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
	var toBigInt$1 = toBigInt$2;

	var typedArrayFrom$1 = function from(source /* , mapfn, thisArg */) {
	  var C = aConstructor(this);
	  var O = toObject$2(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
	  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = getIterator(O, iteratorMethod);
	    next = iterator.next;
	    O = [];
	    while (!(step = call$7(next, iterator)).done) {
	      O.push(step.value);
	    }
	  }
	  if (mapping && argumentsLength > 2) {
	    mapfn = bind$1(mapfn, arguments[2]);
	  }
	  length = lengthOfArrayLike$2(O);
	  result = new (aTypedArrayConstructor$1(C))(length);
	  thisIsBigIntArray = isBigIntArray(result);
	  for (i = 0; length > i; i++) {
	    value = mapping ? mapfn(O[i], i) : O[i];
	    // FF30- typed arrays doesn't properly convert objects to typed array values
	    result[i] = thisIsBigIntArray ? toBigInt$1(value) : +value;
	  }
	  return result;
	};

	var classof$4 = classofRaw$2;

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es/no-array-isarray -- safe
	var isArray$1 = Array.isArray || function isArray(argument) {
	  return classof$4(argument) === 'Array';
	};

	var isArray = isArray$1;
	var isConstructor = isConstructor$2;
	var isObject$2 = isObject$b;
	var wellKnownSymbol$3 = wellKnownSymbol$g;

	var SPECIES$2 = wellKnownSymbol$3('species');
	var $Array = Array;

	// a part of `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesConstructor$1 = function (originalArray) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
	    else if (isObject$2(C)) {
	      C = C[SPECIES$2];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? $Array : C;
	};

	var arraySpeciesConstructor = arraySpeciesConstructor$1;

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate$1 = function (originalArray, length) {
	  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
	};

	var bind = functionBindContext;
	var uncurryThis$7 = functionUncurryThis;
	var IndexedObject = indexedObject;
	var toObject$1 = toObject$6;
	var lengthOfArrayLike$1 = lengthOfArrayLike$6;
	var arraySpeciesCreate = arraySpeciesCreate$1;

	var push$1 = uncurryThis$7([].push);

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
	var createMethod$1 = function (TYPE) {
	  var IS_MAP = TYPE === 1;
	  var IS_FILTER = TYPE === 2;
	  var IS_SOME = TYPE === 3;
	  var IS_EVERY = TYPE === 4;
	  var IS_FIND_INDEX = TYPE === 6;
	  var IS_FILTER_REJECT = TYPE === 7;
	  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject$1($this);
	    var self = IndexedObject(O);
	    var boundFunction = bind(callbackfn, that);
	    var length = lengthOfArrayLike$1(self);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push$1(target, value);      // filter
	        } else switch (TYPE) {
	          case 4: return false;             // every
	          case 7: push$1(target, value);      // filterReject
	        }
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6),
	  // `Array.prototype.filterReject` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterReject: createMethod$1(7)
	};

	var getBuiltIn = getBuiltIn$5;
	var defineBuiltInAccessor$1 = defineBuiltInAccessor$4;
	var wellKnownSymbol$2 = wellKnownSymbol$g;
	var DESCRIPTORS$1 = descriptors;

	var SPECIES$1 = wellKnownSymbol$2('species');

	var setSpecies$1 = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

	  if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES$1]) {
	    defineBuiltInAccessor$1(Constructor, SPECIES$1, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var isCallable$2 = isCallable$k;
	var isObject$1 = isObject$b;
	var setPrototypeOf$1 = objectSetPrototypeOf;

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired$1 = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	    // it can work only with native `setPrototypeOf`
	    setPrototypeOf$1 &&
	    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	    isCallable$2(NewTarget = dummy.constructor) &&
	    NewTarget !== Wrapper &&
	    isObject$1(NewTargetPrototype = NewTarget.prototype) &&
	    NewTargetPrototype !== Wrapper.prototype
	  ) setPrototypeOf$1($this, NewTargetPrototype);
	  return $this;
	};

	var $$2 = _export;
	var global$6 = global$l;
	var call$6 = functionCall;
	var DESCRIPTORS = descriptors;
	var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;
	var ArrayBufferViewCore$3 = arrayBufferViewCore;
	var ArrayBufferModule = arrayBuffer;
	var anInstance = anInstance$2;
	var createPropertyDescriptor = createPropertyDescriptor$5;
	var createNonEnumerableProperty$1 = createNonEnumerableProperty$8;
	var isIntegralNumber = isIntegralNumber$1;
	var toLength$1 = toLength$5;
	var toIndex = toIndex$2;
	var toOffset$1 = toOffset$2;
	var toUint8Clamped = toUint8Clamped$1;
	var toPropertyKey = toPropertyKey$4;
	var hasOwn = hasOwnProperty_1;
	var classof$3 = classof$9;
	var isObject = isObject$b;
	var isSymbol = isSymbol$3;
	var create$1 = objectCreate;
	var isPrototypeOf = objectIsPrototypeOf;
	var setPrototypeOf = objectSetPrototypeOf;
	var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	var typedArrayFrom = typedArrayFrom$1;
	var forEach = arrayIteration.forEach;
	var setSpecies = setSpecies$1;
	var defineBuiltInAccessor = defineBuiltInAccessor$4;
	var definePropertyModule = objectDefineProperty;
	var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
	var InternalStateModule = internalState;
	var inheritIfRequired = inheritIfRequired$1;

	var getInternalState$1 = InternalStateModule.get;
	var setInternalState = InternalStateModule.set;
	var enforceInternalState = InternalStateModule.enforce;
	var nativeDefineProperty = definePropertyModule.f;
	var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
	var RangeError$2 = global$6.RangeError;
	var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
	var ArrayBufferPrototype = ArrayBuffer$1.prototype;
	var DataView$1 = ArrayBufferModule.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$3.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_TAG = ArrayBufferViewCore$3.TYPED_ARRAY_TAG;
	var TypedArray = ArrayBufferViewCore$3.TypedArray;
	var TypedArrayPrototype = ArrayBufferViewCore$3.TypedArrayPrototype;
	var aTypedArrayConstructor = ArrayBufferViewCore$3.aTypedArrayConstructor;
	var isTypedArray = ArrayBufferViewCore$3.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';

	var fromList = function (C, list) {
	  aTypedArrayConstructor(C);
	  var index = 0;
	  var length = list.length;
	  var result = new C(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};

	var addGetter = function (it, key) {
	  defineBuiltInAccessor(it, key, {
	    configurable: true,
	    get: function () {
	      return getInternalState$1(this)[key];
	    }
	  });
	};

	var isArrayBuffer = function (it) {
	  var klass;
	  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$3(it)) === 'ArrayBuffer' || klass === 'SharedArrayBuffer';
	};

	var isTypedArrayIndex = function (target, key) {
	  return isTypedArray(target)
	    && !isSymbol(key)
	    && key in target
	    && isIntegralNumber(+key)
	    && key >= 0;
	};

	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  key = toPropertyKey(key);
	  return isTypedArrayIndex(target, key)
	    ? createPropertyDescriptor(2, target[key])
	    : nativeGetOwnPropertyDescriptor(target, key);
	};

	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  key = toPropertyKey(key);
	  if (isTypedArrayIndex(target, key)
	    && isObject(descriptor)
	    && hasOwn(descriptor, 'value')
	    && !hasOwn(descriptor, 'get')
	    && !hasOwn(descriptor, 'set')
	    // TODO: add validation descriptor w/o calling accessors
	    && !descriptor.configurable
	    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
	    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
	  ) {
	    target[key] = descriptor.value;
	    return target;
	  } return nativeDefineProperty(target, key, descriptor);
	};

	if (DESCRIPTORS) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
	    definePropertyModule.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }

	  $$2({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });

	  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global$6[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};

	    var getter = function (that, index) {
	      var data = getInternalState$1(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };

	    var setter = function (that, index, value) {
	      var data = getInternalState$1(that);
	      data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
	    };

	    var addElement = function (that, index) {
	      nativeDefineProperty(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };

	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructorPrototype);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer$1(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset$1(offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);
	          } else {
	            byteLength = toLength$1($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return call$6(typedArrayFrom, TypedArrayConstructor, data);
	        }
	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView$1(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });

	      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create$1(TypedArrayPrototype);
	    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructorPrototype);
	        return inheritIfRequired(function () {
	          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined
	            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)
	            : typedArrayOffset !== undefined
	              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))
	              : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return call$6(typedArrayFrom, TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });

	      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }

	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }

	    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }

	    var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;

	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

	    $$2({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }

	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }

	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else typedArrayConstructor.exports = function () { /* empty */ };

	var typedArrayConstructorExports = typedArrayConstructor.exports;

	var createTypedArrayConstructor = typedArrayConstructorExports;

	// `Int32Array` constructor
	// https://tc39.es/ecma262/#sec-typedarray-objects
	createTypedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var ArrayBufferViewCore$2 = arrayBufferViewCore;
	var $fill = arrayFill$1;
	var toBigInt = toBigInt$2;
	var classof$2 = classof$9;
	var call$5 = functionCall;
	var uncurryThis$6 = functionUncurryThis;
	var fails$7 = fails$l;

	var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
	var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;
	var slice = uncurryThis$6(''.slice);

	// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
	var CONVERSION_BUG = fails$7(function () {
	  var count = 0;
	  // eslint-disable-next-line es/no-typed-arrays -- safe
	  new Int8Array(2).fill({ valueOf: function () { return count++; } });
	  return count !== 1;
	});

	// `%TypedArray%.prototype.fill` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
	exportTypedArrayMethod$2('fill', function fill(value /* , start, end */) {
	  var length = arguments.length;
	  aTypedArray$2(this);
	  var actualValue = slice(classof$2(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
	  return call$5($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
	}, CONVERSION_BUG);

	var global$5 = global$l;
	var call$4 = functionCall;
	var ArrayBufferViewCore$1 = arrayBufferViewCore;
	var lengthOfArrayLike = lengthOfArrayLike$6;
	var toOffset = toOffset$2;
	var toIndexedObject = toObject$6;
	var fails$6 = fails$l;

	var RangeError$1 = global$5.RangeError;
	var Int8Array$1 = global$5.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
	var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
	var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;

	var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails$6(function () {
	  // eslint-disable-next-line es/no-typed-arrays -- required for testing
	  var array = new Uint8ClampedArray(2);
	  call$4($set, array, { length: 1, 0: 3 }, 1);
	  return array[1] !== 3;
	});

	// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
	var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$1.NATIVE_ARRAY_BUFFER_VIEWS && fails$6(function () {
	  var array = new Int8Array$1(2);
	  array.set(1);
	  array.set('2', 1);
	  return array[0] !== 0 || array[1] !== 2;
	});

	// `%TypedArray%.prototype.set` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
	exportTypedArrayMethod$1('set', function set(arrayLike /* , offset */) {
	  aTypedArray$1(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var src = toIndexedObject(arrayLike);
	  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call$4($set, this, src, offset);
	  var length = this.length;
	  var len = lengthOfArrayLike(src);
	  var index = 0;
	  if (len + offset > length) throw RangeError$1('Wrong length');
	  while (index < len) this[offset + index] = src[index++];
	}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);

	var arraySlice = arraySliceSimple;

	var floor$1 = Math.floor;

	var mergeSort = function (array, comparefn) {
	  var length = array.length;
	  var middle = floor$1(length / 2);
	  return length < 8 ? insertionSort(array, comparefn) : merge(
	    array,
	    mergeSort(arraySlice(array, 0, middle), comparefn),
	    mergeSort(arraySlice(array, middle), comparefn),
	    comparefn
	  );
	};

	var insertionSort = function (array, comparefn) {
	  var length = array.length;
	  var i = 1;
	  var element, j;

	  while (i < length) {
	    j = i;
	    element = array[i];
	    while (j && comparefn(array[j - 1], element) > 0) {
	      array[j] = array[--j];
	    }
	    if (j !== i++) array[j] = element;
	  } return array;
	};

	var merge = function (array, left, right, comparefn) {
	  var llength = left.length;
	  var rlength = right.length;
	  var lindex = 0;
	  var rindex = 0;

	  while (lindex < llength || rindex < rlength) {
	    array[lindex + rindex] = (lindex < llength && rindex < rlength)
	      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
	      : lindex < llength ? left[lindex++] : right[rindex++];
	  } return array;
	};

	var arraySort = mergeSort;

	var userAgent$1 = engineUserAgent;

	var firefox = userAgent$1.match(/firefox\/(\d+)/i);

	var engineFfVersion = !!firefox && +firefox[1];

	var UA = engineUserAgent;

	var engineIsIeOrEdge = /MSIE|Trident/.test(UA);

	var userAgent = engineUserAgent;

	var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

	var engineWebkitVersion = !!webkit && +webkit[1];

	var global$4 = global$l;
	var uncurryThis$5 = functionUncurryThisClause;
	var fails$5 = fails$l;
	var aCallable = aCallable$5;
	var internalSort = arraySort;
	var ArrayBufferViewCore = arrayBufferViewCore;
	var FF = engineFfVersion;
	var IE_OR_EDGE = engineIsIeOrEdge;
	var V8 = engineV8Version;
	var WEBKIT = engineWebkitVersion;

	var aTypedArray = ArrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
	var Uint16Array = global$4.Uint16Array;
	var nativeSort = Uint16Array && uncurryThis$5(Uint16Array.prototype.sort);

	// WebKit
	var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails$5(function () {
	  nativeSort(new Uint16Array(2), null);
	}) && fails$5(function () {
	  nativeSort(new Uint16Array(2), {});
	}));

	var STABLE_SORT = !!nativeSort && !fails$5(function () {
	  // feature detection can be too slow, so check engines versions
	  if (V8) return V8 < 74;
	  if (FF) return FF < 67;
	  if (IE_OR_EDGE) return true;
	  if (WEBKIT) return WEBKIT < 602;

	  var array = new Uint16Array(516);
	  var expected = Array(516);
	  var index, mod;

	  for (index = 0; index < 516; index++) {
	    mod = index % 4;
	    array[index] = 515 - index;
	    expected[index] = index - 2 * mod + 3;
	  }

	  nativeSort(array, function (a, b) {
	    return (a / 4 | 0) - (b / 4 | 0);
	  });

	  for (index = 0; index < 516; index++) {
	    if (array[index] !== expected[index]) return true;
	  }
	});

	var getSortCompare = function (comparefn) {
	  return function (x, y) {
	    if (comparefn !== undefined) return +comparefn(x, y) || 0;
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (y !== y) return -1;
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (x !== x) return 1;
	    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
	    return x > y;
	  };
	};

	// `%TypedArray%.prototype.sort` method
	// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
	exportTypedArrayMethod('sort', function sort(comparefn) {
	  if (comparefn !== undefined) aCallable(comparefn);
	  if (STABLE_SORT) return nativeSort(this, comparefn);

	  return internalSort(aTypedArray(this), getSortCompare(comparefn));
	}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);

	/** @type {typeof globalThis} */
	const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis :
	// @ts-ignore Node typings have this
	global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
	  target.appendChild(node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
	  target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
	  if (node.parentNode) {
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
	  for (let i = 0; i < iterations.length; i += 1) {
	    if (iterations[i]) iterations[i].d(detaching);
	  }
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
	  return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
	  return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
	  return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
	  return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
	  return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
	  node.addEventListener(event, handler, options);
	  return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
	  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}

	/**
	 * @returns {void} */
	function set_custom_element_data(node, prop, value) {
	  if (prop in node) {
	    node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
	  } else {
	    attr(node, prop, value);
	  }
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
	  return Array.from(element.childNodes);
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
	  if (value == null) {
	    node.style.removeProperty(key);
	  } else {
	    node.style.setProperty(key, value, important ? 'important' : '');
	  }
	}

	/**
	 * @returns {void} */
	function toggle_class(element, name, toggle) {
	  // The `!!` is required because an `undefined` flag means flipping the current state.
	  element.classList.toggle(name, !!toggle);
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail) {
	  let {
	    bubbles = false,
	    cancelable = false
	  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  return new CustomEvent(type, {
	    detail,
	    bubbles,
	    cancelable
	  });
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
	  current_component = component;
	}
	function get_current_component() {
	  if (!current_component) throw new Error('Function called outside component initialization');
	  return current_component;
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
	  get_current_component().$$.on_mount.push(fn);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
	  const callbacks = component.$$.callbacks[event.type];
	  if (callbacks) {
	    // @ts-ignore
	    callbacks.slice().forEach(fn => fn.call(this, event));
	  }
	}

	const dirty_components = [];
	const binding_callbacks = [];
	let render_callbacks = [];
	const flush_callbacks = [];
	const resolved_promise = /* @__PURE__ */Promise.resolve();
	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
	  if (!update_scheduled) {
	    update_scheduled = true;
	    resolved_promise.then(flush);
	  }
	}

	/** @returns {void} */
	function add_render_callback(fn) {
	  render_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();
	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
	  // Do not reenter flush while dirty components are updated, as this can
	  // result in an infinite loop. Instead, let the inner flush handle it.
	  // Reentrancy is ok afterwards for bindings etc.
	  if (flushidx !== 0) {
	    return;
	  }
	  const saved_component = current_component;
	  do {
	    // first, call beforeUpdate functions
	    // and update components
	    try {
	      while (flushidx < dirty_components.length) {
	        const component = dirty_components[flushidx];
	        flushidx++;
	        set_current_component(component);
	        update(component.$$);
	      }
	    } catch (e) {
	      // reset dirty state to not end up in a deadlocked state and then rethrow
	      dirty_components.length = 0;
	      flushidx = 0;
	      throw e;
	    }
	    set_current_component(null);
	    dirty_components.length = 0;
	    flushidx = 0;
	    while (binding_callbacks.length) binding_callbacks.pop()();
	    // then, once components are updated, call
	    // afterUpdate functions. This may cause
	    // subsequent updates...
	    for (let i = 0; i < render_callbacks.length; i += 1) {
	      const callback = render_callbacks[i];
	      if (!seen_callbacks.has(callback)) {
	        // ...so guard against infinite loops
	        seen_callbacks.add(callback);
	        callback();
	      }
	    }
	    render_callbacks.length = 0;
	  } while (dirty_components.length);
	  while (flush_callbacks.length) {
	    flush_callbacks.pop()();
	  }
	  update_scheduled = false;
	  seen_callbacks.clear();
	  set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
	  if ($$.fragment !== null) {
	    $$.update();
	    run_all($$.before_update);
	    const dirty = $$.dirty;
	    $$.dirty = [-1];
	    $$.fragment && $$.fragment.p($$.ctx, dirty);
	    $$.after_update.forEach(add_render_callback);
	  }
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
	  const filtered = [];
	  const targets = [];
	  render_callbacks.forEach(c => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
	  targets.forEach(c => c());
	  render_callbacks = filtered;
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
	  outros = {
	    r: 0,
	    c: [],
	    p: outros // parent group
	  };
	}

	/**
	 * @returns {void} */
	function check_outros() {
	  if (!outros.r) {
	    run_all(outros.c);
	  }
	  outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
	  if (block && block.i) {
	    outroing.delete(block);
	    block.i(local);
	  }
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
	  if (block && block.o) {
	    if (outroing.has(block)) return;
	    outroing.add(block);
	    outros.c.push(() => {
	      outroing.delete(block);
	      if (callback) {
	        if (detach) block.d(1);
	        callback();
	      }
	    });
	    block.o(local);
	  } else if (callback) {
	    callback();
	  }
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
	  return (array_like_or_iterator === null || array_like_or_iterator === void 0 ? void 0 : array_like_or_iterator.length) !== undefined ? array_like_or_iterator : Array.from(array_like_or_iterator);
	}

	/** @returns {void} */
	function create_component(block) {
	  block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
	  const {
	    fragment,
	    after_update
	  } = component.$$;
	  fragment && fragment.m(target, anchor);
	  // onMount happens before the initial afterUpdate
	  add_render_callback(() => {
	    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
	    // if the component was destroyed immediately
	    // it will update the `$$.on_destroy` reference to `null`.
	    // the destructured on_destroy may still reference to the old array
	    if (component.$$.on_destroy) {
	      component.$$.on_destroy.push(...new_on_destroy);
	    } else {
	      // Edge case - component was destroyed immediately,
	      // most likely as a result of a binding initialising
	      run_all(new_on_destroy);
	    }
	    component.$$.on_mount = [];
	  });
	  after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
	  const $$ = component.$$;
	  if ($$.fragment !== null) {
	    flush_render_callbacks($$.after_update);
	    run_all($$.on_destroy);
	    $$.fragment && $$.fragment.d(detaching);
	    // TODO null out other refs, including component.$$ (but need to
	    // preserve final state?)
	    $$.on_destroy = $$.fragment = null;
	    $$.ctx = [];
	  }
	}

	/** @returns {void} */
	function make_dirty(component, i) {
	  if (component.$$.dirty[0] === -1) {
	    dirty_components.push(component);
	    schedule_update();
	    component.$$.dirty.fill(0);
	  }
	  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(component, options, instance, create_fragment, not_equal, props) {
	  let append_styles = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
	  let dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
	  const parent_component = current_component;
	  set_current_component(component);
	  /** @type {import('./private.js').T$$} */
	  const $$ = component.$$ = {
	    fragment: null,
	    ctx: [],
	    // state
	    props,
	    update: noop$1,
	    not_equal,
	    bound: blank_object(),
	    // lifecycle
	    on_mount: [],
	    on_destroy: [],
	    on_disconnect: [],
	    before_update: [],
	    after_update: [],
	    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
	    // everything else
	    callbacks: blank_object(),
	    dirty,
	    skip_bound: false,
	    root: options.target || parent_component.$$.root
	  };
	  append_styles && append_styles($$.root);
	  let ready = false;
	  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
	    const value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;
	    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
	      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
	      if (ready) make_dirty(component, i);
	    }
	    return ret;
	  }) : [];
	  $$.update();
	  ready = true;
	  run_all($$.before_update);
	  // `false` as a special case of no DOM component
	  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	  if (options.target) {
	    if (options.hydrate) {
	      // TODO: what is the correct type here?
	      // @ts-expect-error
	      const nodes = children(options.target);
	      $$.fragment && $$.fragment.l(nodes);
	      nodes.forEach(detach);
	    } else {
	      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	      $$.fragment && $$.fragment.c();
	    }
	    if (options.intro) transition_in(component.$$.fragment);
	    mount_component(component, options.target, options.anchor);
	    flush();
	  }
	  set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
	  constructor() {
	    /**
	     * ### PRIVATE API
	     *
	     * Do not use, may change at any time
	     *
	     * @type {any}
	     */
	    _defineProperty(this, "$$", undefined);
	    /**
	     * ### PRIVATE API
	     *
	     * Do not use, may change at any time
	     *
	     * @type {any}
	     */
	    _defineProperty(this, "$$set", undefined);
	  }
	  /** @returns {void} */
	  $destroy() {
	    destroy_component(this, 1);
	    this.$destroy = noop$1;
	  }

	  /**
	   * @template {Extract<keyof Events, string>} K
	   * @param {K} type
	   * @param {((e: Events[K]) => void) | null | undefined} callback
	   * @returns {() => void}
	   */
	  $on(type, callback) {
	    if (!is_function(callback)) {
	      return noop$1;
	    }
	    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
	    callbacks.push(callback);
	    return () => {
	      const index = callbacks.indexOf(callback);
	      if (index !== -1) callbacks.splice(index, 1);
	    };
	  }

	  /**
	   * @param {Partial<Props>} props
	   * @returns {void}
	   */
	  $set(props) {
	    if (this.$$set && !is_empty(props)) {
	      this.$$.skip_bound = true;
	      this.$$set(props);
	      this.$$.skip_bound = false;
	    }
	  }
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */
	const VERSION = '4.2.1';
	const PUBLIC_VERSION = '4';

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */
	function dispatch_dev(type, detail) {
	  document.dispatchEvent(custom_event(type, {
	    version: VERSION,
	    ...detail
	  }, {
	    bubbles: true
	  }));
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append_dev(target, node) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node
	  });
	  append(target, node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert_dev(target, node, anchor) {
	  dispatch_dev('SvelteDOMInsert', {
	    target,
	    node,
	    anchor
	  });
	  insert(target, node, anchor);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach_dev(node) {
	  dispatch_dev('SvelteDOMRemove', {
	    node
	  });
	  detach(node);
	}

	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */
	function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
	  const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
	  if (has_prevent_default) modifiers.push('preventDefault');
	  if (has_stop_propagation) modifiers.push('stopPropagation');
	  if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
	  dispatch_dev('SvelteDOMAddEventListener', {
	    node,
	    event,
	    handler,
	    modifiers
	  });
	  const dispose = listen(node, event, handler, options);
	  return () => {
	    dispatch_dev('SvelteDOMRemoveEventListener', {
	      node,
	      event,
	      handler,
	      modifiers
	    });
	    dispose();
	  };
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr_dev(node, attribute, value) {
	  attr(node, attribute, value);
	  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
	    node,
	    attribute
	  });else dispatch_dev('SvelteDOMSetAttribute', {
	    node,
	    attribute,
	    value
	  });
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data_dev(text, data) {
	  data = '' + data;
	  if (text.data === data) return;
	  dispatch_dev('SvelteDOMSetData', {
	    node: text,
	    data
	  });
	  text.data = /** @type {string} */data;
	}
	function ensure_array_like_dev(arg) {
	  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg) && !(typeof Symbol === 'function' && arg && Symbol.iterator in arg)) {
	    throw new Error('{#each} only works with iterable values.');
	  }
	  return ensure_array_like(arg);
	}

	/**
	 * @returns {void} */
	function validate_slots(name, slot, keys) {
	  for (const slot_key of Object.keys(slot)) {
	    if (!~keys.indexOf(slot_key)) {
	      console.warn("<".concat(name, "> received an unexpected slot \"").concat(slot_key, "\"."));
	    }
	  }
	}
	function construct_svelte_component_dev(component, props) {
	  const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
	  try {
	    const instance = new component(props);
	    if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
	      throw new Error(error_message);
	    }
	    return instance;
	  } catch (err) {
	    const {
	      message
	    } = err;
	    if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
	      throw new Error(error_message);
	    } else {
	      throw err;
	    }
	  }
	}

	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */
	class SvelteComponentDev extends SvelteComponent {
	  /** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
	  constructor(options) {
	    if (!options || !options.target && !options.$$inline) {
	      throw new Error("'target' is a required option");
	    }
	    super();
	    /**
	     * For type checking capabilities only.
	     * Does not exist at runtime.
	     * ### DO NOT USE!
	     *
	     * @type {Props}
	     */
	    _defineProperty(this, "$$prop_def", void 0);
	    /**
	     * For type checking capabilities only.
	     * Does not exist at runtime.
	     * ### DO NOT USE!
	     *
	     * @type {Events}
	     */
	    _defineProperty(this, "$$events_def", void 0);
	    /**
	     * For type checking capabilities only.
	     * Does not exist at runtime.
	     * ### DO NOT USE!
	     *
	     * @type {Slots}
	     */
	    _defineProperty(this, "$$slot_def", void 0);
	  }

	  /** @returns {void} */
	  $destroy() {
	    super.$destroy();
	    this.$destroy = () => {
	      console.warn('Component was already destroyed'); // eslint-disable-line no-console
	    };
	  }

	  /** @returns {void} */
	  $capture_state() {}

	  /** @returns {void} */
	  $inject_state() {}
	}

	if (typeof window !== 'undefined')
	  // @ts-ignore
	  (window.__svelte || (window.__svelte = {
	    v: new Set()
	  })).v.add(PUBLIC_VERSION);

	const file$1j = "src/material-icons/account-balance.svelte";
	function create_fragment$1k(ctx) {
	  let svg;
	  let g0;
	  let rect0;
	  let g2;
	  let g1;
	  let rect1;
	  let rect2;
	  let rect3;
	  let rect4;
	  let polygon;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g0 = svg_element("g");
	      rect0 = svg_element("rect");
	      g2 = svg_element("g");
	      g1 = svg_element("g");
	      rect1 = svg_element("rect");
	      rect2 = svg_element("rect");
	      rect3 = svg_element("rect");
	      rect4 = svg_element("rect");
	      polygon = svg_element("polygon");
	      attr_dev(rect0, "fill", "none");
	      attr_dev(rect0, "height", "24");
	      attr_dev(rect0, "width", "24");
	      add_location(rect0, file$1j, 5, 72, 191);
	      add_location(g0, file$1j, 5, 69, 188);
	      attr_dev(rect1, "height", "7");
	      attr_dev(rect1, "width", "3");
	      attr_dev(rect1, "x", "4");
	      attr_dev(rect1, "y", "10");
	      add_location(rect1, file$1j, 5, 124, 243);
	      attr_dev(rect2, "height", "7");
	      attr_dev(rect2, "width", "3");
	      attr_dev(rect2, "x", "10.5");
	      attr_dev(rect2, "y", "10");
	      add_location(rect2, file$1j, 5, 165, 284);
	      attr_dev(rect3, "height", "3");
	      attr_dev(rect3, "width", "20");
	      attr_dev(rect3, "x", "2");
	      attr_dev(rect3, "y", "19");
	      add_location(rect3, file$1j, 5, 209, 328);
	      attr_dev(rect4, "height", "7");
	      attr_dev(rect4, "width", "3");
	      attr_dev(rect4, "x", "17");
	      attr_dev(rect4, "y", "10");
	      add_location(rect4, file$1j, 5, 251, 370);
	      attr_dev(polygon, "points", "12,1 2,6 2,8 22,8 22,6");
	      add_location(polygon, file$1j, 5, 293, 412);
	      add_location(g1, file$1j, 5, 121, 240);
	      add_location(g2, file$1j, 5, 118, 237);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1j, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g0);
	      append_dev(g0, rect0);
	      append_dev(svg, g2);
	      append_dev(g2, g1);
	      append_dev(g1, rect1);
	      append_dev(g1, rect2);
	      append_dev(g1, rect3);
	      append_dev(g1, rect4);
	      append_dev(g1, polygon);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1k.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1k($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Account_balance', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Account_balance> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Account_balance extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Account_balance",
	      options,
	      id: create_fragment$1k.name
	    });
	  }
	  get size() {
	    throw new Error("<Account_balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Account_balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Account_balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Account_balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Account_balance>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Account_balance>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1i = "src/material-icons/add-box.svelte";
	function create_fragment$1j(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1i, 5, 69, 188);
	      attr_dev(path1, "d", "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z");
	      add_location(path1, file$1i, 5, 106, 225);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1i, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1j.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1j($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Add_box', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Add_box> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Add_box extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Add_box",
	      options,
	      id: create_fragment$1j.name
	    });
	  }
	  get size() {
	    throw new Error("<Add_box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Add_box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Add_box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Add_box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Add_box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Add_box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1h = "src/material-icons/add-circle.svelte";
	function create_fragment$1i(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1h, 6, 69, 189);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z");
	      add_location(path1, file$1h, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1h, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1i.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1i($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Add_circle', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Add_circle> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Add_circle extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Add_circle",
	      options,
	      id: create_fragment$1i.name
	    });
	  }
	  get size() {
	    throw new Error("<Add_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Add_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Add_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Add_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Add_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Add_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1g = "src/material-icons/apps.svelte";
	function create_fragment$1h(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1g, 6, 69, 189);
	      attr_dev(path1, "d", "M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z");
	      add_location(path1, file$1g, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1g, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1h.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1h($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Apps', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Apps> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Apps extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Apps",
	      options,
	      id: create_fragment$1h.name
	    });
	  }
	  get size() {
	    throw new Error("<Apps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Apps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Apps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Apps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Apps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Apps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1f = "src/material-icons/arrow-back.svelte";
	function create_fragment$1g(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1f, 6, 69, 189);
	      attr_dev(path1, "d", "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z");
	      add_location(path1, file$1f, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1f, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1g.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1g($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_back', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_back> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_back extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_back",
	      options,
	      id: create_fragment$1g.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_back>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_back>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_back>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_back>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_back>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_back>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1e = "src/material-icons/arrow-circle-up.svelte";
	function create_fragment$1f(ctx) {
	  let svg;
	  let g;
	  let rect;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g = svg_element("g");
	      rect = svg_element("rect");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$1e, 6, 72, 192);
	      attr_dev(path, "d", "M12,20c-4.41,0-8-3.59-8-8s3.59-8,8-8s8,3.59,8,8S16.41,20,12,20 M12,22c5.52,0,10-4.48,10-10c0-5.52-4.48-10-10-10 C6.48,2,2,6.48,2,12C2,17.52,6.48,22,12,22L12,22z M11,12l0,4h2l0-4h3l-4-4l-4,4H11z");
	      add_location(path, file$1e, 6, 114, 234);
	      add_location(g, file$1e, 6, 69, 189);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1e, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g);
	      append_dev(g, rect);
	      append_dev(g, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1f.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1f($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_circle_up', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_circle_up> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_circle_up extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_circle_up",
	      options,
	      id: create_fragment$1f.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_circle_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_circle_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_circle_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_circle_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_circle_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_circle_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1d = "src/material-icons/arrow-drop-down.svelte";
	function create_fragment$1e(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1d, 6, 69, 189);
	      attr_dev(path1, "d", "M7 10l5 5 5-5z");
	      add_location(path1, file$1d, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1d, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1e.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1e($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_drop_down', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_drop_down> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_drop_down extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_drop_down",
	      options,
	      id: create_fragment$1e.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_drop_down>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_drop_down>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_drop_down>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_drop_down>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_drop_down>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_drop_down>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1c = "src/material-icons/arrow-downward.svelte";
	function create_fragment$1d(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1c, 6, 69, 189);
	      attr_dev(path1, "d", "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z");
	      add_location(path1, file$1c, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1c, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1d.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1d($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_downward', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_downward> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_downward extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_downward",
	      options,
	      id: create_fragment$1d.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_downward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_downward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_downward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_downward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_downward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_downward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1b = "src/material-icons/arrow-drop-up.svelte";
	function create_fragment$1c(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1b, 6, 69, 189);
	      attr_dev(path1, "d", "M7 14l5-5 5 5z");
	      add_location(path1, file$1b, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1b, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1c.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1c($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_drop_up', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_drop_up> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_drop_up extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_drop_up",
	      options,
	      id: create_fragment$1c.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_drop_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_drop_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_drop_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_drop_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_drop_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_drop_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$1a = "src/material-icons/arrow-forward.svelte";
	function create_fragment$1b(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$1a, 6, 69, 189);
	      attr_dev(path1, "d", "M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z");
	      add_location(path1, file$1a, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$1a, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1b.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1b($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_forward', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_forward> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_forward extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_forward",
	      options,
	      id: create_fragment$1b.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_forward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_forward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_forward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_forward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_forward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_forward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$19 = "src/material-icons/arrow-right.svelte";
	function create_fragment$1a(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M10 17l5-5-5-5v10z");
	      add_location(path0, file$19, 6, 69, 189);
	      attr_dev(path1, "d", "M0 24V0h24v24H0z");
	      attr_dev(path1, "fill", "none");
	      add_location(path1, file$19, 6, 99, 219);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$19, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1a.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1a($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_right', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_right> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_right extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_right",
	      options,
	      id: create_fragment$1a.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$18 = "src/material-icons/arrow-upward.svelte";
	function create_fragment$19(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$18, 6, 69, 189);
	      attr_dev(path1, "d", "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z");
	      add_location(path1, file$18, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$18, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$19.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$19($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Arrow_upward', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Arrow_upward> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Arrow_upward extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$19, create_fragment$19, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Arrow_upward",
	      options,
	      id: create_fragment$19.name
	    });
	  }
	  get size() {
	    throw new Error("<Arrow_upward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Arrow_upward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Arrow_upward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Arrow_upward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Arrow_upward>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Arrow_upward>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$17 = "src/material-icons/article.svelte";
	function create_fragment$18(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$17, 6, 69, 189);
	      attr_dev(path1, "d", "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z");
	      add_location(path1, file$17, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$17, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$18.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$18($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Article', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Article> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Article extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$18, create_fragment$18, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Article",
	      options,
	      id: create_fragment$18.name
	    });
	  }
	  get size() {
	    throw new Error("<Article>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Article>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Article>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Article>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Article>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Article>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$16 = "src/material-icons/bookmark-black.svelte";
	function create_fragment$17(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$16, 6, 69, 189);
	      attr_dev(path1, "d", "M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z");
	      add_location(path1, file$16, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$16, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$17.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$17($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Bookmark_black', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Bookmark_black> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Bookmark_black extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$17, create_fragment$17, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Bookmark_black",
	      options,
	      id: create_fragment$17.name
	    });
	  }
	  get size() {
	    throw new Error("<Bookmark_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Bookmark_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Bookmark_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Bookmark_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Bookmark_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Bookmark_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$15 = "src/material-icons/build.svelte";
	function create_fragment$16(ctx) {
	  let svg;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr_dev(path, "d", "M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z");
	      add_location(path, file$15, 5, 71, 190);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$15, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$16.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$16($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Build', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Build> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Build extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$16, create_fragment$16, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Build",
	      options,
	      id: create_fragment$16.name
	    });
	  }
	  get size() {
	    throw new Error("<Build>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Build>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Build>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Build>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Build>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Build>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$14 = "src/material-icons/calendar-today.svelte";
	function create_fragment$15(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$14, 5, 69, 188);
	      attr_dev(path1, "d", "M20 3h-1V1h-2v2H7V1H5v2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 18H4V8h16v13z");
	      add_location(path1, file$14, 5, 106, 225);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$14, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$15.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$15($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Calendar_today', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Calendar_today> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Calendar_today extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$15, create_fragment$15, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Calendar_today",
	      options,
	      id: create_fragment$15.name
	    });
	  }
	  get size() {
	    throw new Error("<Calendar_today>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Calendar_today>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Calendar_today>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Calendar_today>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Calendar_today>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Calendar_today>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$13 = "src/material-icons/cancel.svelte";
	function create_fragment$14(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$13, 5, 71, 190);
	      attr_dev(path1, "d", "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z");
	      add_location(path1, file$13, 5, 108, 227);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$13, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$14.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$14($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Cancel', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Cancel> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Cancel extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$14, create_fragment$14, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Cancel",
	      options,
	      id: create_fragment$14.name
	    });
	  }
	  get size() {
	    throw new Error("<Cancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Cancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Cancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Cancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Cancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Cancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$12 = "src/material-icons/cancel-presentation.svelte";
	function create_fragment$13(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  let path2;
	  let path3;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      path2 = svg_element("path");
	      path3 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$12, 5, 71, 190);
	      attr_dev(path1, "d", "M21 19.1H3V5h18v14.1zM21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
	      add_location(path1, file$12, 5, 108, 227);
	      attr_dev(path2, "d", "M21 19.1H3V5h18v14.1zM21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z");
	      attr_dev(path2, "fill", "none");
	      add_location(path2, file$12, 5, 217, 336);
	      attr_dev(path3, "d", "M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41z");
	      add_location(path3, file$12, 5, 338, 457);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$12, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	      append_dev(svg, path2);
	      append_dev(svg, path3);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$13.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$13($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Cancel_presentation', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Cancel_presentation> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Cancel_presentation extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$13, create_fragment$13, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Cancel_presentation",
	      options,
	      id: create_fragment$13.name
	    });
	  }
	  get size() {
	    throw new Error("<Cancel_presentation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Cancel_presentation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Cancel_presentation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Cancel_presentation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Cancel_presentation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Cancel_presentation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$11 = "src/material-icons/check-circle.svelte";
	function create_fragment$12(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$11, 5, 71, 190);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
	      add_location(path1, file$11, 5, 108, 227);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$11, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$12.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$12($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Check_circle', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Check_circle> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Check_circle extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$12, create_fragment$12, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Check_circle",
	      options,
	      id: create_fragment$12.name
	    });
	  }
	  get size() {
	    throw new Error("<Check_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Check_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Check_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Check_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Check_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Check_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$10 = "src/material-icons/chevron-left.svelte";
	function create_fragment$11(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$10, 6, 69, 189);
	      attr_dev(path1, "d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z");
	      add_location(path1, file$10, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$10, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$11.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$11($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Chevron_left', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Chevron_left> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Chevron_left extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$11, create_fragment$11, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Chevron_left",
	      options,
	      id: create_fragment$11.name
	    });
	  }
	  get size() {
	    throw new Error("<Chevron_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Chevron_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Chevron_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Chevron_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Chevron_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Chevron_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$$ = "src/material-icons/chevron-right.svelte";
	function create_fragment$10(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$$, 6, 69, 189);
	      attr_dev(path1, "d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z");
	      add_location(path1, file$$, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$$, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$10.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$10($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Chevron_right', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Chevron_right> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Chevron_right extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$10, create_fragment$10, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Chevron_right",
	      options,
	      id: create_fragment$10.name
	    });
	  }
	  get size() {
	    throw new Error("<Chevron_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Chevron_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Chevron_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Chevron_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Chevron_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Chevron_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$_ = "src/material-icons/circle.svelte";
	function create_fragment$$(ctx) {
	  let svg;
	  let path;
	  let circle;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      circle = svg_element("circle");
	      attr_dev(path, "d", "M24 24H0V0h24v24z");
	      attr_dev(path, "fill", "none");
	      add_location(path, file$_, 5, 71, 190);
	      attr_dev(circle, "cx", "12");
	      attr_dev(circle, "cy", "12");
	      attr_dev(circle, "r", "8");
	      add_location(circle, file$_, 5, 112, 231);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$_, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	      append_dev(svg, circle);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$$.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$$($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Circle', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Circle> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Circle extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$$, create_fragment$$, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Circle",
	      options,
	      id: create_fragment$$.name
	    });
	  }
	  get size() {
	    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$Z = "src/material-icons/close.svelte";
	function create_fragment$_(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$Z, 5, 71, 190);
	      attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
	      add_location(path1, file$Z, 5, 108, 227);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$Z, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$_.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$_($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Close', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Close> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Close extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$_, create_fragment$_, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Close",
	      options,
	      id: create_fragment$_.name
	    });
	  }
	  get size() {
	    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Close>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Close>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$Y = "src/material-icons/content-copy.svelte";
	function create_fragment$Z(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$Y, 5, 71, 190);
	      attr_dev(path1, "d", "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z");
	      add_location(path1, file$Y, 5, 108, 227);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$Y, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Z.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$Z($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Content_copy', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Content_copy> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Content_copy extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Content_copy",
	      options,
	      id: create_fragment$Z.name
	    });
	  }
	  get size() {
	    throw new Error("<Content_copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Content_copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Content_copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Content_copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Content_copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Content_copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$X = "src/material-icons/double-arrow.svelte";
	function create_fragment$Y(ctx) {
	  let svg;
	  let g0;
	  let rect;
	  let g2;
	  let g1;
	  let polygon0;
	  let polygon1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g0 = svg_element("g");
	      rect = svg_element("rect");
	      g2 = svg_element("g");
	      g1 = svg_element("g");
	      polygon0 = svg_element("polygon");
	      polygon1 = svg_element("polygon");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$X, 6, 72, 192);
	      add_location(g0, file$X, 6, 69, 189);
	      attr_dev(polygon0, "points", "15.5,5 11,5 16,12 11,19 15.5,19 20.5,12");
	      add_location(polygon0, file$X, 6, 124, 244);
	      attr_dev(polygon1, "points", "8.5,5 4,5 9,12 4,19 8.5,19 13.5,12");
	      add_location(polygon1, file$X, 6, 183, 303);
	      add_location(g1, file$X, 6, 121, 241);
	      add_location(g2, file$X, 6, 118, 238);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$X, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g0);
	      append_dev(g0, rect);
	      append_dev(svg, g2);
	      append_dev(g2, g1);
	      append_dev(g1, polygon0);
	      append_dev(g1, polygon1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Y.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$Y($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Double_arrow', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Double_arrow> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Double_arrow extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Double_arrow",
	      options,
	      id: create_fragment$Y.name
	    });
	  }
	  get size() {
	    throw new Error("<Double_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Double_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Double_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Double_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Double_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Double_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$W = "src/material-icons/download.svelte";
	function create_fragment$X(ctx) {
	  let svg;
	  let g0;
	  let rect;
	  let g1;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g0 = svg_element("g");
	      rect = svg_element("rect");
	      g1 = svg_element("g");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$W, 6, 72, 192);
	      add_location(g0, file$W, 6, 69, 189);
	      attr_dev(path, "d", "M5,20h14v-2H5V20z M19,9h-4V3H9v6H5l7,7L19,9z");
	      add_location(path, file$W, 6, 121, 241);
	      add_location(g1, file$W, 6, 118, 238);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$W, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g0);
	      append_dev(g0, rect);
	      append_dev(svg, g1);
	      append_dev(g1, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$X.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$X($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Download', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Download> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Download extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$X, create_fragment$X, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Download",
	      options,
	      id: create_fragment$X.name
	    });
	  }
	  get size() {
	    throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$V = "src/material-icons/download-white.svelte";
	function create_fragment$W(ctx) {
	  let svg;
	  let g0;
	  let rect;
	  let g1;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g0 = svg_element("g");
	      rect = svg_element("rect");
	      g1 = svg_element("g");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$V, 6, 72, 192);
	      add_location(g0, file$V, 6, 69, 189);
	      attr_dev(path, "d", "M5,20h14v-2H5V20z M19,9h-4V3H9v6H5l7,7L19,9z");
	      add_location(path, file$V, 6, 121, 241);
	      add_location(g1, file$V, 6, 118, 238);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$V, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g0);
	      append_dev(g0, rect);
	      append_dev(svg, g1);
	      append_dev(g1, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$W.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$W($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Download_white', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Download_white> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Download_white extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$W, create_fragment$W, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Download_white",
	      options,
	      id: create_fragment$W.name
	    });
	  }
	  get size() {
	    throw new Error("<Download_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Download_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Download_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Download_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Download_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Download_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$U = "src/material-icons/drafts.svelte";
	function create_fragment$V(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$U, 6, 69, 189);
	      attr_dev(path1, "d", "M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z");
	      add_location(path1, file$U, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$U, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$V.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$V($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Drafts', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Drafts> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Drafts extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$V, create_fragment$V, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Drafts",
	      options,
	      id: create_fragment$V.name
	    });
	  }
	  get size() {
	    throw new Error("<Drafts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Drafts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Drafts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Drafts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Drafts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Drafts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$T = "src/material-icons/edit.svelte";
	function create_fragment$U(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$T, 6, 71, 191);
	      attr_dev(path1, "d", "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z");
	      add_location(path1, file$T, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$T, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$U.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$U($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Edit', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Edit> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Edit extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$U, create_fragment$U, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Edit",
	      options,
	      id: create_fragment$U.name
	    });
	  }
	  get size() {
	    throw new Error("<Edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Edit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Edit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$S = "src/material-icons/expand-less.svelte";
	function create_fragment$T(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$S, 6, 71, 191);
	      attr_dev(path1, "d", "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z");
	      add_location(path1, file$S, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$S, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$T.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$T($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Expand_less', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Expand_less> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Expand_less extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$T, create_fragment$T, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Expand_less",
	      options,
	      id: create_fragment$T.name
	    });
	  }
	  get size() {
	    throw new Error("<Expand_less>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Expand_less>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Expand_less>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Expand_less>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Expand_less>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Expand_less>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$R = "src/material-icons/expand-more.svelte";
	function create_fragment$S(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$R, 6, 71, 191);
	      attr_dev(path1, "d", "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z");
	      add_location(path1, file$R, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$R, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$S.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$S($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Expand_more', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Expand_more> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Expand_more extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$S, create_fragment$S, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Expand_more",
	      options,
	      id: create_fragment$S.name
	    });
	  }
	  get size() {
	    throw new Error("<Expand_more>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Expand_more>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Expand_more>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Expand_more>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Expand_more>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Expand_more>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$Q = "src/material-icons/file-text.svelte";
	function create_fragment$R(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M5 4a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1H5zm-.5 2.5A.5.5 0 0 1 5 6h6a.5.5 0 0 1 0 1H5a.5.5 0 0 1-.5-.5zM5 8a.5.5 0 0 0 0 1h6a.5.5 0 0 0 0-1H5zm0 2a.5.5 0 0 0 0 1h3a.5.5 0 0 0 0-1H5z");
	      add_location(path0, file$Q, 7, 2, 192);
	      attr_dev(path1, "d", "M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2zm10-1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1z");
	      add_location(path1, file$Q, 8, 2, 384);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$Q, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$R.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$R($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('File_text', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<File_text> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class File_text extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$R, create_fragment$R, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "File_text",
	      options,
	      id: create_fragment$R.name
	    });
	  }
	  get size() {
	    throw new Error("<File_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<File_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<File_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<File_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<File_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<File_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$P = "src/material-icons/file-pdf.svelte";
	function create_fragment$Q(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4zm0 1h8a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1z");
	      add_location(path0, file$P, 6, 2, 193);
	      attr_dev(path1, "d", "M4.603 12.087a.81.81 0 0 1-.438-.42c-.195-.388-.13-.776.08-1.102.198-.307.526-.568.897-.787a7.68 7.68 0 0 1 1.482-.645 19.701 19.701 0 0 0 1.062-2.227 7.269 7.269 0 0 1-.43-1.295c-.086-.4-.119-.796-.046-1.136.075-.354.274-.672.65-.823.192-.077.4-.12.602-.077a.7.7 0 0 1 .477.365c.088.164.12.356.127.538.007.187-.012.395-.047.614-.084.51-.27 1.134-.52 1.794a10.954 10.954 0 0 0 .98 1.686 5.753 5.753 0 0 1 1.334.05c.364.065.734.195.96.465.12.144.193.32.2.518.007.192-.047.382-.138.563a1.04 1.04 0 0 1-.354.416.856.856 0 0 1-.51.138c-.331-.014-.654-.196-.933-.417a5.716 5.716 0 0 1-.911-.95 11.642 11.642 0 0 0-1.997.406 11.311 11.311 0 0 1-1.021 1.51c-.29.35-.608.655-.926.787a.793.793 0 0 1-.58.029zm1.379-1.901c-.166.076-.32.156-.459.238-.328.194-.541.383-.647.547-.094.145-.096.25-.04.361.01.022.02.036.026.044a.27.27 0 0 0 .035-.012c.137-.056.355-.235.635-.572a8.18 8.18 0 0 0 .45-.606zm1.64-1.33a12.647 12.647 0 0 1 1.01-.193 11.666 11.666 0 0 1-.51-.858 20.741 20.741 0 0 1-.5 1.05zm2.446.45c.15.162.296.3.435.41.24.19.407.253.498.256a.107.107 0 0 0 .07-.015.307.307 0 0 0 .094-.125.436.436 0 0 0 .059-.2.095.095 0 0 0-.026-.063c-.052-.062-.2-.152-.518-.209a3.881 3.881 0 0 0-.612-.053zM8.078 5.8a6.7 6.7 0 0 0 .2-.828c.031-.188.043-.343.038-.465a.613.613 0 0 0-.032-.198.517.517 0 0 0-.145.04c-.087.035-.158.106-.196.283-.04.192-.03.469.046.822.024.111.054.227.09.346z");
	      add_location(path1, file$P, 7, 2, 348);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$P, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$Q.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$Q($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('File_pdf', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 16 16"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<File_pdf> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class File_pdf extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "File_pdf",
	      options,
	      id: create_fragment$Q.name
	    });
	  }
	  get size() {
	    throw new Error("<File_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<File_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<File_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<File_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<File_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<File_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$O = "src/material-icons/file-pdf-fill.svelte";
	function create_fragment$P(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M5.523 10.424c.14-.082.293-.162.459-.238a7.878 7.878 0 0 1-.45.606c-.28.337-.498.516-.635.572a.266.266 0 0 1-.035.012.282.282 0 0 1-.026-.044c-.056-.11-.054-.216.04-.36.106-.165.319-.354.647-.548zm2.455-1.647c-.119.025-.237.05-.356.078a21.035 21.035 0 0 0 .5-1.05 11.96 11.96 0 0 0 .51.858c-.217.032-.436.07-.654.114zm2.525.939a3.888 3.888 0 0 1-.435-.41c.228.005.434.022.612.054.317.057.466.147.518.209a.095.095 0 0 1 .026.064.436.436 0 0 1-.06.2.307.307 0 0 1-.094.124.107.107 0 0 1-.069.015c-.09-.003-.258-.066-.498-.256zM8.278 4.97c-.04.244-.108.524-.2.829a4.86 4.86 0 0 1-.089-.346c-.076-.353-.087-.63-.046-.822.038-.177.11-.248.196-.283a.517.517 0 0 1 .145-.04c.013.03.028.092.032.198.005.122-.007.277-.038.465z");
	      add_location(path0, file$O, 6, 2, 193);
	      attr_dev(path1, "fill-rule", "evenodd");
	      attr_dev(path1, "d", "M4 0h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2zm.165 11.668c.09.18.23.343.438.419.207.075.412.04.58-.03.318-.13.635-.436.926-.786.333-.401.683-.927 1.021-1.51a11.64 11.64 0 0 1 1.997-.406c.3.383.61.713.91.95.28.22.603.403.934.417a.856.856 0 0 0 .51-.138c.155-.101.27-.247.354-.416.09-.181.145-.37.138-.563a.844.844 0 0 0-.2-.518c-.226-.27-.596-.4-.96-.465a5.76 5.76 0 0 0-1.335-.05 10.954 10.954 0 0 1-.98-1.686c.25-.66.437-1.284.52-1.794.036-.218.055-.426.048-.614a1.238 1.238 0 0 0-.127-.538.7.7 0 0 0-.477-.365c-.202-.043-.41 0-.601.077-.377.15-.576.47-.651.823-.073.34-.04.736.046 1.136.088.406.238.848.43 1.295a19.707 19.707 0 0 1-1.062 2.227 7.662 7.662 0 0 0-1.482.645c-.37.22-.699.48-.897.787-.21.326-.275.714-.08 1.103z");
	      add_location(path1, file$O, 7, 2, 925);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$O, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$P.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$P($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('File_pdf_fill', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<File_pdf_fill> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class File_pdf_fill extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$P, create_fragment$P, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "File_pdf_fill",
	      options,
	      id: create_fragment$P.name
	    });
	  }
	  get size() {
	    throw new Error("<File_pdf_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<File_pdf_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<File_pdf_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<File_pdf_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<File_pdf_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<File_pdf_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$N = "src/material-icons/first-page.svelte";
	function create_fragment$O(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z");
	      add_location(path0, file$N, 6, 69, 189);
	      attr_dev(path1, "d", "M24 24H0V0h24v24z");
	      attr_dev(path1, "fill", "none");
	      add_location(path1, file$N, 6, 139, 259);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$N, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$O.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$O($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('First_page', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<First_page> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class First_page extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$O, create_fragment$O, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "First_page",
	      options,
	      id: create_fragment$O.name
	    });
	  }
	  get size() {
	    throw new Error("<First_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<First_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<First_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<First_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<First_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<First_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$M = "src/material-icons/folder.svelte";
	function create_fragment$N(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$M, 6, 69, 189);
	      attr_dev(path1, "d", "M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z");
	      add_location(path1, file$M, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$M, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$N.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$N($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Folder', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Folder> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Folder extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$N, create_fragment$N, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Folder",
	      options,
	      id: create_fragment$N.name
	    });
	  }
	  get size() {
	    throw new Error("<Folder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Folder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Folder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Folder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Folder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Folder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$L = "src/material-icons/folder-open.svelte";
	function create_fragment$M(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$L, 6, 69, 189);
	      attr_dev(path1, "d", "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z");
	      add_location(path1, file$L, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$L, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$M.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$M($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Folder_open', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Folder_open> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Folder_open extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$M, create_fragment$M, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Folder_open",
	      options,
	      id: create_fragment$M.name
	    });
	  }
	  get size() {
	    throw new Error("<Folder_open>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Folder_open>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Folder_open>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Folder_open>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Folder_open>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Folder_open>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$K = "src/material-icons/github.svelte";
	function create_fragment$L(ctx) {
	  let svg;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr_dev(path, "d", "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z");
	      add_location(path, file$K, 7, 2, 192);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$K, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$L.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$L($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Github', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Github> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Github extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$L, create_fragment$L, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Github",
	      options,
	      id: create_fragment$L.name
	    });
	  }
	  get size() {
	    throw new Error("<Github>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Github>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Github>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Github>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Github>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Github>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$J = "src/material-icons/headphone.svelte";
	function create_fragment$K(ctx) {
	  let svg;
	  let g0;
	  let rect;
	  let g1;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g0 = svg_element("g");
	      rect = svg_element("rect");
	      g1 = svg_element("g");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$J, 7, 3, 193);
	      add_location(g0, file$J, 7, 0, 190);
	      attr_dev(path, "d", "M12,3c-4.97,0-9,4.03-9,9v7c0,1.1,0.9,2,2,2h4v-8H5v-1c0-3.87,3.13-7,7-7s7,3.13,7,7v1h-4v8h4c1.1,0,2-0.9,2-2v-7 C21,7.03,16.97,3,12,3z");
	      add_location(path, file$J, 7, 52, 242);
	      add_location(g1, file$J, 7, 49, 239);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$J, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g0);
	      append_dev(g0, rect);
	      append_dev(svg, g1);
	      append_dev(g1, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$K.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$K($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Headphone', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Headphone> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Headphone extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$K, create_fragment$K, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Headphone",
	      options,
	      id: create_fragment$K.name
	    });
	  }
	  get size() {
	    throw new Error("<Headphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Headphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Headphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Headphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Headphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Headphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$I = "src/material-icons/help.svelte";
	function create_fragment$J(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$I, 6, 69, 189);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z");
	      add_location(path1, file$I, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$I, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$J.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$J($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Help', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Help> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	let Help$1 = class Help extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$J, create_fragment$J, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Help",
	      options,
	      id: create_fragment$J.name
	    });
	  }
	  get size() {
	    throw new Error("<Help>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Help>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Help>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Help>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Help>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Help>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	const file$H = "src/material-icons/home.svelte";
	function create_fragment$I(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$H, 6, 69, 189);
	      attr_dev(path1, "d", "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z");
	      add_location(path1, file$H, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$H, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$I.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$I($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Home', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Home> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	let Home$1 = class Home extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$I, create_fragment$I, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Home",
	      options,
	      id: create_fragment$I.name
	    });
	  }
	  get size() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	const file$G = "src/material-icons/inbox.svelte";
	function create_fragment$H(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$G, 6, 69, 189);
	      attr_dev(path1, "d", "M19 3H4.99c-1.11 0-1.98.89-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10z");
	      add_location(path1, file$G, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$G, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$H.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$H($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Inbox', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Inbox> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Inbox extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$H, create_fragment$H, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Inbox",
	      options,
	      id: create_fragment$H.name
	    });
	  }
	  get size() {
	    throw new Error("<Inbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Inbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Inbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Inbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Inbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Inbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$F = "src/material-icons/info.svelte";
	function create_fragment$G(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$F, 6, 69, 189);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z");
	      add_location(path1, file$F, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$F, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$G.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$G($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Info', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Info> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Info extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$G, create_fragment$G, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Info",
	      options,
	      id: create_fragment$G.name
	    });
	  }
	  get size() {
	    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$E = "src/material-icons/keyboard.svelte";
	function create_fragment$F(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M20 5H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2V8zm0 3h2v2h-2v-2zM8 8h2v2H8V8zm0 3h2v2H8v-2zm-1 2H5v-2h2v2zm0-3H5V8h2v2zm9 7H8v-2h8v2zm0-4h-2v-2h2v2zm0-3h-2V8h2v2zm3 3h-2v-2h2v2zm0-3h-2V8h2v2z");
	      add_location(path0, file$E, 5, 69, 188);
	      attr_dev(path1, "d", "M0 0h24v24H0zm0 0h24v24H0z");
	      attr_dev(path1, "fill", "none");
	      add_location(path1, file$E, 5, 321, 440);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$E, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$F.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$F($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Keyboard', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Keyboard> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Keyboard extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$F, create_fragment$F, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Keyboard",
	      options,
	      id: create_fragment$F.name
	    });
	  }
	  get size() {
	    throw new Error("<Keyboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Keyboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Keyboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Keyboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Keyboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Keyboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$D = "src/material-icons/keyboard-arrow-up.svelte";
	function create_fragment$E(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$D, 6, 69, 189);
	      attr_dev(path1, "d", "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z");
	      add_location(path1, file$D, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$D, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$E.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$E($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Keyboard_arrow_up', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Keyboard_arrow_up> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Keyboard_arrow_up extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$E, create_fragment$E, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Keyboard_arrow_up",
	      options,
	      id: create_fragment$E.name
	    });
	  }
	  get size() {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Keyboard_arrow_up>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$C = "src/material-icons/last-page.svelte";
	function create_fragment$D(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$C, 6, 69, 189);
	      attr_dev(path1, "d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z");
	      add_location(path1, file$C, 6, 108, 228);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$C, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$D.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$D($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Last_page', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Last_page> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Last_page extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$D, create_fragment$D, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Last_page",
	      options,
	      id: create_fragment$D.name
	    });
	  }
	  get size() {
	    throw new Error("<Last_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Last_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Last_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Last_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Last_page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Last_page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$B = "src/material-icons/launch.svelte";
	function create_fragment$C(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$B, 6, 69, 189);
	      attr_dev(path1, "d", "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z");
	      add_location(path1, file$B, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$B, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$C.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$C($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Launch', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Launch> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Launch extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$C, create_fragment$C, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Launch",
	      options,
	      id: create_fragment$C.name
	    });
	  }
	  get size() {
	    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Launch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Launch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$A = "src/material-icons/mail-outline.svelte";
	function create_fragment$B(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$A, 6, 69, 189);
	      attr_dev(path1, "d", "M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H4V8l8 5 8-5v10zm-8-7L4 6h16l-8 5z");
	      add_location(path1, file$A, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$A, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$B.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$B($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Mail_outline', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Mail_outline> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Mail_outline extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$B, create_fragment$B, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Mail_outline",
	      options,
	      id: create_fragment$B.name
	    });
	  }
	  get size() {
	    throw new Error("<Mail_outline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Mail_outline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Mail_outline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Mail_outline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Mail_outline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Mail_outline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$z = "src/material-icons/menu.svelte";
	function create_fragment$A(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$z, 6, 69, 189);
	      attr_dev(path1, "d", "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z");
	      add_location(path1, file$z, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$z, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$A.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$A($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Menu', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Menu> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	let Menu$1 = class Menu extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$A, create_fragment$A, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Menu",
	      options,
	      id: create_fragment$A.name
	    });
	  }
	  get size() {
	    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	};

	const file$y = "src/material-icons/more-vert.svelte";
	function create_fragment$z(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$y, 6, 69, 189);
	      attr_dev(path1, "d", "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z");
	      add_location(path1, file$y, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$y, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$z.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$z($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('More_vert', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<More_vert> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class More_vert extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$z, create_fragment$z, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "More_vert",
	      options,
	      id: create_fragment$z.name
	    });
	  }
	  get size() {
	    throw new Error("<More_vert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<More_vert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<More_vert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<More_vert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<More_vert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<More_vert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$x = "src/material-icons/open-in-new.svelte";
	function create_fragment$y(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$x, 6, 69, 189);
	      attr_dev(path1, "d", "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z");
	      add_location(path1, file$x, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$x, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$y.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$y($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Open_in_new', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Open_in_new> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Open_in_new extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$y, create_fragment$y, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Open_in_new",
	      options,
	      id: create_fragment$y.name
	    });
	  }
	  get size() {
	    throw new Error("<Open_in_new>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Open_in_new>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Open_in_new>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Open_in_new>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Open_in_new>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Open_in_new>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$w = "src/material-icons/person.svelte";
	function create_fragment$x(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$w, 6, 69, 189);
	      attr_dev(path1, "d", "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z");
	      add_location(path1, file$w, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$w, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$x.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$x($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Person', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Person> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Person extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$x, create_fragment$x, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Person",
	      options,
	      id: create_fragment$x.name
	    });
	  }
	  get size() {
	    throw new Error("<Person>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Person>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Person>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Person>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Person>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Person>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$v = "src/material-icons/picture-as-pdf.svelte";
	function create_fragment$w(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$v, 5, 69, 188);
	      attr_dev(path1, "d", "M20 2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 7.5c0 .83-.67 1.5-1.5 1.5H9v2H7.5V7H10c.83 0 1.5.67 1.5 1.5v1zm5 2c0 .83-.67 1.5-1.5 1.5h-2.5V7H15c.83 0 1.5.67 1.5 1.5v3zm4-3H19v1h1.5V11H19v2h-1.5V7h3v1.5zM9 9.5h1v-1H9v1zM4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm10 5.5h1v-3h-1v3z");
	      add_location(path1, file$v, 5, 106, 225);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$v, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$w.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$w($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Picture_as_pdf', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Picture_as_pdf> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Picture_as_pdf extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$w, create_fragment$w, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Picture_as_pdf",
	      options,
	      id: create_fragment$w.name
	    });
	  }
	  get size() {
	    throw new Error("<Picture_as_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Picture_as_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Picture_as_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Picture_as_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Picture_as_pdf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Picture_as_pdf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$u = "src/material-icons/play-arrow.svelte";
	function create_fragment$v(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$u, 5, 69, 188);
	      attr_dev(path1, "d", "M8 5v14l11-7z");
	      add_location(path1, file$u, 5, 106, 225);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$u, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$v.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$v($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Play_arrow', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Play_arrow> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Play_arrow extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$v, create_fragment$v, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Play_arrow",
	      options,
	      id: create_fragment$v.name
	    });
	  }
	  get size() {
	    throw new Error("<Play_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Play_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Play_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Play_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Play_arrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Play_arrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$t = "src/material-icons/play-circle-filled.svelte";
	function create_fragment$u(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$t, 6, 69, 189);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z");
	      add_location(path1, file$t, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$t, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$u.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$u($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Play_circle_filled', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Play_circle_filled> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Play_circle_filled extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$u, create_fragment$u, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Play_circle_filled",
	      options,
	      id: create_fragment$u.name
	    });
	  }
	  get size() {
	    throw new Error("<Play_circle_filled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Play_circle_filled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Play_circle_filled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Play_circle_filled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Play_circle_filled>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Play_circle_filled>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$s = "src/material-icons/print.svelte";
	function create_fragment$t(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$s, 6, 69, 189);
	      attr_dev(path1, "d", "M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z");
	      add_location(path1, file$s, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$s, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$t.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$t($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Print', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Print> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Print extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$t, create_fragment$t, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Print",
	      options,
	      id: create_fragment$t.name
	    });
	  }
	  get size() {
	    throw new Error("<Print>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Print>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Print>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Print>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Print>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Print>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$r = "src/material-icons/print-white.svelte";
	function create_fragment$s(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$r, 6, 69, 189);
	      attr_dev(path1, "d", "M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z");
	      add_location(path1, file$r, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$r, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$s.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$s($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Print_white', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Print_white> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Print_white extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$s, create_fragment$s, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Print_white",
	      options,
	      id: create_fragment$s.name
	    });
	  }
	  get size() {
	    throw new Error("<Print_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Print_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Print_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Print_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Print_white>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Print_white>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$q = "src/material-icons/remove-circle.svelte";
	function create_fragment$r(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$q, 6, 69, 189);
	      attr_dev(path1, "d", "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z");
	      add_location(path1, file$q, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$q, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$r.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$r($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Remove_circle', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Remove_circle> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Remove_circle extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$r, create_fragment$r, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Remove_circle",
	      options,
	      id: create_fragment$r.name
	    });
	  }
	  get size() {
	    throw new Error("<Remove_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Remove_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Remove_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Remove_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Remove_circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Remove_circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$p = "src/material-icons/reply.svelte";
	function create_fragment$q(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$p, 6, 69, 189);
	      attr_dev(path1, "d", "M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z");
	      add_location(path1, file$p, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$p, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$q.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$q($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Reply', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Reply> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Reply extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$q, create_fragment$q, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Reply",
	      options,
	      id: create_fragment$q.name
	    });
	  }
	  get size() {
	    throw new Error("<Reply>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Reply>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Reply>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Reply>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Reply>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Reply>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$o = "src/material-icons/settings.svelte";
	function create_fragment$p(ctx) {
	  let svg;
	  let g;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g = svg_element("g");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0,0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$o, 6, 72, 192);
	      attr_dev(path1, "d", "M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z");
	      add_location(path1, file$o, 6, 111, 231);
	      add_location(g, file$o, 6, 69, 189);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$o, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g);
	      append_dev(g, path0);
	      append_dev(g, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$p.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$p($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Settings', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Settings> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Settings extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$p, create_fragment$p, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Settings",
	      options,
	      id: create_fragment$p.name
	    });
	  }
	  get size() {
	    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$n = "src/material-icons/send.svelte";
	function create_fragment$o(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$n, 6, 69, 189);
	      attr_dev(path1, "d", "M2.01 21L23 12 2.01 3 2 10l15 2-15 2z");
	      add_location(path1, file$n, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$n, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$o.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$o($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Send', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Send> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Send extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$o, create_fragment$o, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Send",
	      options,
	      id: create_fragment$o.name
	    });
	  }
	  get size() {
	    throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$m = "src/material-icons/share.svelte";
	function create_fragment$n(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$m, 6, 69, 189);
	      attr_dev(path1, "d", "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z");
	      add_location(path1, file$m, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$m, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$n.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$n($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Share', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Share> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Share extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$n, create_fragment$n, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Share",
	      options,
	      id: create_fragment$n.name
	    });
	  }
	  get size() {
	    throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$l = "src/material-icons/shopping-basket.svelte";
	function create_fragment$m(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$l, 6, 69, 189);
	      attr_dev(path1, "d", "M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z");
	      add_location(path1, file$l, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$l, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$m.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$m($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Shopping_basket', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Shopping_basket> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Shopping_basket extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$m, create_fragment$m, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Shopping_basket",
	      options,
	      id: create_fragment$m.name
	    });
	  }
	  get size() {
	    throw new Error("<Shopping_basket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Shopping_basket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Shopping_basket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Shopping_basket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Shopping_basket>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Shopping_basket>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$k = "src/material-icons/shopping-cart.svelte";
	function create_fragment$l(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$k, 6, 69, 189);
	      attr_dev(path1, "d", "M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z");
	      add_location(path1, file$k, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$k, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$l.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$l($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Shopping_cart', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Shopping_cart> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Shopping_cart extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$l, create_fragment$l, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Shopping_cart",
	      options,
	      id: create_fragment$l.name
	    });
	  }
	  get size() {
	    throw new Error("<Shopping_cart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Shopping_cart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Shopping_cart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Shopping_cart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Shopping_cart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Shopping_cart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$j = "src/material-icons/skip-next.svelte";
	function create_fragment$k(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$j, 6, 69, 189);
	      attr_dev(path1, "d", "M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z");
	      add_location(path1, file$j, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$j, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$k.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$k($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Skip_next', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Skip_next> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Skip_next extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$k, create_fragment$k, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Skip_next",
	      options,
	      id: create_fragment$k.name
	    });
	  }
	  get size() {
	    throw new Error("<Skip_next>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Skip_next>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Skip_next>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Skip_next>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Skip_next>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Skip_next>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$i = "src/material-icons/skip-previous.svelte";
	function create_fragment$j(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$i, 6, 69, 189);
	      attr_dev(path1, "d", "M6 6h2v12H6zm3.5 6l8.5 6V6z");
	      add_location(path1, file$i, 6, 106, 226);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$i, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$j.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$j($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Skip_previous', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Skip_previous> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Skip_previous extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$j, create_fragment$j, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Skip_previous",
	      options,
	      id: create_fragment$j.name
	    });
	  }
	  get size() {
	    throw new Error("<Skip_previous>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Skip_previous>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Skip_previous>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Skip_previous>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Skip_previous>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Skip_previous>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$h = "src/material-icons/source.svelte";
	function create_fragment$i(ctx) {
	  let svg;
	  let g;
	  let rect;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g = svg_element("g");
	      rect = svg_element("rect");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$h, 6, 72, 192);
	      attr_dev(path, "d", "M20,6h-8l-2-2H4C2.9,4,2.01,4.9,2.01,6L2,18c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V8C22,6.9,21.1,6,20,6z M14,16H6v-2h8V16z M18,12H6v-2h12V12z");
	      add_location(path, file$h, 6, 114, 234);
	      add_location(g, file$h, 6, 69, 189);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$h, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g);
	      append_dev(g, rect);
	      append_dev(g, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$i.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$i($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Source', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Source> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Source extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$i, create_fragment$i, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Source",
	      options,
	      id: create_fragment$i.name
	    });
	  }
	  get size() {
	    throw new Error("<Source>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Source>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Source>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Source>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Source>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Source>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$g = "src/material-icons/spinner.svelte";
	function create_fragment$h(ctx) {
	  let svg;
	  let g;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      g = svg_element("g");
	      path = svg_element("path");
	      attr_dev(path, "d", "M15.1,19.37l1,1.74c-0.96,0.44-2.01,0.73-3.1,0.84v-2.02C13.74,19.84,14.44,19.65,15.1,19.37z M4.07,13H2.05 c0.11,1.1,0.4,2.14,0.84,3.1l1.74-1C4.35,14.44,4.16,13.74,4.07,13z M15.1,4.63l1-1.74C15.14,2.45,14.1,2.16,13,2.05v2.02 C13.74,4.16,14.44,4.35,15.1,4.63z M19.93,11h2.02c-0.11-1.1-0.4-2.14-0.84-3.1l-1.74,1C19.65,9.56,19.84,10.26,19.93,11z M8.9,19.37l-1,1.74c0.96,0.44,2.01,0.73,3.1,0.84v-2.02C10.26,19.84,9.56,19.65,8.9,19.37z M11,4.07V2.05 c-1.1,0.11-2.14,0.4-3.1,0.84l1,1.74C9.56,4.35,10.26,4.16,11,4.07z M18.36,7.17l1.74-1.01c-0.63-0.87-1.4-1.64-2.27-2.27 l-1.01,1.74C17.41,6.08,17.92,6.59,18.36,7.17z M4.63,8.9l-1.74-1C2.45,8.86,2.16,9.9,2.05,11h2.02C4.16,10.26,4.35,9.56,4.63,8.9z M19.93,13c-0.09,0.74-0.28,1.44-0.56,2.1l1.74,1c0.44-0.96,0.73-2.01,0.84-3.1H19.93z M16.83,18.36l1.01,1.74 c0.87-0.63,1.64-1.4,2.27-2.27l-1.74-1.01C17.92,17.41,17.41,17.92,16.83,18.36z M7.17,5.64L6.17,3.89 C5.29,4.53,4.53,5.29,3.9,6.17l1.74,1.01C6.08,6.59,6.59,6.08,7.17,5.64z M5.64,16.83L3.9,17.83c0.63,0.87,1.4,1.64,2.27,2.27 l1.01-1.74C6.59,17.92,6.08,17.41,5.64,16.83z M13");
	      add_location(path, file$g, 6, 72, 192);
	      add_location(g, file$g, 6, 69, 189);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$g, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, g);
	      append_dev(g, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$h.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$h($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Spinner', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Spinner> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Spinner extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$h, create_fragment$h, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Spinner",
	      options,
	      id: create_fragment$h.name
	    });
	  }
	  get size() {
	    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$f = "src/material-icons/star.svelte";
	function create_fragment$g(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  let path2;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      path2 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$f, 6, 69, 189);
	      attr_dev(path1, "d", "M0 0h24v24H0z");
	      attr_dev(path1, "fill", "none");
	      add_location(path1, file$f, 6, 106, 226);
	      attr_dev(path2, "d", "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z");
	      add_location(path2, file$f, 6, 143, 263);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$f, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	      append_dev(svg, path2);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$g.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$g($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Star', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Star> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Star extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$g, create_fragment$g, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Star",
	      options,
	      id: create_fragment$g.name
	    });
	  }
	  get size() {
	    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$e = "src/material-icons/stop-black.svelte";
	function create_fragment$f(ctx) {
	  let svg;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr_dev(path, "d", "M6 6h12v12H6z");
	      add_location(path, file$e, 7, 69, 190);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$e, 7, 0, 121);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$f.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$f($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Stop_black', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Stop_black> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Stop_black extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$f, create_fragment$f, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Stop_black",
	      options,
	      id: create_fragment$f.name
	    });
	  }
	  get size() {
	    throw new Error("<Stop_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Stop_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Stop_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Stop_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Stop_black>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Stop_black>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$d = "src/material-icons/storage.svelte";
	function create_fragment$e(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$d, 5, 69, 188);
	      attr_dev(path1, "d", "M2 20h20v-4H2v4zm2-3h2v2H4v-2zM2 4v4h20V4H2zm4 3H4V5h2v2zm-4 7h20v-4H2v4zm2-3h2v2H4v-2z");
	      add_location(path1, file$d, 5, 106, 225);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$d, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$e.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$e($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Storage', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Storage> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Storage extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$e, create_fragment$e, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Storage",
	      options,
	      id: create_fragment$e.name
	    });
	  }
	  get size() {
	    throw new Error("<Storage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Storage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Storage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Storage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Storage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Storage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$c = "src/material-icons/subdirectory-arrow-right.svelte";
	function create_fragment$d(ctx) {
	  let svg;
	  let path0;
	  let path1;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path0 = svg_element("path");
	      path1 = svg_element("path");
	      attr_dev(path0, "d", "M0 0h24v24H0V0z");
	      attr_dev(path0, "fill", "none");
	      add_location(path0, file$c, 5, 69, 188);
	      attr_dev(path1, "d", "M19 15l-6 6-1.42-1.42L15.17 16H4V4h2v10h9.17l-3.59-3.58L13 9l6 6z");
	      add_location(path1, file$c, 5, 108, 227);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$c, 5, 0, 119);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path0);
	      append_dev(svg, path1);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$d.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$d($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Subdirectory_arrow_right', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Subdirectory_arrow_right> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Subdirectory_arrow_right extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$d, create_fragment$d, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Subdirectory_arrow_right",
	      options,
	      id: create_fragment$d.name
	    });
	  }
	  get size() {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Subdirectory_arrow_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$b = "src/material-icons/youtube.svelte";
	function create_fragment$c(ctx) {
	  let svg;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr_dev(path, "d", "M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31.4 31.4 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788 0 0 1 7.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z");
	      add_location(path, file$b, 7, 2, 194);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$b, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$c.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$c($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Youtube', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 16 16"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Youtube> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class Youtube extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$c, create_fragment$c, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Youtube",
	      options,
	      id: create_fragment$c.name
	    });
	  }
	  get size() {
	    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<Youtube>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<Youtube>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$a = "src/material-icons/view-list.svelte";
	function create_fragment$b(ctx) {
	  let svg;
	  let rect;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      rect = svg_element("rect");
	      path = svg_element("path");
	      attr_dev(rect, "fill", "none");
	      attr_dev(rect, "height", "24");
	      attr_dev(rect, "width", "24");
	      add_location(rect, file$a, 6, 69, 189);
	      attr_dev(path, "d", "M3,14h4v-4H3V14z M3,19h4v-4H3V19z M3,9h4V5H3V9z M8,14h13v-4H8V14z M8,19h13v-4H8V19z M8,5v4h13V5H8z");
	      add_location(path, file$a, 6, 111, 231);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$a, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, rect);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$b.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$b($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('View_list', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<View_list> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class View_list extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$b, create_fragment$b, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "View_list",
	      options,
	      id: create_fragment$b.name
	    });
	  }
	  get size() {
	    throw new Error("<View_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<View_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<View_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<View_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<View_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<View_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$9 = "src/material-icons/x-circle-fill.svelte";
	function create_fragment$a(ctx) {
	  let svg;
	  let path;
	  const block = {
	    c: function create() {
	      svg = svg_element("svg");
	      path = svg_element("path");
	      attr_dev(path, "d", "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM5.354 4.646a.5.5 0 1 0-.708.708L7.293 8l-2.647 2.646a.5.5 0 0 0 .708.708L8 8.707l2.646 2.647a.5.5 0 0 0 .708-.708L8.707 8l2.647-2.646a.5.5 0 0 0-.708-.708L8 7.293 5.354 4.646z");
	      add_location(path, file$9, 6, 71, 191);
	      attr_dev(svg, "fill", /*color*/ctx[1]);
	      attr_dev(svg, "width", /*size*/ctx[0]);
	      attr_dev(svg, "height", /*size*/ctx[0]);
	      attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      add_location(svg, file$9, 6, 0, 120);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, svg, anchor);
	      append_dev(svg, path);
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*color*/2) {
	        attr_dev(svg, "fill", /*color*/ctx[1]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "width", /*size*/ctx[0]);
	      }
	      if (dirty & /*size*/1) {
	        attr_dev(svg, "height", /*size*/ctx[0]);
	      }
	      if (dirty & /*viewBox*/4) {
	        attr_dev(svg, "viewBox", /*viewBox*/ctx[2]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(svg);
	      }
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$a.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$a($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('X_circle_fill', slots, []);
	  let {
	    size = "1em"
	  } = $$props;
	  let {
	    color = "currentColor"
	  } = $$props;
	  let {
	    viewBox = "0 0 24 24"
	  } = $$props;
	  const writable_props = ['size', 'color', 'viewBox'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<X_circle_fill> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$$set = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  $$self.$capture_state = () => ({
	    size,
	    color,
	    viewBox
	  });
	  $$self.$inject_state = $$props => {
	    if ('size' in $$props) $$invalidate(0, size = $$props.size);
	    if ('color' in $$props) $$invalidate(1, color = $$props.color);
	    if ('viewBox' in $$props) $$invalidate(2, viewBox = $$props.viewBox);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [size, color, viewBox];
	}
	class X_circle_fill extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$a, create_fragment$a, safe_not_equal, {
	      size: 0,
	      color: 1,
	      viewBox: 2
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "X_circle_fill",
	      options,
	      id: create_fragment$a.name
	    });
	  }
	  get size() {
	    throw new Error("<X_circle_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set size(value) {
	    throw new Error("<X_circle_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get color() {
	    throw new Error("<X_circle_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set color(value) {
	    throw new Error("<X_circle_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get viewBox() {
	    throw new Error("<X_circle_fill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set viewBox(value) {
	    throw new Error("<X_circle_fill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */

	var extendStatics = function (d, b) {
	  extendStatics = Object.setPrototypeOf || {
	    __proto__: []
	  } instanceof Array && function (d, b) {
	    d.__proto__ = b;
	  } || function (d, b) {
	    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	  };
	  return extendStatics(d, b);
	};
	function __extends(d, b) {
	  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	  extendStatics(d, b);
	  function __() {
	    this.constructor = d;
	  }
	  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}
	var __assign = function () {
	  __assign = Object.assign || function __assign(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	      s = arguments[i];
	      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	    }
	    return t;
	  };
	  return __assign.apply(this, arguments);
	};
	function __decorate(decorators, target, key, desc) {
	  var c = arguments.length,
	    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
	    d;
	  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	}
	function __values(o) {
	  var s = typeof Symbol === "function" && Symbol.iterator,
	    m = s && o[s],
	    i = 0;
	  if (m) return m.call(o);
	  if (o && typeof o.length === "number") return {
	    next: function () {
	      if (o && i >= o.length) o = void 0;
	      return {
	        value: o && o[i++],
	        done: !o
	      };
	    }
	  };
	  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	  var e = new Error(message);
	  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const e$8 = e => n => "function" == typeof n ? ((e, n) => (customElements.define(e, n), n))(e, n) : ((e, n) => {
	  const {
	    kind: t,
	    elements: s
	  } = n;
	  return {
	    kind: t,
	    elements: s,
	    finisher(n) {
	      customElements.define(e, n);
	    }
	  };
	})(e, n);

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const i$5 = (i, e) => "method" === e.kind && e.descriptor && !("value" in e.descriptor) ? {
	    ...e,
	    finisher(n) {
	      n.createProperty(e.key, i);
	    }
	  } : {
	    kind: "field",
	    key: Symbol(),
	    placement: "own",
	    descriptor: {},
	    originalKey: e.key,
	    initializer() {
	      "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this));
	    },
	    finisher(n) {
	      n.createProperty(e.key, i);
	    }
	  },
	  e$7 = (i, e, n) => {
	    e.constructor.createProperty(n, i);
	  };
	function n$6(n) {
	  return (t, o) => void 0 !== o ? e$7(n, t, o) : i$5(n, t);
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function t$3(t) {
	  return n$6({
	    ...t,
	    state: !0
	  });
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const o$7 = _ref => {
	    let {
	      finisher: e,
	      descriptor: t
	    } = _ref;
	    return (o, n) => {
	      var r;
	      if (void 0 === n) {
	        const n = null !== (r = o.originalKey) && void 0 !== r ? r : o.key,
	          i = null != t ? {
	            kind: "method",
	            placement: "prototype",
	            key: n,
	            descriptor: t(o.key)
	          } : {
	            ...o,
	            key: n
	          };
	        return null != e && (i.finisher = function (t) {
	          e(t, n);
	        }), i;
	      }
	      {
	        const r = o.constructor;
	        void 0 !== t && Object.defineProperty(o, n, t(n)), null == e || e(r, n);
	      }
	    };
	  };

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function e$6(e) {
	  return o$7({
	    finisher: (r, t) => {
	      Object.assign(r.prototype[t], e);
	    }
	  });
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function i$4(i, n) {
	  return o$7({
	    descriptor: o => {
	      const t = {
	        get() {
	          var o, n;
	          return null !== (n = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(i)) && void 0 !== n ? n : null;
	        },
	        enumerable: !0,
	        configurable: !0
	      };
	      if (n) {
	        const n = "symbol" == typeof o ? Symbol() : "__" + o;
	        t.get = function () {
	          var o, t;
	          return void 0 === this[n] && (this[n] = null !== (t = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(i)) && void 0 !== t ? t : null), this[n];
	        };
	      }
	      return t;
	    }
	  });
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function e$5(e) {
	  return o$7({
	    descriptor: r => ({
	      async get() {
	        var r;
	        return await this.updateComplete, null === (r = this.renderRoot) || void 0 === r ? void 0 : r.querySelector(e);
	      },
	      enumerable: !0,
	      configurable: !0
	    })
	  });
	}

	/**
	 * @license
	 * Copyright 2021 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	var n$5;
	const e$4 = null != (null === (n$5 = window.HTMLSlotElement) || void 0 === n$5 ? void 0 : n$5.prototype.assignedElements) ? (o, n) => o.assignedElements(n) : (o, n) => o.assignedNodes(n).filter(o => o.nodeType === Node.ELEMENT_NODE);
	function l$4(n) {
	  const {
	    slot: l,
	    selector: t
	  } = null != n ? n : {};
	  return o$7({
	    descriptor: o => ({
	      get() {
	        var o;
	        const r = "slot" + (l ? "[name=".concat(l, "]") : ":not([name])"),
	          i = null === (o = this.renderRoot) || void 0 === o ? void 0 : o.querySelector(r),
	          s = null != i ? e$4(i, n) : [];
	        return t ? s.filter(o => o.matches(t)) : s;
	      },
	      enumerable: !0,
	      configurable: !0
	    })
	  });
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	function o$6(o, n, r) {
	  let l,
	    s = o;
	  return "object" == typeof o ? (s = o.slot, l = o) : l = {
	    flatten: n
	  }, r ? l$4({
	    slot: s,
	    flatten: n,
	    selector: r
	  }) : o$7({
	    descriptor: e => ({
	      get() {
	        var e, t;
	        const o = "slot" + (s ? "[name=".concat(s, "]") : ":not([name])"),
	          n = null === (e = this.renderRoot) || void 0 === e ? void 0 : e.querySelector(o);
	        return null !== (t = null == n ? void 0 : n.assignedNodes(l)) && void 0 !== t ? t : [];
	      },
	      enumerable: !0,
	      configurable: !0
	    })
	  });
	}

	function _taggedTemplateLiteral(strings, raw) {
	  if (!raw) {
	    raw = strings.slice(0);
	  }
	  return Object.freeze(Object.defineProperties(strings, {
	    raw: {
	      value: Object.freeze(raw)
	    }
	  }));
	}

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module
	var addToUnscopables = addToUnscopables$2;

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('flat');

	/**
	 * @license
	 * Copyright 2019 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const t$2 = window,
	  e$3 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
	  s$3 = Symbol(),
	  n$4 = new WeakMap();
	let o$5 = class o {
	  constructor(t, e, n) {
	    if (this._$cssResult$ = !0, n !== s$3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
	    this.cssText = t, this.t = e;
	  }
	  get styleSheet() {
	    let t = this.o;
	    const s = this.t;
	    if (e$3 && void 0 === t) {
	      const e = void 0 !== s && 1 === s.length;
	      e && (t = n$4.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), e && n$4.set(s, t));
	    }
	    return t;
	  }
	  toString() {
	    return this.cssText;
	  }
	};
	const r$2 = t => new o$5("string" == typeof t ? t : t + "", void 0, s$3),
	  i$3 = function (t) {
	    for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      e[_key - 1] = arguments[_key];
	    }
	    const n = 1 === t.length ? t[0] : e.reduce((e, s, n) => e + (t => {
	      if (!0 === t._$cssResult$) return t.cssText;
	      if ("number" == typeof t) return t;
	      throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
	    })(s) + t[n + 1], t[0]);
	    return new o$5(n, t, s$3);
	  },
	  S$1 = (s, n) => {
	    e$3 ? s.adoptedStyleSheets = n.map(t => t instanceof CSSStyleSheet ? t : t.styleSheet) : n.forEach(e => {
	      const n = document.createElement("style"),
	        o = t$2.litNonce;
	      void 0 !== o && n.setAttribute("nonce", o), n.textContent = e.cssText, s.appendChild(n);
	    });
	  },
	  c$1 = e$3 ? t => t : t => t instanceof CSSStyleSheet ? (t => {
	    let e = "";
	    for (const s of t.cssRules) e += s.cssText;
	    return r$2(e);
	  })(t) : t;

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	var s$2;
	const e$2 = window,
	  r$1 = e$2.trustedTypes,
	  h$1 = r$1 ? r$1.emptyScript : "",
	  o$4 = e$2.reactiveElementPolyfillSupport,
	  n$3 = {
	    toAttribute(t, i) {
	      switch (i) {
	        case Boolean:
	          t = t ? h$1 : null;
	          break;
	        case Object:
	        case Array:
	          t = null == t ? t : JSON.stringify(t);
	      }
	      return t;
	    },
	    fromAttribute(t, i) {
	      let s = t;
	      switch (i) {
	        case Boolean:
	          s = null !== t;
	          break;
	        case Number:
	          s = null === t ? null : Number(t);
	          break;
	        case Object:
	        case Array:
	          try {
	            s = JSON.parse(t);
	          } catch (t) {
	            s = null;
	          }
	      }
	      return s;
	    }
	  },
	  a$1 = (t, i) => i !== t && (i == i || t == t),
	  l$3 = {
	    attribute: !0,
	    type: String,
	    converter: n$3,
	    reflect: !1,
	    hasChanged: a$1
	  },
	  d$1 = "finalized";
	let u$1 = class u extends HTMLElement {
	  constructor() {
	    super(), this._$Ei = new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu();
	  }
	  static addInitializer(t) {
	    var i;
	    this.finalize(), (null !== (i = this.h) && void 0 !== i ? i : this.h = []).push(t);
	  }
	  static get observedAttributes() {
	    this.finalize();
	    const t = [];
	    return this.elementProperties.forEach((i, s) => {
	      const e = this._$Ep(s, i);
	      void 0 !== e && (this._$Ev.set(e, s), t.push(e));
	    }), t;
	  }
	  static createProperty(t) {
	    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : l$3;
	    if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {
	      const s = "symbol" == typeof t ? Symbol() : "__" + t,
	        e = this.getPropertyDescriptor(t, s, i);
	      void 0 !== e && Object.defineProperty(this.prototype, t, e);
	    }
	  }
	  static getPropertyDescriptor(t, i, s) {
	    return {
	      get() {
	        return this[i];
	      },
	      set(e) {
	        const r = this[t];
	        this[i] = e, this.requestUpdate(t, r, s);
	      },
	      configurable: !0,
	      enumerable: !0
	    };
	  }
	  static getPropertyOptions(t) {
	    return this.elementProperties.get(t) || l$3;
	  }
	  static finalize() {
	    if (this.hasOwnProperty(d$1)) return !1;
	    this[d$1] = !0;
	    const t = Object.getPrototypeOf(this);
	    if (t.finalize(), void 0 !== t.h && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map(), this.hasOwnProperty("properties")) {
	      const t = this.properties,
	        i = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];
	      for (const s of i) this.createProperty(s, t[s]);
	    }
	    return this.elementStyles = this.finalizeStyles(this.styles), !0;
	  }
	  static finalizeStyles(i) {
	    const s = [];
	    if (Array.isArray(i)) {
	      const e = new Set(i.flat(1 / 0).reverse());
	      for (const i of e) s.unshift(c$1(i));
	    } else void 0 !== i && s.push(c$1(i));
	    return s;
	  }
	  static _$Ep(t, i) {
	    const s = i.attribute;
	    return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0;
	  }
	  _$Eu() {
	    var t;
	    this._$E_ = new Promise(t => this.enableUpdating = t), this._$AL = new Map(), this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach(t => t(this));
	  }
	  addController(t) {
	    var i, s;
	    (null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t));
	  }
	  removeController(t) {
	    var i;
	    null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1);
	  }
	  _$Eg() {
	    this.constructor.elementProperties.forEach((t, i) => {
	      this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i]);
	    });
	  }
	  createRenderRoot() {
	    var t;
	    const s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
	    return S$1(s, this.constructor.elementStyles), s;
	  }
	  connectedCallback() {
	    var t;
	    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
	      var i;
	      return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t);
	    });
	  }
	  enableUpdating(t) {}
	  disconnectedCallback() {
	    var t;
	    null === (t = this._$ES) || void 0 === t || t.forEach(t => {
	      var i;
	      return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t);
	    });
	  }
	  attributeChangedCallback(t, i, s) {
	    this._$AK(t, s);
	  }
	  _$EO(t, i) {
	    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : l$3;
	    var e;
	    const r = this.constructor._$Ep(t, s);
	    if (void 0 !== r && !0 === s.reflect) {
	      const h = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : n$3).toAttribute(i, s.type);
	      this._$El = t, null == h ? this.removeAttribute(r) : this.setAttribute(r, h), this._$El = null;
	    }
	  }
	  _$AK(t, i) {
	    var s;
	    const e = this.constructor,
	      r = e._$Ev.get(t);
	    if (void 0 !== r && this._$El !== r) {
	      const t = e.getPropertyOptions(r),
	        h = "function" == typeof t.converter ? {
	          fromAttribute: t.converter
	        } : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : n$3;
	      this._$El = r, this[r] = h.fromAttribute(i, t.type), this._$El = null;
	    }
	  }
	  requestUpdate(t, i, s) {
	    let e = !0;
	    void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || a$1)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map()), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej());
	  }
	  async _$Ej() {
	    this.isUpdatePending = !0;
	    try {
	      await this._$E_;
	    } catch (t) {
	      Promise.reject(t);
	    }
	    const t = this.scheduleUpdate();
	    return null != t && (await t), !this.isUpdatePending;
	  }
	  scheduleUpdate() {
	    return this.performUpdate();
	  }
	  performUpdate() {
	    var t;
	    if (!this.isUpdatePending) return;
	    this.hasUpdated, this._$Ei && (this._$Ei.forEach((t, i) => this[i] = t), this._$Ei = void 0);
	    let i = !1;
	    const s = this._$AL;
	    try {
	      i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
	        var i;
	        return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t);
	      }), this.update(s)) : this._$Ek();
	    } catch (t) {
	      throw i = !1, this._$Ek(), t;
	    }
	    i && this._$AE(s);
	  }
	  willUpdate(t) {}
	  _$AE(t) {
	    var i;
	    null === (i = this._$ES) || void 0 === i || i.forEach(t => {
	      var i;
	      return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t);
	    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
	  }
	  _$Ek() {
	    this._$AL = new Map(), this.isUpdatePending = !1;
	  }
	  get updateComplete() {
	    return this.getUpdateComplete();
	  }
	  getUpdateComplete() {
	    return this._$E_;
	  }
	  shouldUpdate(t) {
	    return !0;
	  }
	  update(t) {
	    void 0 !== this._$EC && (this._$EC.forEach((t, i) => this._$EO(i, this[i], t)), this._$EC = void 0), this._$Ek();
	  }
	  updated(t) {}
	  firstUpdated(t) {}
	};
	u$1[d$1] = !0, u$1.elementProperties = new Map(), u$1.elementStyles = [], u$1.shadowRootOptions = {
	  mode: "open"
	}, null == o$4 || o$4({
	  ReactiveElement: u$1
	}), (null !== (s$2 = e$2.reactiveElementVersions) && void 0 !== s$2 ? s$2 : e$2.reactiveElementVersions = []).push("1.6.3");

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	var t$1;
	const i$2 = window,
	  s$1 = i$2.trustedTypes,
	  e$1 = s$1 ? s$1.createPolicy("lit-html", {
	    createHTML: t => t
	  }) : void 0,
	  o$3 = "$lit$",
	  n$2 = "lit$".concat((Math.random() + "").slice(9), "$"),
	  l$2 = "?" + n$2,
	  h = "<".concat(l$2, ">"),
	  r = document,
	  u = () => r.createComment(""),
	  d = t => null === t || "object" != typeof t && "function" != typeof t,
	  c = Array.isArray,
	  v = t => c(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]),
	  a = "[ \t\n\f\r]",
	  f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
	  _ = /-->/g,
	  m = />/g,
	  p = RegExp(">|".concat(a, "(?:([^\\s\"'>=/]+)(").concat(a, "*=").concat(a, "*(?:[^ \t\n\f\r\"'`<>=]|(\"|')|))|$)"), "g"),
	  g = /'/g,
	  $$1 = /"/g,
	  y = /^(?:script|style|textarea|title)$/i,
	  w = t => function (i) {
	    for (var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      s[_key - 1] = arguments[_key];
	    }
	    return {
	      _$litType$: t,
	      strings: i,
	      values: s
	    };
	  },
	  x = w(1),
	  T = Symbol.for("lit-noChange"),
	  A = Symbol.for("lit-nothing"),
	  E = new WeakMap(),
	  C = r.createTreeWalker(r, 129, null, !1);
	function P(t, i) {
	  if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
	  return void 0 !== e$1 ? e$1.createHTML(i) : i;
	}
	const V = (t, i) => {
	  const s = t.length - 1,
	    e = [];
	  let l,
	    r = 2 === i ? "<svg>" : "",
	    u = f;
	  for (let i = 0; i < s; i++) {
	    const s = t[i];
	    let d,
	      c,
	      v = -1,
	      a = 0;
	    for (; a < s.length && (u.lastIndex = a, c = u.exec(s), null !== c);) a = u.lastIndex, u === f ? "!--" === c[1] ? u = _ : void 0 !== c[1] ? u = m : void 0 !== c[2] ? (y.test(c[2]) && (l = RegExp("</" + c[2], "g")), u = p) : void 0 !== c[3] && (u = p) : u === p ? ">" === c[0] ? (u = null != l ? l : f, v = -1) : void 0 === c[1] ? v = -2 : (v = u.lastIndex - c[2].length, d = c[1], u = void 0 === c[3] ? p : '"' === c[3] ? $$1 : g) : u === $$1 || u === g ? u = p : u === _ || u === m ? u = f : (u = p, l = void 0);
	    const w = u === p && t[i + 1].startsWith("/>") ? " " : "";
	    r += u === f ? s + h : v >= 0 ? (e.push(d), s.slice(0, v) + o$3 + s.slice(v) + n$2 + w) : s + n$2 + (-2 === v ? (e.push(void 0), i) : w);
	  }
	  return [P(t, r + (t[s] || "<?>") + (2 === i ? "</svg>" : "")), e];
	};
	class N {
	  constructor(_ref, e) {
	    let {
	      strings: t,
	      _$litType$: i
	    } = _ref;
	    let h;
	    this.parts = [];
	    let r = 0,
	      d = 0;
	    const c = t.length - 1,
	      v = this.parts,
	      [a, f] = V(t, i);
	    if (this.el = N.createElement(a, e), C.currentNode = this.el.content, 2 === i) {
	      const t = this.el.content,
	        i = t.firstChild;
	      i.remove(), t.append(...i.childNodes);
	    }
	    for (; null !== (h = C.nextNode()) && v.length < c;) {
	      if (1 === h.nodeType) {
	        if (h.hasAttributes()) {
	          const t = [];
	          for (const i of h.getAttributeNames()) if (i.endsWith(o$3) || i.startsWith(n$2)) {
	            const s = f[d++];
	            if (t.push(i), void 0 !== s) {
	              const t = h.getAttribute(s.toLowerCase() + o$3).split(n$2),
	                i = /([.?@])?(.*)/.exec(s);
	              v.push({
	                type: 1,
	                index: r,
	                name: i[2],
	                strings: t,
	                ctor: "." === i[1] ? H : "?" === i[1] ? L : "@" === i[1] ? z : k
	              });
	            } else v.push({
	              type: 6,
	              index: r
	            });
	          }
	          for (const i of t) h.removeAttribute(i);
	        }
	        if (y.test(h.tagName)) {
	          const t = h.textContent.split(n$2),
	            i = t.length - 1;
	          if (i > 0) {
	            h.textContent = s$1 ? s$1.emptyScript : "";
	            for (let s = 0; s < i; s++) h.append(t[s], u()), C.nextNode(), v.push({
	              type: 2,
	              index: ++r
	            });
	            h.append(t[i], u());
	          }
	        }
	      } else if (8 === h.nodeType) if (h.data === l$2) v.push({
	        type: 2,
	        index: r
	      });else {
	        let t = -1;
	        for (; -1 !== (t = h.data.indexOf(n$2, t + 1));) v.push({
	          type: 7,
	          index: r
	        }), t += n$2.length - 1;
	      }
	      r++;
	    }
	  }
	  static createElement(t, i) {
	    const s = r.createElement("template");
	    return s.innerHTML = t, s;
	  }
	}
	function S(t, i) {
	  let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : t;
	  let e = arguments.length > 3 ? arguments[3] : undefined;
	  var o, n, l, h;
	  if (i === T) return i;
	  let r = void 0 !== e ? null === (o = s._$Co) || void 0 === o ? void 0 : o[e] : s._$Cl;
	  const u = d(i) ? void 0 : i._$litDirective$;
	  return (null == r ? void 0 : r.constructor) !== u && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Co) && void 0 !== l ? l : h._$Co = [])[e] = r : s._$Cl = r), void 0 !== r && (i = S(t, r._$AS(t, i.values), r, e)), i;
	}
	class M {
	  constructor(t, i) {
	    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;
	  }
	  get parentNode() {
	    return this._$AM.parentNode;
	  }
	  get _$AU() {
	    return this._$AM._$AU;
	  }
	  u(t) {
	    var i;
	    const {
	        el: {
	          content: s
	        },
	        parts: e
	      } = this._$AD,
	      o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : r).importNode(s, !0);
	    C.currentNode = o;
	    let n = C.nextNode(),
	      l = 0,
	      h = 0,
	      u = e[0];
	    for (; void 0 !== u;) {
	      if (l === u.index) {
	        let i;
	        2 === u.type ? i = new R(n, n.nextSibling, this, t) : 1 === u.type ? i = new u.ctor(n, u.name, u.strings, this, t) : 6 === u.type && (i = new Z(n, this, t)), this._$AV.push(i), u = e[++h];
	      }
	      l !== (null == u ? void 0 : u.index) && (n = C.nextNode(), l++);
	    }
	    return C.currentNode = r, o;
	  }
	  v(t) {
	    let i = 0;
	    for (const s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;
	  }
	}
	class R {
	  constructor(t, i, s, e) {
	    var o;
	    this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cp = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;
	  }
	  get _$AU() {
	    var t, i;
	    return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cp;
	  }
	  get parentNode() {
	    let t = this._$AA.parentNode;
	    const i = this._$AM;
	    return void 0 !== i && 11 === (null == t ? void 0 : t.nodeType) && (t = i.parentNode), t;
	  }
	  get startNode() {
	    return this._$AA;
	  }
	  get endNode() {
	    return this._$AB;
	  }
	  _$AI(t) {
	    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	    t = S(this, t, i), d(t) ? t === A || null == t || "" === t ? (this._$AH !== A && this._$AR(), this._$AH = A) : t !== this._$AH && t !== T && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : v(t) ? this.T(t) : this._(t);
	  }
	  k(t) {
	    return this._$AA.parentNode.insertBefore(t, this._$AB);
	  }
	  $(t) {
	    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));
	  }
	  _(t) {
	    this._$AH !== A && d(this._$AH) ? this._$AA.nextSibling.data = t : this.$(r.createTextNode(t)), this._$AH = t;
	  }
	  g(t) {
	    var i;
	    const {
	        values: s,
	        _$litType$: e
	      } = t,
	      o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = N.createElement(P(e.h, e.h[0]), this.options)), e);
	    if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.v(s);else {
	      const t = new M(o, this),
	        i = t.u(this.options);
	      t.v(s), this.$(i), this._$AH = t;
	    }
	  }
	  _$AC(t) {
	    let i = E.get(t.strings);
	    return void 0 === i && E.set(t.strings, i = new N(t)), i;
	  }
	  T(t) {
	    c(this._$AH) || (this._$AH = [], this._$AR());
	    const i = this._$AH;
	    let s,
	      e = 0;
	    for (const o of t) e === i.length ? i.push(s = new R(this.k(u()), this.k(u()), this, this.options)) : s = i[e], s._$AI(o), e++;
	    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);
	  }
	  _$AR() {
	    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._$AA.nextSibling;
	    let i = arguments.length > 1 ? arguments[1] : undefined;
	    var s;
	    for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {
	      const i = t.nextSibling;
	      t.remove(), t = i;
	    }
	  }
	  setConnected(t) {
	    var i;
	    void 0 === this._$AM && (this._$Cp = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));
	  }
	}
	class k {
	  constructor(t, i, s, e, o) {
	    this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = A;
	  }
	  get tagName() {
	    return this.element.tagName;
	  }
	  get _$AU() {
	    return this._$AM._$AU;
	  }
	  _$AI(t) {
	    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	    let s = arguments.length > 2 ? arguments[2] : undefined;
	    let e = arguments.length > 3 ? arguments[3] : undefined;
	    const o = this.strings;
	    let n = !1;
	    if (void 0 === o) t = S(this, t, i, 0), n = !d(t) || t !== this._$AH && t !== T, n && (this._$AH = t);else {
	      const e = t;
	      let l, h;
	      for (t = o[0], l = 0; l < o.length - 1; l++) h = S(this, e[s + l], i, l), h === T && (h = this._$AH[l]), n || (n = !d(h) || h !== this._$AH[l]), h === A ? t = A : t !== A && (t += (null != h ? h : "") + o[l + 1]), this._$AH[l] = h;
	    }
	    n && !e && this.j(t);
	  }
	  j(t) {
	    t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");
	  }
	}
	class H extends k {
	  constructor() {
	    super(...arguments), this.type = 3;
	  }
	  j(t) {
	    this.element[this.name] = t === A ? void 0 : t;
	  }
	}
	const I = s$1 ? s$1.emptyScript : "";
	class L extends k {
	  constructor() {
	    super(...arguments), this.type = 4;
	  }
	  j(t) {
	    t && t !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);
	  }
	}
	class z extends k {
	  constructor(t, i, s, e, o) {
	    super(t, i, s, e, o), this.type = 5;
	  }
	  _$AI(t) {
	    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
	    var s;
	    if ((t = null !== (s = S(this, t, i, 0)) && void 0 !== s ? s : A) === T) return;
	    const e = this._$AH,
	      o = t === A && e !== A || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,
	      n = t !== A && (e === A || o);
	    o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;
	  }
	  handleEvent(t) {
	    var i, s;
	    "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);
	  }
	}
	class Z {
	  constructor(t, i, s) {
	    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;
	  }
	  get _$AU() {
	    return this._$AM._$AU;
	  }
	  _$AI(t) {
	    S(this, t);
	  }
	}
	const B = i$2.litHtmlPolyfillSupport;
	null == B || B(N, R), (null !== (t$1 = i$2.litHtmlVersions) && void 0 !== t$1 ? t$1 : i$2.litHtmlVersions = []).push("2.8.0");
	const D = (t, i, s) => {
	  var e, o;
	  const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;
	  let l = n._$litPart$;
	  if (void 0 === l) {
	    const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;
	    n._$litPart$ = l = new R(i.insertBefore(u(), t), t, void 0, null != s ? s : {});
	  }
	  return l._$AI(t), l;
	};

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	var l$1, o$2;
	class s extends u$1 {
	  constructor() {
	    super(...arguments), this.renderOptions = {
	      host: this
	    }, this._$Do = void 0;
	  }
	  createRenderRoot() {
	    var t, e;
	    const i = super.createRenderRoot();
	    return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = i.firstChild), i;
	  }
	  update(t) {
	    const i = this.render();
	    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = D(i, this.renderRoot, this.renderOptions);
	  }
	  connectedCallback() {
	    var t;
	    super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0);
	  }
	  disconnectedCallback() {
	    var t;
	    super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1);
	  }
	  render() {
	    return T;
	  }
	}
	s.finalized = !0, s._$litElement$ = !0, null === (l$1 = globalThis.litElementHydrateSupport) || void 0 === l$1 || l$1.call(globalThis, {
	  LitElement: s
	});
	const n$1 = globalThis.litElementPolyfillSupport;
	null == n$1 || n$1({
	  LitElement: s
	});
	(null !== (o$2 = globalThis.litElementVersions) && void 0 !== o$2 ? o$2 : globalThis.litElementVersions = []).push("3.3.3");

	var _templateObject$l;
	const styles$a = i$3(_templateObject$l || (_templateObject$l = _taggedTemplateLiteral([".mdc-top-app-bar{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee);color:white;display:flex;position:fixed;flex-direction:column;justify-content:space-between;box-sizing:border-box;width:100%;z-index:4}.mdc-top-app-bar .mdc-top-app-bar__action-item,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon{color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-top-app-bar .mdc-top-app-bar__action-item::before,.mdc-top-app-bar .mdc-top-app-bar__action-item::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon::after{background-color:#fff;background-color:var(--mdc-ripple-color, var(--mdc-theme-on-primary, #fff))}.mdc-top-app-bar .mdc-top-app-bar__action-item:hover::before,.mdc-top-app-bar .mdc-top-app-bar__action-item.mdc-ripple-surface--hover::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:hover::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon.mdc-ripple-surface--hover::before{opacity:0.08;opacity:var(--mdc-ripple-hover-opacity, 0.08)}.mdc-top-app-bar .mdc-top-app-bar__action-item.mdc-ripple-upgraded--background-focused::before,.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded):focus::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon.mdc-ripple-upgraded--background-focused::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded)::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded):active::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-top-app-bar .mdc-top-app-bar__action-item.mdc-ripple-upgraded,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-top-app-bar__row{display:flex;position:relative;box-sizing:border-box;width:100%;height:64px}.mdc-top-app-bar__section{display:inline-flex;flex:1 1 auto;align-items:center;min-width:0;padding:8px 12px;z-index:1}.mdc-top-app-bar__section--align-start{justify-content:flex-start;order:-1}.mdc-top-app-bar__section--align-end{justify-content:flex-end;order:1}.mdc-top-app-bar__title{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-headline6-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1.25rem;font-size:var(--mdc-typography-headline6-font-size, 1.25rem);line-height:2rem;line-height:var(--mdc-typography-headline6-line-height, 2rem);font-weight:500;font-weight:var(--mdc-typography-headline6-font-weight, 500);letter-spacing:0.0125em;letter-spacing:var(--mdc-typography-headline6-letter-spacing, 0.0125em);text-decoration:inherit;text-decoration:var(--mdc-typography-headline6-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-headline6-text-transform, inherit);padding-left:20px;padding-right:0;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;z-index:1}[dir=rtl] .mdc-top-app-bar__title,.mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:20px}.mdc-top-app-bar--short-collapsed{border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:24px;border-bottom-left-radius:0}[dir=rtl] .mdc-top-app-bar--short-collapsed,.mdc-top-app-bar--short-collapsed[dir=rtl]{border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:24px}.mdc-top-app-bar--short{top:0;right:auto;left:0;width:100%;transition:width 250ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-top-app-bar--short,.mdc-top-app-bar--short[dir=rtl]{right:0;left:auto}.mdc-top-app-bar--short .mdc-top-app-bar__row{height:56px}.mdc-top-app-bar--short .mdc-top-app-bar__section{padding:4px}.mdc-top-app-bar--short .mdc-top-app-bar__title{transition:opacity 200ms cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.mdc-top-app-bar--short-collapsed{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12);width:56px;transition:width 300ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__title{display:none}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__action-item{transition:padding 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item{width:112px}.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end{padding-left:0;padding-right:12px}[dir=rtl] .mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end,.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end[dir=rtl]{padding-left:12px;padding-right:0}.mdc-top-app-bar--dense .mdc-top-app-bar__row{height:48px}.mdc-top-app-bar--dense .mdc-top-app-bar__section{padding:0 4px}.mdc-top-app-bar--dense .mdc-top-app-bar__title{padding-left:12px;padding-right:0}[dir=rtl] .mdc-top-app-bar--dense .mdc-top-app-bar__title,.mdc-top-app-bar--dense .mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:12px}.mdc-top-app-bar--prominent .mdc-top-app-bar__row{height:128px}.mdc-top-app-bar--prominent .mdc-top-app-bar__title{align-self:flex-end;padding-bottom:2px}.mdc-top-app-bar--prominent .mdc-top-app-bar__action-item,.mdc-top-app-bar--prominent .mdc-top-app-bar__navigation-icon{align-self:flex-start}.mdc-top-app-bar--fixed{transition:box-shadow 200ms linear}.mdc-top-app-bar--fixed-scrolled{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12);transition:box-shadow 200ms linear}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__row{height:96px}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__section{padding:0 12px}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title{padding-left:20px;padding-right:0;padding-bottom:9px}[dir=rtl] .mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title,.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:20px}.mdc-top-app-bar--fixed-adjust{padding-top:64px}.mdc-top-app-bar--dense-fixed-adjust{padding-top:48px}.mdc-top-app-bar--short-fixed-adjust{padding-top:56px}.mdc-top-app-bar--prominent-fixed-adjust{padding-top:128px}.mdc-top-app-bar--dense-prominent-fixed-adjust{padding-top:96px}@media(max-width: 599px){.mdc-top-app-bar__row{height:56px}.mdc-top-app-bar__section{padding:4px}.mdc-top-app-bar--short{transition:width 200ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed{transition:width 250ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end{padding-left:0;padding-right:12px}[dir=rtl] .mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end,.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end[dir=rtl]{padding-left:12px;padding-right:0}.mdc-top-app-bar--prominent .mdc-top-app-bar__title{padding-bottom:6px}.mdc-top-app-bar--fixed-adjust{padding-top:56px}}:host{display:block}.mdc-top-app-bar{color:#fff;color:var(--mdc-theme-on-primary, #fff);width:100%;width:var(--mdc-top-app-bar-width, 100%)}.mdc-top-app-bar--prominent #navigation ::slotted(*),.mdc-top-app-bar--prominent #actions ::slotted(*){align-self:flex-start}#navigation ::slotted(*),#actions ::slotted(*){--mdc-icon-button-ripple-opacity: 0.24}.mdc-top-app-bar--short-collapsed #actions ::slotted(*){transition:padding 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar__section--align-center{justify-content:center}.mdc-top-app-bar__section--align-center .mdc-top-app-bar__title{padding-left:0;padding-right:0}.center-title .mdc-top-app-bar__section--align-start,.center-title .mdc-top-app-bar__section--align-end{flex-basis:0}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__section--align-center .mdc-top-app-bar__title{padding-left:0;padding-right:0}.mdc-top-app-bar--fixed-scrolled{box-shadow:var(--mdc-top-app-bar-fixed-box-shadow, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}"])));

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var cssClasses$5 = {
	  FIXED_CLASS: 'mdc-top-app-bar--fixed',
	  FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
	  SHORT_CLASS: 'mdc-top-app-bar--short',
	  SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed',
	  SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item'
	};
	var numbers$4 = {
	  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
	  MAX_TOP_APP_BAR_HEIGHT: 128
	};
	var strings$5 = {
	  ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
	  NAVIGATION_EVENT: 'MDCTopAppBar:nav',
	  NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
	  ROOT_SELECTOR: '.mdc-top-app-bar',
	  TITLE_SELECTOR: '.mdc-top-app-bar__title'
	};

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation$5 = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCTopAppBarBaseFoundation = /** @class */function (_super) {
	  __extends(MDCTopAppBarBaseFoundation, _super);
	  /* istanbul ignore next: optional argument is not a branch statement */
	  function MDCTopAppBarBaseFoundation(adapter) {
	    return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation.defaultAdapter), adapter)) || this;
	  }
	  Object.defineProperty(MDCTopAppBarBaseFoundation, "strings", {
	    get: function () {
	      return strings$5;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCTopAppBarBaseFoundation, "cssClasses", {
	    get: function () {
	      return cssClasses$5;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCTopAppBarBaseFoundation, "numbers", {
	    get: function () {
	      return numbers$4;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCTopAppBarBaseFoundation, "defaultAdapter", {
	    /**
	     * See {@link MDCTopAppBarAdapter} for typing information on parameters and return types.
	     */
	    get: function () {
	      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
	      return {
	        addClass: function () {
	          return undefined;
	        },
	        removeClass: function () {
	          return undefined;
	        },
	        hasClass: function () {
	          return false;
	        },
	        setStyle: function () {
	          return undefined;
	        },
	        getTopAppBarHeight: function () {
	          return 0;
	        },
	        notifyNavigationIconClicked: function () {
	          return undefined;
	        },
	        getViewportScrollY: function () {
	          return 0;
	        },
	        getTotalActionItems: function () {
	          return 0;
	        }
	      };
	      // tslint:enable:object-literal-sort-keys
	    },

	    enumerable: false,
	    configurable: true
	  });
	  /** Other variants of TopAppBar foundation overrides this method */
	  MDCTopAppBarBaseFoundation.prototype.handleTargetScroll = function () {}; // tslint:disable-line:no-empty
	  /** Other variants of TopAppBar foundation overrides this method */
	  MDCTopAppBarBaseFoundation.prototype.handleWindowResize = function () {}; // tslint:disable-line:no-empty
	  MDCTopAppBarBaseFoundation.prototype.handleNavigationClick = function () {
	    this.adapter.notifyNavigationIconClicked();
	  };
	  return MDCTopAppBarBaseFoundation;
	}(MDCFoundation$5);

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var INITIAL_VALUE = 0;
	var MDCTopAppBarFoundation = /** @class */function (_super) {
	  __extends(MDCTopAppBarFoundation, _super);
	  /* istanbul ignore next: optional argument is not a branch statement */
	  function MDCTopAppBarFoundation(adapter) {
	    var _this = _super.call(this, adapter) || this;
	    /**
	     * Indicates if the top app bar was docked in the previous scroll handler iteration.
	     */
	    _this.wasDocked = true;
	    /**
	     * Indicates if the top app bar is docked in the fully shown position.
	     */
	    _this.isDockedShowing = true;
	    /**
	     * Variable for current scroll position of the top app bar
	     */
	    _this.currentAppBarOffsetTop = 0;
	    /**
	     * Used to prevent the top app bar from being scrolled out of view during resize events
	     */
	    _this.isCurrentlyBeingResized = false;
	    /**
	     * The timeout that's used to throttle the resize events
	     */
	    _this.resizeThrottleId = INITIAL_VALUE;
	    /**
	     * The timeout that's used to debounce toggling the isCurrentlyBeingResized
	     * variable after a resize
	     */
	    _this.resizeDebounceId = INITIAL_VALUE;
	    _this.lastScrollPosition = _this.adapter.getViewportScrollY();
	    _this.topAppBarHeight = _this.adapter.getTopAppBarHeight();
	    return _this;
	  }
	  MDCTopAppBarFoundation.prototype.destroy = function () {
	    _super.prototype.destroy.call(this);
	    this.adapter.setStyle('top', '');
	  };
	  /**
	   * Scroll handler for the default scroll behavior of the top app bar.
	   */
	  MDCTopAppBarFoundation.prototype.handleTargetScroll = function () {
	    var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
	    var diff = currentScrollPosition - this.lastScrollPosition;
	    this.lastScrollPosition = currentScrollPosition;
	    // If the window is being resized the lastScrollPosition needs to be updated
	    // but the current scroll of the top app bar should stay in the same
	    // position.
	    if (!this.isCurrentlyBeingResized) {
	      this.currentAppBarOffsetTop -= diff;
	      if (this.currentAppBarOffsetTop > 0) {
	        this.currentAppBarOffsetTop = 0;
	      } else if (Math.abs(this.currentAppBarOffsetTop) > this.topAppBarHeight) {
	        this.currentAppBarOffsetTop = -this.topAppBarHeight;
	      }
	      this.moveTopAppBar();
	    }
	  };
	  /**
	   * Top app bar resize handler that throttle/debounce functions that execute updates.
	   */
	  MDCTopAppBarFoundation.prototype.handleWindowResize = function () {
	    var _this = this;
	    // Throttle resize events 10 p/s
	    if (!this.resizeThrottleId) {
	      this.resizeThrottleId = setTimeout(function () {
	        _this.resizeThrottleId = INITIAL_VALUE;
	        _this.throttledResizeHandler();
	      }, numbers$4.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
	    }
	    this.isCurrentlyBeingResized = true;
	    if (this.resizeDebounceId) {
	      clearTimeout(this.resizeDebounceId);
	    }
	    this.resizeDebounceId = setTimeout(function () {
	      _this.handleTargetScroll();
	      _this.isCurrentlyBeingResized = false;
	      _this.resizeDebounceId = INITIAL_VALUE;
	    }, numbers$4.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
	  };
	  /**
	   * Function to determine if the DOM needs to update.
	   */
	  MDCTopAppBarFoundation.prototype.checkForUpdate = function () {
	    var offscreenBoundaryTop = -this.topAppBarHeight;
	    var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop < 0;
	    var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop > offscreenBoundaryTop;
	    var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
	    // If it's partially showing, it can't be docked.
	    if (partiallyShowing) {
	      this.wasDocked = false;
	    } else {
	      // Not previously docked and not partially showing, it's now docked.
	      if (!this.wasDocked) {
	        this.wasDocked = true;
	        return true;
	      } else if (this.isDockedShowing !== hasAnyPixelsOnscreen) {
	        this.isDockedShowing = hasAnyPixelsOnscreen;
	        return true;
	      }
	    }
	    return partiallyShowing;
	  };
	  /**
	   * Function to move the top app bar if needed.
	   */
	  MDCTopAppBarFoundation.prototype.moveTopAppBar = function () {
	    if (this.checkForUpdate()) {
	      // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
	      // so the top app bar doesn't show if the window resizes and the new height > the old height.
	      var offset = this.currentAppBarOffsetTop;
	      if (Math.abs(offset) >= this.topAppBarHeight) {
	        offset = -numbers$4.MAX_TOP_APP_BAR_HEIGHT;
	      }
	      this.adapter.setStyle('top', offset + 'px');
	    }
	  };
	  /**
	   * Throttled function that updates the top app bar scrolled values if the
	   * top app bar height changes.
	   */
	  MDCTopAppBarFoundation.prototype.throttledResizeHandler = function () {
	    var currentHeight = this.adapter.getTopAppBarHeight();
	    if (this.topAppBarHeight !== currentHeight) {
	      this.wasDocked = false;
	      // Since the top app bar has a different height depending on the screen width, this
	      // will ensure that the top app bar remains in the correct location if
	      // completely hidden and a resize makes the top app bar a different height.
	      this.currentAppBarOffsetTop -= this.topAppBarHeight - currentHeight;
	      this.topAppBarHeight = currentHeight;
	    }
	    this.handleTargetScroll();
	  };
	  return MDCTopAppBarFoundation;
	}(MDCTopAppBarBaseFoundation);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCTopAppBarFoundation$1 = MDCTopAppBarFoundation;

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	// Style preference for leading underscores.
	// tslint:disable:strip-private-property-underscore
	/**
	 * Determines whether a node is an element.
	 *
	 * @param node Node to check
	 */
	const isNodeElement = node => {
	  return node.nodeType === Node.ELEMENT_NODE;
	};
	function addHasRemoveClass(element) {
	  return {
	    addClass: className => {
	      element.classList.add(className);
	    },
	    removeClass: className => {
	      element.classList.remove(className);
	    },
	    hasClass: className => element.classList.contains(className)
	  };
	}
	let supportsPassive = false;
	const fn = () => {};
	const optionsBlock = {
	  get passive() {
	    supportsPassive = true;
	    return false;
	  }
	};
	document.addEventListener('x', fn, optionsBlock);
	document.removeEventListener('x', fn);
	/**
	 * Do event listeners suport the `passive` option?
	 */
	const supportsPassiveEventListener = supportsPassive;
	const deepActiveElementPath = function () {
	  let doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.document;
	  let activeElement = doc.activeElement;
	  const path = [];
	  if (!activeElement) {
	    return path;
	  }
	  while (activeElement) {
	    path.push(activeElement);
	    if (activeElement.shadowRoot) {
	      activeElement = activeElement.shadowRoot.activeElement;
	    } else {
	      break;
	    }
	  }
	  return path;
	};
	const doesElementContainFocus = element => {
	  const activePath = deepActiveElementPath();
	  if (!activePath.length) {
	    return false;
	  }
	  const deepActiveElement = activePath[activePath.length - 1];
	  const focusEv = new Event('check-if-focused', {
	    bubbles: true,
	    composed: true
	  });
	  let composedPath = [];
	  const listener = ev => {
	    composedPath = ev.composedPath();
	  };
	  document.body.addEventListener('check-if-focused', listener);
	  deepActiveElement.dispatchEvent(focusEv);
	  document.body.removeEventListener('check-if-focused', listener);
	  return composedPath.indexOf(element) !== -1;
	};

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/** @soyCompatible */
	class BaseElement extends s {
	  click() {
	    if (this.mdcRoot) {
	      this.mdcRoot.focus();
	      this.mdcRoot.click();
	      return;
	    }
	    super.click();
	  }
	  /**
	   * Create and attach the MDC Foundation to the instance
	   */
	  createFoundation() {
	    if (this.mdcFoundation !== undefined) {
	      this.mdcFoundation.destroy();
	    }
	    if (this.mdcFoundationClass) {
	      this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter());
	      this.mdcFoundation.init();
	    }
	  }
	  firstUpdated() {
	    this.createFoundation();
	  }
	}

	/**
	 * @license
	 * Copyright 2017 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const t = {
	    ATTRIBUTE: 1,
	    CHILD: 2,
	    PROPERTY: 3,
	    BOOLEAN_ATTRIBUTE: 4,
	    EVENT: 5,
	    ELEMENT: 6
	  },
	  e = t => function () {
	    for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
	      e[_key] = arguments[_key];
	    }
	    return {
	      _$litDirective$: t,
	      values: e
	    };
	  };
	let i$1 = class i {
	  constructor(t) {}
	  get _$AU() {
	    return this._$AM._$AU;
	  }
	  _$AT(t, e, i) {
	    this._$Ct = t, this._$AM = e, this._$Ci = i;
	  }
	  _$AS(t, e) {
	    return this.update(t, e);
	  }
	  update(t, e) {
	    return this.render(...e);
	  }
	};

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const o$1 = e(class extends i$1 {
	  constructor(t$1) {
	    var i;
	    if (super(t$1), t$1.type !== t.ATTRIBUTE || "class" !== t$1.name || (null === (i = t$1.strings) || void 0 === i ? void 0 : i.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
	  }
	  render(t) {
	    return " " + Object.keys(t).filter(i => t[i]).join(" ") + " ";
	  }
	  update(i, _ref) {
	    let [s] = _ref;
	    var r, o;
	    if (void 0 === this.it) {
	      this.it = new Set(), void 0 !== i.strings && (this.nt = new Set(i.strings.join(" ").split(/\s/).filter(t => "" !== t)));
	      for (const t in s) s[t] && !(null === (r = this.nt) || void 0 === r ? void 0 : r.has(t)) && this.it.add(t);
	      return this.render(s);
	    }
	    const e = i.element.classList;
	    this.it.forEach(t => {
	      t in s || (e.remove(t), this.it.delete(t));
	    });
	    for (const t in s) {
	      const i = !!s[t];
	      i === this.it.has(t) || (null === (o = this.nt) || void 0 === o ? void 0 : o.has(t)) || (i ? (e.add(t), this.it.add(t)) : (e.remove(t), this.it.delete(t)));
	    }
	    return T;
	  }
	});

	var _templateObject$k, _templateObject2$8, _templateObject3$5;
	const passiveEventOptionsIfSupported = supportsPassiveEventListener ? {
	  passive: true
	} : undefined;
	class TopAppBarBaseBase extends BaseElement {
	  constructor() {
	    super(...arguments);
	    this.centerTitle = false;
	    this.handleTargetScroll = () => {
	      this.mdcFoundation.handleTargetScroll();
	    };
	    this.handleNavigationClick = () => {
	      this.mdcFoundation.handleNavigationClick();
	    };
	  }
	  get scrollTarget() {
	    return this._scrollTarget || window;
	  }
	  set scrollTarget(value) {
	    this.unregisterScrollListener();
	    const old = this.scrollTarget;
	    this._scrollTarget = value;
	    this.updateRootPosition();
	    this.requestUpdate('scrollTarget', old);
	    this.registerScrollListener();
	  }
	  updateRootPosition() {
	    if (this.mdcRoot) {
	      const windowScroller = this.scrollTarget === window;
	      // we add support for top-app-bar's tied to an element scroller.
	      this.mdcRoot.style.position = windowScroller ? '' : 'absolute';
	    }
	  }
	  render() {
	    // clang-format off
	    let title = x(_templateObject$k || (_templateObject$k = _taggedTemplateLiteral(["<span class=\"mdc-top-app-bar__title\"><slot name=\"title\"></slot></span>"])));
	    if (this.centerTitle) {
	      title = x(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteral(["<section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-center\">", "</section>"])), title);
	    }
	    // clang-format on
	    return x(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteral(["\n      <header class=\"mdc-top-app-bar ", "\">\n      <div class=\"mdc-top-app-bar__row\">\n        <section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-start\" id=\"navigation\">\n          <slot name=\"navigationIcon\"\n            @click=", "></slot>\n          ", "\n        </section>\n        ", "\n        <section class=\"mdc-top-app-bar__section mdc-top-app-bar__section--align-end\" id=\"actions\" role=\"toolbar\">\n          <slot name=\"actionItems\"></slot>\n        </section>\n      </div>\n    </header>\n    <div class=\"", "\">\n      <slot></slot>\n    </div>\n    "])), o$1(this.barClasses()), this.handleNavigationClick, this.centerTitle ? null : title, this.centerTitle ? title : null, o$1(this.contentClasses()));
	  }
	  createAdapter() {
	    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {
	      setStyle: (property, value) => this.mdcRoot.style.setProperty(property, value),
	      getTopAppBarHeight: () => this.mdcRoot.clientHeight,
	      notifyNavigationIconClicked: () => {
	        this.dispatchEvent(new Event(strings$5.NAVIGATION_EVENT, {
	          bubbles: true,
	          cancelable: true
	        }));
	      },
	      getViewportScrollY: () => this.scrollTarget instanceof Window ? this.scrollTarget.pageYOffset : this.scrollTarget.scrollTop,
	      getTotalActionItems: () => this._actionItemsSlot.assignedNodes({
	        flatten: true
	      }).length
	    });
	  }
	  registerListeners() {
	    this.registerScrollListener();
	  }
	  unregisterListeners() {
	    this.unregisterScrollListener();
	  }
	  registerScrollListener() {
	    this.scrollTarget.addEventListener('scroll', this.handleTargetScroll, passiveEventOptionsIfSupported);
	  }
	  unregisterScrollListener() {
	    this.scrollTarget.removeEventListener('scroll', this.handleTargetScroll);
	  }
	  firstUpdated() {
	    super.firstUpdated();
	    this.updateRootPosition();
	    this.registerListeners();
	  }
	  disconnectedCallback() {
	    super.disconnectedCallback();
	    this.unregisterListeners();
	  }
	}
	__decorate([i$4('.mdc-top-app-bar')], TopAppBarBaseBase.prototype, "mdcRoot", void 0);
	__decorate([i$4('slot[name="actionItems"]')], TopAppBarBaseBase.prototype, "_actionItemsSlot", void 0);
	__decorate([n$6({
	  type: Boolean
	})], TopAppBarBaseBase.prototype, "centerTitle", void 0);
	__decorate([n$6({
	  type: Object
	})], TopAppBarBaseBase.prototype, "scrollTarget", null);

	class TopAppBarBase extends TopAppBarBaseBase {
	  constructor() {
	    super(...arguments);
	    this.mdcFoundationClass = MDCTopAppBarFoundation$1;
	    this.prominent = false;
	    this.dense = false;
	    this.handleResize = () => {
	      this.mdcFoundation.handleWindowResize();
	    };
	  }
	  barClasses() {
	    return {
	      'mdc-top-app-bar--dense': this.dense,
	      'mdc-top-app-bar--prominent': this.prominent,
	      'center-title': this.centerTitle
	    };
	  }
	  contentClasses() {
	    return {
	      'mdc-top-app-bar--fixed-adjust': !this.dense && !this.prominent,
	      'mdc-top-app-bar--dense-fixed-adjust': this.dense && !this.prominent,
	      'mdc-top-app-bar--prominent-fixed-adjust': !this.dense && this.prominent,
	      'mdc-top-app-bar--dense-prominent-fixed-adjust': this.dense && this.prominent
	    };
	  }
	  registerListeners() {
	    super.registerListeners();
	    window.addEventListener('resize', this.handleResize, passiveEventOptionsIfSupported);
	  }
	  unregisterListeners() {
	    super.unregisterListeners();
	    window.removeEventListener('resize', this.handleResize);
	  }
	}
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], TopAppBarBase.prototype, "prominent", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], TopAppBarBase.prototype, "dense", void 0);

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFixedTopAppBarFoundation = /** @class */function (_super) {
	  __extends(MDCFixedTopAppBarFoundation, _super);
	  function MDCFixedTopAppBarFoundation() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	    /**
	     * State variable for the previous scroll iteration top app bar state
	     */
	    _this.wasScrolled = false;
	    return _this;
	  }
	  /**
	   * Scroll handler for applying/removing the modifier class on the fixed top app bar.
	   */
	  MDCFixedTopAppBarFoundation.prototype.handleTargetScroll = function () {
	    var currentScroll = this.adapter.getViewportScrollY();
	    if (currentScroll <= 0) {
	      if (this.wasScrolled) {
	        this.adapter.removeClass(cssClasses$5.FIXED_SCROLLED_CLASS);
	        this.wasScrolled = false;
	      }
	    } else {
	      if (!this.wasScrolled) {
	        this.adapter.addClass(cssClasses$5.FIXED_SCROLLED_CLASS);
	        this.wasScrolled = true;
	      }
	    }
	  };
	  return MDCFixedTopAppBarFoundation;
	}(MDCTopAppBarFoundation);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCFixedTopAppBarFoundation$1 = MDCFixedTopAppBarFoundation;

	class TopAppBarFixedBase extends TopAppBarBase {
	  constructor() {
	    super(...arguments);
	    this.mdcFoundationClass = MDCFixedTopAppBarFoundation$1;
	  }
	  barClasses() {
	    return Object.assign(Object.assign({}, super.barClasses()), {
	      'mdc-top-app-bar--fixed': true
	    });
	  }
	  registerListeners() {
	    this.scrollTarget.addEventListener('scroll', this.handleTargetScroll, passiveEventOptionsIfSupported);
	  }
	  unregisterListeners() {
	    this.scrollTarget.removeEventListener('scroll', this.handleTargetScroll);
	  }
	}

	/**
	 * @license
	 * Copyright 2019 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let TopAppBarFixed = class TopAppBarFixed extends TopAppBarFixedBase {};
	TopAppBarFixed.styles = [styles$a];
	TopAppBarFixed = __decorate([e$8('mwc-top-app-bar-fixed')], TopAppBarFixed);

	var _templateObject$j;
	const styles$9 = i$3(_templateObject$j || (_templateObject$j = _taggedTemplateLiteral([":host{font-family:var(--mdc-icon-font, \"Material Icons\");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:\"liga\"}"])));

	var _templateObject$i;
	/** @soyCompatible */
	let Icon = class Icon extends s {
	  /** @soyTemplate */
	  render() {
	    return x(_templateObject$i || (_templateObject$i = _taggedTemplateLiteral(["<span><slot></slot></span>"])));
	  }
	};
	Icon.styles = [styles$9];
	Icon = __decorate([e$8('mwc-icon')], Icon);

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	/**
	 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
	 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
	 */
	function matches(element, selector) {
	  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
	  return nativeMatches.call(element, selector);
	}

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation$4 = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var cssClasses$4 = {
	  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
	  // given that it's an 'upgrade' to an existing component. That being said it is the root
	  // CSS class that all other CSS classes derive from.
	  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
	  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
	  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
	  ROOT: 'mdc-ripple-upgraded',
	  UNBOUNDED: 'mdc-ripple-upgraded--unbounded'
	};
	var strings$4 = {
	  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
	  VAR_FG_SIZE: '--mdc-ripple-fg-size',
	  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
	  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
	  VAR_LEFT: '--mdc-ripple-left',
	  VAR_TOP: '--mdc-ripple-top'
	};
	var numbers$3 = {
	  DEACTIVATION_TIMEOUT_MS: 225,
	  FG_DEACTIVATION_MS: 150,
	  INITIAL_ORIGIN_SCALE: 0.6,
	  PADDING: 10,
	  TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
	};

	/**
	 * Stores result from supportsCssVariables to avoid redundant processing to
	 * detect CSS custom variable support.
	 */
	function getNormalizedEventCoords(evt, pageOffset, clientRect) {
	  if (!evt) {
	    return {
	      x: 0,
	      y: 0
	    };
	  }
	  var x = pageOffset.x,
	    y = pageOffset.y;
	  var documentX = x + clientRect.left;
	  var documentY = y + clientRect.top;
	  var normalizedX;
	  var normalizedY;
	  // Determine touch point relative to the ripple container.
	  if (evt.type === 'touchstart') {
	    var touchEvent = evt;
	    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
	    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
	  } else {
	    var mouseEvent = evt;
	    normalizedX = mouseEvent.pageX - documentX;
	    normalizedY = mouseEvent.pageY - documentY;
	  }
	  return {
	    x: normalizedX,
	    y: normalizedY
	  };
	}

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	// Activation events registered on the root element of each instance for activation
	var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];
	// Deactivation events registered on documentElement when a pointer-related down event occurs
	var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu'];
	// simultaneous nested activations
	var activatedTargets = [];
	var MDCRippleFoundation = /** @class */function (_super) {
	  __extends(MDCRippleFoundation, _super);
	  function MDCRippleFoundation(adapter) {
	    var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;
	    _this.activationAnimationHasEnded = false;
	    _this.activationTimer = 0;
	    _this.fgDeactivationRemovalTimer = 0;
	    _this.fgScale = '0';
	    _this.frame = {
	      width: 0,
	      height: 0
	    };
	    _this.initialSize = 0;
	    _this.layoutFrame = 0;
	    _this.maxRadius = 0;
	    _this.unboundedCoords = {
	      left: 0,
	      top: 0
	    };
	    _this.activationState = _this.defaultActivationState();
	    _this.activationTimerCallback = function () {
	      _this.activationAnimationHasEnded = true;
	      _this.runDeactivationUXLogicIfReady();
	    };
	    _this.activateHandler = function (e) {
	      _this.activateImpl(e);
	    };
	    _this.deactivateHandler = function () {
	      _this.deactivateImpl();
	    };
	    _this.focusHandler = function () {
	      _this.handleFocus();
	    };
	    _this.blurHandler = function () {
	      _this.handleBlur();
	    };
	    _this.resizeHandler = function () {
	      _this.layout();
	    };
	    return _this;
	  }
	  Object.defineProperty(MDCRippleFoundation, "cssClasses", {
	    get: function () {
	      return cssClasses$4;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCRippleFoundation, "strings", {
	    get: function () {
	      return strings$4;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCRippleFoundation, "numbers", {
	    get: function () {
	      return numbers$3;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
	    get: function () {
	      return {
	        addClass: function () {
	          return undefined;
	        },
	        browserSupportsCssVars: function () {
	          return true;
	        },
	        computeBoundingRect: function () {
	          return {
	            top: 0,
	            right: 0,
	            bottom: 0,
	            left: 0,
	            width: 0,
	            height: 0
	          };
	        },
	        containsEventTarget: function () {
	          return true;
	        },
	        deregisterDocumentInteractionHandler: function () {
	          return undefined;
	        },
	        deregisterInteractionHandler: function () {
	          return undefined;
	        },
	        deregisterResizeHandler: function () {
	          return undefined;
	        },
	        getWindowPageOffset: function () {
	          return {
	            x: 0,
	            y: 0
	          };
	        },
	        isSurfaceActive: function () {
	          return true;
	        },
	        isSurfaceDisabled: function () {
	          return true;
	        },
	        isUnbounded: function () {
	          return true;
	        },
	        registerDocumentInteractionHandler: function () {
	          return undefined;
	        },
	        registerInteractionHandler: function () {
	          return undefined;
	        },
	        registerResizeHandler: function () {
	          return undefined;
	        },
	        removeClass: function () {
	          return undefined;
	        },
	        updateCssVariable: function () {
	          return undefined;
	        }
	      };
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCRippleFoundation.prototype.init = function () {
	    var _this = this;
	    var supportsPressRipple = this.supportsPressRipple();
	    this.registerRootHandlers(supportsPressRipple);
	    if (supportsPressRipple) {
	      var _a = MDCRippleFoundation.cssClasses,
	        ROOT_1 = _a.ROOT,
	        UNBOUNDED_1 = _a.UNBOUNDED;
	      requestAnimationFrame(function () {
	        _this.adapter.addClass(ROOT_1);
	        if (_this.adapter.isUnbounded()) {
	          _this.adapter.addClass(UNBOUNDED_1);
	          // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
	          _this.layoutInternal();
	        }
	      });
	    }
	  };
	  MDCRippleFoundation.prototype.destroy = function () {
	    var _this = this;
	    if (this.supportsPressRipple()) {
	      if (this.activationTimer) {
	        clearTimeout(this.activationTimer);
	        this.activationTimer = 0;
	        this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
	      }
	      if (this.fgDeactivationRemovalTimer) {
	        clearTimeout(this.fgDeactivationRemovalTimer);
	        this.fgDeactivationRemovalTimer = 0;
	        this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
	      }
	      var _a = MDCRippleFoundation.cssClasses,
	        ROOT_2 = _a.ROOT,
	        UNBOUNDED_2 = _a.UNBOUNDED;
	      requestAnimationFrame(function () {
	        _this.adapter.removeClass(ROOT_2);
	        _this.adapter.removeClass(UNBOUNDED_2);
	        _this.removeCssVars();
	      });
	    }
	    this.deregisterRootHandlers();
	    this.deregisterDeactivationHandlers();
	  };
	  /**
	   * @param evt Optional event containing position information.
	   */
	  MDCRippleFoundation.prototype.activate = function (evt) {
	    this.activateImpl(evt);
	  };
	  MDCRippleFoundation.prototype.deactivate = function () {
	    this.deactivateImpl();
	  };
	  MDCRippleFoundation.prototype.layout = function () {
	    var _this = this;
	    if (this.layoutFrame) {
	      cancelAnimationFrame(this.layoutFrame);
	    }
	    this.layoutFrame = requestAnimationFrame(function () {
	      _this.layoutInternal();
	      _this.layoutFrame = 0;
	    });
	  };
	  MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
	    var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
	    if (unbounded) {
	      this.adapter.addClass(UNBOUNDED);
	    } else {
	      this.adapter.removeClass(UNBOUNDED);
	    }
	  };
	  MDCRippleFoundation.prototype.handleFocus = function () {
	    var _this = this;
	    requestAnimationFrame(function () {
	      return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
	    });
	  };
	  MDCRippleFoundation.prototype.handleBlur = function () {
	    var _this = this;
	    requestAnimationFrame(function () {
	      return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
	    });
	  };
	  /**
	   * We compute this property so that we are not querying information about the client
	   * until the point in time where the foundation requests it. This prevents scenarios where
	   * client-side feature-detection may happen too early, such as when components are rendered on the server
	   * and then initialized at mount time on the client.
	   */
	  MDCRippleFoundation.prototype.supportsPressRipple = function () {
	    return this.adapter.browserSupportsCssVars();
	  };
	  MDCRippleFoundation.prototype.defaultActivationState = function () {
	    return {
	      activationEvent: undefined,
	      hasDeactivationUXRun: false,
	      isActivated: false,
	      isProgrammatic: false,
	      wasActivatedByPointer: false,
	      wasElementMadeActive: false
	    };
	  };
	  /**
	   * supportsPressRipple Passed from init to save a redundant function call
	   */
	  MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {
	    var e_1, _a;
	    if (supportsPressRipple) {
	      try {
	        for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
	          var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
	          this.adapter.registerInteractionHandler(evtType, this.activateHandler);
	        }
	      } catch (e_1_1) {
	        e_1 = {
	          error: e_1_1
	        };
	      } finally {
	        try {
	          if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);
	        } finally {
	          if (e_1) throw e_1.error;
	        }
	      }
	      if (this.adapter.isUnbounded()) {
	        this.adapter.registerResizeHandler(this.resizeHandler);
	      }
	    }
	    this.adapter.registerInteractionHandler('focus', this.focusHandler);
	    this.adapter.registerInteractionHandler('blur', this.blurHandler);
	  };
	  MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {
	    var e_2, _a;
	    if (evt.type === 'keydown') {
	      this.adapter.registerInteractionHandler('keyup', this.deactivateHandler);
	    } else {
	      try {
	        for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
	          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
	          this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
	        }
	      } catch (e_2_1) {
	        e_2 = {
	          error: e_2_1
	        };
	      } finally {
	        try {
	          if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
	        } finally {
	          if (e_2) throw e_2.error;
	        }
	      }
	    }
	  };
	  MDCRippleFoundation.prototype.deregisterRootHandlers = function () {
	    var e_3, _a;
	    try {
	      for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
	        var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
	        this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
	      }
	    } catch (e_3_1) {
	      e_3 = {
	        error: e_3_1
	      };
	    } finally {
	      try {
	        if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);
	      } finally {
	        if (e_3) throw e_3.error;
	      }
	    }
	    this.adapter.deregisterInteractionHandler('focus', this.focusHandler);
	    this.adapter.deregisterInteractionHandler('blur', this.blurHandler);
	    if (this.adapter.isUnbounded()) {
	      this.adapter.deregisterResizeHandler(this.resizeHandler);
	    }
	  };
	  MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {
	    var e_4, _a;
	    this.adapter.deregisterInteractionHandler('keyup', this.deactivateHandler);
	    try {
	      for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
	        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
	        this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
	      }
	    } catch (e_4_1) {
	      e_4 = {
	        error: e_4_1
	      };
	    } finally {
	      try {
	        if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
	      } finally {
	        if (e_4) throw e_4.error;
	      }
	    }
	  };
	  MDCRippleFoundation.prototype.removeCssVars = function () {
	    var _this = this;
	    var rippleStrings = MDCRippleFoundation.strings;
	    var keys = Object.keys(rippleStrings);
	    keys.forEach(function (key) {
	      if (key.indexOf('VAR_') === 0) {
	        _this.adapter.updateCssVariable(rippleStrings[key], null);
	      }
	    });
	  };
	  MDCRippleFoundation.prototype.activateImpl = function (evt) {
	    var _this = this;
	    if (this.adapter.isSurfaceDisabled()) {
	      return;
	    }
	    var activationState = this.activationState;
	    if (activationState.isActivated) {
	      return;
	    }
	    // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
	    var previousActivationEvent = this.previousActivationEvent;
	    var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
	    if (isSameInteraction) {
	      return;
	    }
	    activationState.isActivated = true;
	    activationState.isProgrammatic = evt === undefined;
	    activationState.activationEvent = evt;
	    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
	    var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
	      return _this.adapter.containsEventTarget(target);
	    });
	    if (hasActivatedChild) {
	      // Immediately reset activation state, while preserving logic that prevents touch follow-on events
	      this.resetActivationState();
	      return;
	    }
	    if (evt !== undefined) {
	      activatedTargets.push(evt.target);
	      this.registerDeactivationHandlers(evt);
	    }
	    activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
	    if (activationState.wasElementMadeActive) {
	      this.animateActivation();
	    }
	    requestAnimationFrame(function () {
	      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
	      activatedTargets = [];
	      if (!activationState.wasElementMadeActive && evt !== undefined && (evt.key === ' ' || evt.keyCode === 32)) {
	        // If space was pressed, try again within an rAF call to detect :active, because different UAs report
	        // active states inconsistently when they're called within event handling code:
	        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
	        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
	        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
	        // variable is set within a rAF callback for a submit button interaction (#2241).
	        activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
	        if (activationState.wasElementMadeActive) {
	          _this.animateActivation();
	        }
	      }
	      if (!activationState.wasElementMadeActive) {
	        // Reset activation state immediately if element was not made active.
	        _this.activationState = _this.defaultActivationState();
	      }
	    });
	  };
	  MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {
	    return evt !== undefined && evt.type === 'keydown' ? this.adapter.isSurfaceActive() : true;
	  };
	  MDCRippleFoundation.prototype.animateActivation = function () {
	    var _this = this;
	    var _a = MDCRippleFoundation.strings,
	      VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START,
	      VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
	    var _b = MDCRippleFoundation.cssClasses,
	      FG_DEACTIVATION = _b.FG_DEACTIVATION,
	      FG_ACTIVATION = _b.FG_ACTIVATION;
	    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
	    this.layoutInternal();
	    var translateStart = '';
	    var translateEnd = '';
	    if (!this.adapter.isUnbounded()) {
	      var _c = this.getFgTranslationCoordinates(),
	        startPoint = _c.startPoint,
	        endPoint = _c.endPoint;
	      translateStart = startPoint.x + "px, " + startPoint.y + "px";
	      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
	    }
	    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
	    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
	    // Cancel any ongoing activation/deactivation animations
	    clearTimeout(this.activationTimer);
	    clearTimeout(this.fgDeactivationRemovalTimer);
	    this.rmBoundedActivationClasses();
	    this.adapter.removeClass(FG_DEACTIVATION);
	    // Force layout in order to re-trigger the animation.
	    this.adapter.computeBoundingRect();
	    this.adapter.addClass(FG_ACTIVATION);
	    this.activationTimer = setTimeout(function () {
	      _this.activationTimerCallback();
	    }, DEACTIVATION_TIMEOUT_MS);
	  };
	  MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {
	    var _a = this.activationState,
	      activationEvent = _a.activationEvent,
	      wasActivatedByPointer = _a.wasActivatedByPointer;
	    var startPoint;
	    if (wasActivatedByPointer) {
	      startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
	    } else {
	      startPoint = {
	        x: this.frame.width / 2,
	        y: this.frame.height / 2
	      };
	    }
	    // Center the element around the start point.
	    startPoint = {
	      x: startPoint.x - this.initialSize / 2,
	      y: startPoint.y - this.initialSize / 2
	    };
	    var endPoint = {
	      x: this.frame.width / 2 - this.initialSize / 2,
	      y: this.frame.height / 2 - this.initialSize / 2
	    };
	    return {
	      startPoint: startPoint,
	      endPoint: endPoint
	    };
	  };
	  MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {
	    var _this = this;
	    // This method is called both when a pointing device is released, and when the activation animation ends.
	    // The deactivation animation should only run after both of those occur.
	    var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
	    var _a = this.activationState,
	      hasDeactivationUXRun = _a.hasDeactivationUXRun,
	      isActivated = _a.isActivated;
	    var activationHasEnded = hasDeactivationUXRun || !isActivated;
	    if (activationHasEnded && this.activationAnimationHasEnded) {
	      this.rmBoundedActivationClasses();
	      this.adapter.addClass(FG_DEACTIVATION);
	      this.fgDeactivationRemovalTimer = setTimeout(function () {
	        _this.adapter.removeClass(FG_DEACTIVATION);
	      }, numbers$3.FG_DEACTIVATION_MS);
	    }
	  };
	  MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {
	    var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
	    this.adapter.removeClass(FG_ACTIVATION);
	    this.activationAnimationHasEnded = false;
	    this.adapter.computeBoundingRect();
	  };
	  MDCRippleFoundation.prototype.resetActivationState = function () {
	    var _this = this;
	    this.previousActivationEvent = this.activationState.activationEvent;
	    this.activationState = this.defaultActivationState();
	    // Touch devices may fire additional events for the same interaction within a short time.
	    // Store the previous event until it's safe to assume that subsequent events are for new interactions.
	    setTimeout(function () {
	      return _this.previousActivationEvent = undefined;
	    }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
	  };
	  MDCRippleFoundation.prototype.deactivateImpl = function () {
	    var _this = this;
	    var activationState = this.activationState;
	    // This can happen in scenarios such as when you have a keyup event that blurs the element.
	    if (!activationState.isActivated) {
	      return;
	    }
	    var state = __assign({}, activationState);
	    if (activationState.isProgrammatic) {
	      requestAnimationFrame(function () {
	        _this.animateDeactivation(state);
	      });
	      this.resetActivationState();
	    } else {
	      this.deregisterDeactivationHandlers();
	      requestAnimationFrame(function () {
	        _this.activationState.hasDeactivationUXRun = true;
	        _this.animateDeactivation(state);
	        _this.resetActivationState();
	      });
	    }
	  };
	  MDCRippleFoundation.prototype.animateDeactivation = function (_a) {
	    var wasActivatedByPointer = _a.wasActivatedByPointer,
	      wasElementMadeActive = _a.wasElementMadeActive;
	    if (wasActivatedByPointer || wasElementMadeActive) {
	      this.runDeactivationUXLogicIfReady();
	    }
	  };
	  MDCRippleFoundation.prototype.layoutInternal = function () {
	    var _this = this;
	    this.frame = this.adapter.computeBoundingRect();
	    var maxDim = Math.max(this.frame.height, this.frame.width);
	    // Surface diameter is treated differently for unbounded vs. bounded ripples.
	    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
	    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
	    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
	    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
	    // `overflow: hidden`.
	    var getBoundedRadius = function () {
	      var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
	      return hypotenuse + MDCRippleFoundation.numbers.PADDING;
	    };
	    this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
	    // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
	    var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
	    // Unbounded ripple size should always be even number to equally center align.
	    if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
	      this.initialSize = initialSize - 1;
	    } else {
	      this.initialSize = initialSize;
	    }
	    this.fgScale = "" + this.maxRadius / this.initialSize;
	    this.updateLayoutCssVars();
	  };
	  MDCRippleFoundation.prototype.updateLayoutCssVars = function () {
	    var _a = MDCRippleFoundation.strings,
	      VAR_FG_SIZE = _a.VAR_FG_SIZE,
	      VAR_LEFT = _a.VAR_LEFT,
	      VAR_TOP = _a.VAR_TOP,
	      VAR_FG_SCALE = _a.VAR_FG_SCALE;
	    this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
	    this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
	    if (this.adapter.isUnbounded()) {
	      this.unboundedCoords = {
	        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
	        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
	      };
	      this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
	      this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
	    }
	  };
	  return MDCRippleFoundation;
	}(MDCFoundation$4);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCRippleFoundation$1 = MDCRippleFoundation;

	var NATIVE_BIND = functionBindNative;

	var FunctionPrototype = Function.prototype;
	var apply$1 = FunctionPrototype.apply;
	var call$3 = FunctionPrototype.call;

	// eslint-disable-next-line es/no-reflect -- safe
	var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$3.bind(apply$1) : function () {
	  return call$3.apply(apply$1, arguments);
	});

	var classof$1 = classof$9;

	var $String = String;

	var toString$3 = function (argument) {
	  if (classof$1(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
	  return $String(argument);
	};

	var anObject$2 = anObject$9;

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags$1 = function () {
	  var that = anObject$2(this);
	  var result = '';
	  if (that.hasIndices) result += 'd';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.unicodeSets) result += 'v';
	  if (that.sticky) result += 'y';
	  return result;
	};

	var fails$4 = fails$l;
	var global$3 = global$l;

	// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	var $RegExp$2 = global$3.RegExp;

	var UNSUPPORTED_Y$1 = fails$4(function () {
	  var re = $RegExp$2('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') !== null;
	});

	// UC Browser bug
	// https://github.com/zloirock/core-js/issues/1008
	var MISSED_STICKY = UNSUPPORTED_Y$1 || fails$4(function () {
	  return !$RegExp$2('a', 'y').sticky;
	});

	var BROKEN_CARET = UNSUPPORTED_Y$1 || fails$4(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = $RegExp$2('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') !== null;
	});

	var regexpStickyHelpers = {
	  BROKEN_CARET: BROKEN_CARET,
	  MISSED_STICKY: MISSED_STICKY,
	  UNSUPPORTED_Y: UNSUPPORTED_Y$1
	};

	var fails$3 = fails$l;
	var global$2 = global$l;

	// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
	var $RegExp$1 = global$2.RegExp;

	var regexpUnsupportedDotAll = fails$3(function () {
	  var re = $RegExp$1('.', 's');
	  return !(re.dotAll && re.exec('\n') && re.flags === 's');
	});

	var fails$2 = fails$l;
	var global$1 = global$l;

	// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
	var $RegExp = global$1.RegExp;

	var regexpUnsupportedNcg = fails$2(function () {
	  var re = $RegExp('(?<a>b)', 'g');
	  return re.exec('b').groups.a !== 'b' ||
	    'b'.replace(re, '$<a>c') !== 'bc';
	});

	/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
	/* eslint-disable regexp/no-useless-quantifier -- testing */
	var call$2 = functionCall;
	var uncurryThis$4 = functionUncurryThis;
	var toString$2 = toString$3;
	var regexpFlags = regexpFlags$1;
	var stickyHelpers = regexpStickyHelpers;
	var shared = sharedExports;
	var create = objectCreate;
	var getInternalState = internalState.get;
	var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
	var UNSUPPORTED_NCG = regexpUnsupportedNcg;

	var nativeReplace = shared('native-string-replace', String.prototype.replace);
	var nativeExec = RegExp.prototype.exec;
	var patchedExec = nativeExec;
	var charAt$3 = uncurryThis$4(''.charAt);
	var indexOf = uncurryThis$4(''.indexOf);
	var replace$1 = uncurryThis$4(''.replace);
	var stringSlice$3 = uncurryThis$4(''.slice);

	var UPDATES_LAST_INDEX_WRONG = (function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  call$2(nativeExec, re1, 'a');
	  call$2(nativeExec, re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	})();

	var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

	if (PATCH) {
	  patchedExec = function exec(string) {
	    var re = this;
	    var state = getInternalState(re);
	    var str = toString$2(string);
	    var raw = state.raw;
	    var result, reCopy, lastIndex, match, i, object, group;

	    if (raw) {
	      raw.lastIndex = re.lastIndex;
	      result = call$2(patchedExec, raw, str);
	      re.lastIndex = raw.lastIndex;
	      return result;
	    }

	    var groups = state.groups;
	    var sticky = UNSUPPORTED_Y && re.sticky;
	    var flags = call$2(regexpFlags, re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;

	    if (sticky) {
	      flags = replace$1(flags, 'y', '');
	      if (indexOf(flags, 'g') === -1) {
	        flags += 'g';
	      }

	      strCopy = stringSlice$3(str, re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }

	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

	    match = call$2(nativeExec, sticky ? reCopy : re, strCopy);

	    if (sticky) {
	      if (match) {
	        match.input = stringSlice$3(match.input, charsAdded);
	        match[0] = stringSlice$3(match[0], charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
	      call$2(nativeReplace, match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }

	    if (match && groups) {
	      match.groups = object = create(null);
	      for (i = 0; i < groups.length; i++) {
	        group = groups[i];
	        object[group[0]] = match[group[1]];
	      }
	    }

	    return match;
	  };
	}

	var regexpExec$2 = patchedExec;

	var $ = _export;
	var exec = regexpExec$2;

	// `RegExp.prototype.exec` method
	// https://tc39.es/ecma262/#sec-regexp.prototype.exec
	$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
	  exec: exec
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points

	var uncurryThis$3 = functionUncurryThisClause;
	var defineBuiltIn = defineBuiltIn$6;
	var regexpExec$1 = regexpExec$2;
	var fails$1 = fails$l;
	var wellKnownSymbol$1 = wellKnownSymbol$g;
	var createNonEnumerableProperty = createNonEnumerableProperty$8;

	var SPECIES = wellKnownSymbol$1('species');
	var RegExpPrototype = RegExp.prototype;

	var fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
	  var SYMBOL = wellKnownSymbol$1(KEY);

	  var DELEGATES_TO_SYMBOL = !fails$1(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) !== 7;
	  });

	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;

	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES] = function () { return re; };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }

	    re.exec = function () {
	      execCalled = true;
	      return null;
	    };

	    re[SYMBOL]('');
	    return !execCalled;
	  });

	  if (
	    !DELEGATES_TO_SYMBOL ||
	    !DELEGATES_TO_EXEC ||
	    FORCED
	  ) {
	    var uncurriedNativeRegExpMethod = uncurryThis$3(/./[SYMBOL]);
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      var uncurriedNativeMethod = uncurryThis$3(nativeMethod);
	      var $exec = regexp.exec;
	      if ($exec === regexpExec$1 || $exec === RegExpPrototype.exec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
	        }
	        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
	      }
	      return { done: false };
	    });

	    defineBuiltIn(String.prototype, KEY, methods[0]);
	    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
	  }

	  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
	};

	var uncurryThis$2 = functionUncurryThis;
	var toIntegerOrInfinity$1 = toIntegerOrInfinity$7;
	var toString$1 = toString$3;
	var requireObjectCoercible$1 = requireObjectCoercible$4;

	var charAt$2 = uncurryThis$2(''.charAt);
	var charCodeAt = uncurryThis$2(''.charCodeAt);
	var stringSlice$2 = uncurryThis$2(''.slice);

	var createMethod = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = toString$1(requireObjectCoercible$1($this));
	    var position = toIntegerOrInfinity$1(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = charCodeAt(S, position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING
	          ? charAt$2(S, position)
	          : first
	        : CONVERT_TO_STRING
	          ? stringSlice$2(S, position, position + 2)
	          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod(true)
	};

	var charAt$1 = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.es/ecma262/#sec-advancestringindex
	var advanceStringIndex$1 = function (S, index, unicode) {
	  return index + (unicode ? charAt$1(S, index).length : 1);
	};

	var uncurryThis$1 = functionUncurryThis;
	var toObject = toObject$6;

	var floor = Math.floor;
	var charAt = uncurryThis$1(''.charAt);
	var replace = uncurryThis$1(''.replace);
	var stringSlice$1 = uncurryThis$1(''.slice);
	// eslint-disable-next-line redos/no-vulnerable -- safe
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

	// `GetSubstitution` abstract operation
	// https://tc39.es/ecma262/#sec-getsubstitution
	var getSubstitution$1 = function (matched, str, position, captures, namedCaptures, replacement) {
	  var tailPos = position + matched.length;
	  var m = captures.length;
	  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	  if (namedCaptures !== undefined) {
	    namedCaptures = toObject(namedCaptures);
	    symbols = SUBSTITUTION_SYMBOLS;
	  }
	  return replace(replacement, symbols, function (match, ch) {
	    var capture;
	    switch (charAt(ch, 0)) {
	      case '$': return '$';
	      case '&': return matched;
	      case '`': return stringSlice$1(str, 0, position);
	      case "'": return stringSlice$1(str, tailPos);
	      case '<':
	        capture = namedCaptures[stringSlice$1(ch, 1, -1)];
	        break;
	      default: // \d\d?
	        var n = +ch;
	        if (n === 0) return match;
	        if (n > m) {
	          var f = floor(n / 10);
	          if (f === 0) return match;
	          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
	          return match;
	        }
	        capture = captures[n - 1];
	    }
	    return capture === undefined ? '' : capture;
	  });
	};

	var call$1 = functionCall;
	var anObject$1 = anObject$9;
	var isCallable$1 = isCallable$k;
	var classof = classofRaw$2;
	var regexpExec = regexpExec$2;

	var $TypeError = TypeError;

	// `RegExpExec` abstract operation
	// https://tc39.es/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (isCallable$1(exec)) {
	    var result = call$1(exec, R, S);
	    if (result !== null) anObject$1(result);
	    return result;
	  }
	  if (classof(R) === 'RegExp') return call$1(regexpExec, R, S);
	  throw $TypeError('RegExp#exec called on incompatible receiver');
	};

	var apply = functionApply;
	var call = functionCall;
	var uncurryThis = functionUncurryThis;
	var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
	var fails = fails$l;
	var anObject = anObject$9;
	var isCallable = isCallable$k;
	var isNullOrUndefined = isNullOrUndefined$4;
	var toIntegerOrInfinity = toIntegerOrInfinity$7;
	var toLength = toLength$5;
	var toString = toString$3;
	var requireObjectCoercible = requireObjectCoercible$4;
	var advanceStringIndex = advanceStringIndex$1;
	var getMethod = getMethod$3;
	var getSubstitution = getSubstitution$1;
	var regExpExec = regexpExecAbstract;
	var wellKnownSymbol = wellKnownSymbol$g;

	var REPLACE = wellKnownSymbol('replace');
	var max = Math.max;
	var min = Math.min;
	var concat = uncurryThis([].concat);
	var push = uncurryThis([].push);
	var stringIndexOf = uncurryThis(''.indexOf);
	var stringSlice = uncurryThis(''.slice);

	var maybeToString = function (it) {
	  return it === undefined ? it : String(it);
	};

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = (function () {
	  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
	  return 'a'.replace(/./, '$0') === '$0';
	})();

	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	})();

	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = { a: '7' };
	    return result;
	  };
	  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
	  return ''.replace(re, '$<a>') !== '7';
	});

	// @@replace logic
	fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

	  return [
	    // `String.prototype.replace` method
	    // https://tc39.es/ecma262/#sec-string.prototype.replace
	    function replace(searchValue, replaceValue) {
	      var O = requireObjectCoercible(this);
	      var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
	      return replacer
	        ? call(replacer, searchValue, O, replaceValue)
	        : call(nativeReplace, toString(O), searchValue, replaceValue);
	    },
	    // `RegExp.prototype[@@replace]` method
	    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
	    function (string, replaceValue) {
	      var rx = anObject(this);
	      var S = toString(string);

	      if (
	        typeof replaceValue == 'string' &&
	        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
	        stringIndexOf(replaceValue, '$<') === -1
	      ) {
	        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
	        if (res.done) return res.value;
	      }

	      var functionalReplace = isCallable(replaceValue);
	      if (!functionalReplace) replaceValue = toString(replaceValue);

	      var global = rx.global;
	      var fullUnicode;
	      if (global) {
	        fullUnicode = rx.unicode;
	        rx.lastIndex = 0;
	      }

	      var results = [];
	      var result;
	      while (true) {
	        result = regExpExec(rx, S);
	        if (result === null) break;

	        push(results, result);
	        if (!global) break;

	        var matchStr = toString(result[0]);
	        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      }

	      var accumulatedResult = '';
	      var nextSourcePosition = 0;
	      for (var i = 0; i < results.length; i++) {
	        result = results[i];

	        var matched = toString(result[0]);
	        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
	        var captures = [];
	        var replacement;
	        // NOTE: This is equivalent to
	        //   captures = result.slice(1).map(maybeToString)
	        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
	        var namedCaptures = result.groups;
	        if (functionalReplace) {
	          var replacerArgs = concat([matched], captures, position, S);
	          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
	          replacement = toString(apply(replaceValue, undefined, replacerArgs));
	        } else {
	          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	        }
	        if (position >= nextSourcePosition) {
	          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
	          nextSourcePosition = position + matched.length;
	        }
	      }

	      return accumulatedResult + stringSlice(S, nextSourcePosition);
	    }
	  ];
	}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const i = "important",
	  n = " !" + i,
	  o = e(class extends i$1 {
	    constructor(t$1) {
	      var e;
	      if (super(t$1), t$1.type !== t.ATTRIBUTE || "style" !== t$1.name || (null === (e = t$1.strings) || void 0 === e ? void 0 : e.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
	    }
	    render(t) {
	      return Object.keys(t).reduce((e, r) => {
	        const s = t[r];
	        return null == s ? e : e + "".concat(r = r.includes("-") ? r : r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase(), ":").concat(s, ";");
	      }, "");
	    }
	    update(e, _ref) {
	      let [r] = _ref;
	      const {
	        style: s
	      } = e.element;
	      if (void 0 === this.ht) {
	        this.ht = new Set();
	        for (const t in r) this.ht.add(t);
	        return this.render(r);
	      }
	      this.ht.forEach(t => {
	        null == r[t] && (this.ht.delete(t), t.includes("-") ? s.removeProperty(t) : s[t] = "");
	      });
	      for (const t in r) {
	        const e = r[t];
	        if (null != e) {
	          this.ht.add(t);
	          const r = "string" == typeof e && e.endsWith(n);
	          t.includes("-") || r ? s.setProperty(t, r ? e.slice(0, -11) : e, r ? i : "") : s[t] = e;
	        }
	      }
	      return T;
	    }
	  });

	var _templateObject$h;
	/** @soyCompatible */
	class RippleBase extends BaseElement {
	  constructor() {
	    super(...arguments);
	    this.primary = false;
	    this.accent = false;
	    this.unbounded = false;
	    this.disabled = false;
	    this.activated = false;
	    this.selected = false;
	    this.internalUseStateLayerCustomProperties = false;
	    this.hovering = false;
	    this.bgFocused = false;
	    this.fgActivation = false;
	    this.fgDeactivation = false;
	    this.fgScale = '';
	    this.fgSize = '';
	    this.translateStart = '';
	    this.translateEnd = '';
	    this.leftPos = '';
	    this.topPos = '';
	    this.mdcFoundationClass = MDCRippleFoundation$1;
	  }
	  get isActive() {
	    return matches(this.parentElement || this, ':active');
	  }
	  createAdapter() {
	    return {
	      browserSupportsCssVars: () => true,
	      isUnbounded: () => this.unbounded,
	      isSurfaceActive: () => this.isActive,
	      isSurfaceDisabled: () => this.disabled,
	      addClass: className => {
	        switch (className) {
	          case 'mdc-ripple-upgraded--background-focused':
	            this.bgFocused = true;
	            break;
	          case 'mdc-ripple-upgraded--foreground-activation':
	            this.fgActivation = true;
	            break;
	          case 'mdc-ripple-upgraded--foreground-deactivation':
	            this.fgDeactivation = true;
	            break;
	        }
	      },
	      removeClass: className => {
	        switch (className) {
	          case 'mdc-ripple-upgraded--background-focused':
	            this.bgFocused = false;
	            break;
	          case 'mdc-ripple-upgraded--foreground-activation':
	            this.fgActivation = false;
	            break;
	          case 'mdc-ripple-upgraded--foreground-deactivation':
	            this.fgDeactivation = false;
	            break;
	        }
	      },
	      containsEventTarget: () => true,
	      registerInteractionHandler: () => undefined,
	      deregisterInteractionHandler: () => undefined,
	      registerDocumentInteractionHandler: () => undefined,
	      deregisterDocumentInteractionHandler: () => undefined,
	      registerResizeHandler: () => undefined,
	      deregisterResizeHandler: () => undefined,
	      updateCssVariable: (varName, value) => {
	        switch (varName) {
	          case '--mdc-ripple-fg-scale':
	            this.fgScale = value;
	            break;
	          case '--mdc-ripple-fg-size':
	            this.fgSize = value;
	            break;
	          case '--mdc-ripple-fg-translate-end':
	            this.translateEnd = value;
	            break;
	          case '--mdc-ripple-fg-translate-start':
	            this.translateStart = value;
	            break;
	          case '--mdc-ripple-left':
	            this.leftPos = value;
	            break;
	          case '--mdc-ripple-top':
	            this.topPos = value;
	            break;
	        }
	      },
	      computeBoundingRect: () => (this.parentElement || this).getBoundingClientRect(),
	      getWindowPageOffset: () => ({
	        x: window.pageXOffset,
	        y: window.pageYOffset
	      })
	    };
	  }
	  startPress(ev) {
	    this.waitForFoundation(() => {
	      this.mdcFoundation.activate(ev);
	    });
	  }
	  endPress() {
	    this.waitForFoundation(() => {
	      this.mdcFoundation.deactivate();
	    });
	  }
	  startFocus() {
	    this.waitForFoundation(() => {
	      this.mdcFoundation.handleFocus();
	    });
	  }
	  endFocus() {
	    this.waitForFoundation(() => {
	      this.mdcFoundation.handleBlur();
	    });
	  }
	  startHover() {
	    this.hovering = true;
	  }
	  endHover() {
	    this.hovering = false;
	  }
	  /**
	   * Wait for the MDCFoundation to be created by `firstUpdated`
	   */
	  waitForFoundation(fn) {
	    if (this.mdcFoundation) {
	      fn();
	    } else {
	      this.updateComplete.then(fn);
	    }
	  }
	  update(changedProperties) {
	    if (changedProperties.has('disabled')) {
	      // stop hovering when ripple is disabled to prevent a stuck "hover" state
	      // When re-enabled, the outer component will get a `mouseenter` event on
	      // the first movement, which will call `startHover()`
	      if (this.disabled) {
	        this.endHover();
	      }
	    }
	    super.update(changedProperties);
	  }
	  /** @soyTemplate */
	  render() {
	    const shouldActivateInPrimary = this.activated && (this.primary || !this.accent);
	    const shouldSelectInPrimary = this.selected && (this.primary || !this.accent);
	    /** @classMap */
	    const classes = {
	      'mdc-ripple-surface--accent': this.accent,
	      'mdc-ripple-surface--primary--activated': shouldActivateInPrimary,
	      'mdc-ripple-surface--accent--activated': this.accent && this.activated,
	      'mdc-ripple-surface--primary--selected': shouldSelectInPrimary,
	      'mdc-ripple-surface--accent--selected': this.accent && this.selected,
	      'mdc-ripple-surface--disabled': this.disabled,
	      'mdc-ripple-surface--hover': this.hovering,
	      'mdc-ripple-surface--primary': this.primary,
	      'mdc-ripple-surface--selected': this.selected,
	      'mdc-ripple-upgraded--background-focused': this.bgFocused,
	      'mdc-ripple-upgraded--foreground-activation': this.fgActivation,
	      'mdc-ripple-upgraded--foreground-deactivation': this.fgDeactivation,
	      'mdc-ripple-upgraded--unbounded': this.unbounded,
	      'mdc-ripple-surface--internal-use-state-layer-custom-properties': this.internalUseStateLayerCustomProperties
	    };
	    return x(_templateObject$h || (_templateObject$h = _taggedTemplateLiteral(["\n        <div class=\"mdc-ripple-surface mdc-ripple-upgraded ", "\"\n          style=\"", "\"></div>"])), o$1(classes), o({
	      '--mdc-ripple-fg-scale': this.fgScale,
	      '--mdc-ripple-fg-size': this.fgSize,
	      '--mdc-ripple-fg-translate-end': this.translateEnd,
	      '--mdc-ripple-fg-translate-start': this.translateStart,
	      '--mdc-ripple-left': this.leftPos,
	      '--mdc-ripple-top': this.topPos
	    }));
	  }
	}
	__decorate([i$4('.mdc-ripple-surface')], RippleBase.prototype, "mdcRoot", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "primary", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "accent", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "unbounded", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "disabled", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "activated", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "selected", void 0);
	__decorate([n$6({
	  type: Boolean
	})], RippleBase.prototype, "internalUseStateLayerCustomProperties", void 0);
	__decorate([t$3()], RippleBase.prototype, "hovering", void 0);
	__decorate([t$3()], RippleBase.prototype, "bgFocused", void 0);
	__decorate([t$3()], RippleBase.prototype, "fgActivation", void 0);
	__decorate([t$3()], RippleBase.prototype, "fgDeactivation", void 0);
	__decorate([t$3()], RippleBase.prototype, "fgScale", void 0);
	__decorate([t$3()], RippleBase.prototype, "fgSize", void 0);
	__decorate([t$3()], RippleBase.prototype, "translateStart", void 0);
	__decorate([t$3()], RippleBase.prototype, "translateEnd", void 0);
	__decorate([t$3()], RippleBase.prototype, "leftPos", void 0);
	__decorate([t$3()], RippleBase.prototype, "topPos", void 0);

	var _templateObject$g;
	const styles$8 = i$3(_templateObject$g || (_templateObject$g = _taggedTemplateLiteral([".mdc-ripple-surface{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity;position:relative;outline:none;overflow:hidden}.mdc-ripple-surface::before,.mdc-ripple-surface::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:\"\"}.mdc-ripple-surface::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-ripple-surface::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-ripple-surface.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-ripple-surface::before,.mdc-ripple-surface::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-ripple-surface.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded],.mdc-ripple-upgraded--unbounded{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]::after,.mdc-ripple-upgraded--unbounded::before,.mdc-ripple-upgraded--unbounded::after{top:calc(50% - 50%);left:calc(50% - 50%);width:100%;height:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::before,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::before,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{top:var(--mdc-ripple-top, calc(50% - 50%));left:var(--mdc-ripple-left, calc(50% - 50%));width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded::after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-ripple-surface::before,.mdc-ripple-surface::after{background-color:#000;background-color:var(--mdc-ripple-color, #000)}.mdc-ripple-surface:hover::before,.mdc-ripple-surface.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:block}:host .mdc-ripple-surface{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;will-change:unset}.mdc-ripple-surface--primary::before,.mdc-ripple-surface--primary::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary:hover::before,.mdc-ripple-surface--primary.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--primary.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--primary--activated::before,.mdc-ripple-surface--primary--activated::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--activated:hover::before,.mdc-ripple-surface--primary--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--primary--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--primary--selected::before,.mdc-ripple-surface--primary--selected::after{background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-ripple-surface--primary--selected:hover::before,.mdc-ripple-surface--primary--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--primary--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--primary--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent::before,.mdc-ripple-surface--accent::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent:hover::before,.mdc-ripple-surface--accent.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-ripple-surface--accent.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before{opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12)}.mdc-ripple-surface--accent--activated::before,.mdc-ripple-surface--accent--activated::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--activated:hover::before,.mdc-ripple-surface--accent--activated.mdc-ripple-surface--hover::before{opacity:0.16;opacity:var(--mdc-ripple-hover-opacity, 0.16)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-focus-opacity, 0.24)}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--activated:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.24;opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.24)}.mdc-ripple-surface--accent--selected::before{opacity:0.08;opacity:var(--mdc-ripple-selected-opacity, 0.08)}.mdc-ripple-surface--accent--selected::before,.mdc-ripple-surface--accent--selected::after{background-color:#018786;background-color:var(--mdc-ripple-color, var(--mdc-theme-secondary, #018786))}.mdc-ripple-surface--accent--selected:hover::before,.mdc-ripple-surface--accent--selected.mdc-ripple-surface--hover::before{opacity:0.12;opacity:var(--mdc-ripple-hover-opacity, 0.12)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-focus-opacity, 0.2)}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--accent--selected:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.2;opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--accent--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.2)}.mdc-ripple-surface--disabled{opacity:0}.mdc-ripple-surface--internal-use-state-layer-custom-properties::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties::after{background-color:#000;background-color:var(--mdc-ripple-hover-state-layer-color, #000)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:hover::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-surface--hover::before{opacity:0.04;opacity:var(--mdc-ripple-hover-state-layer-opacity, 0.04)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded--background-focused::before,.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-ripple-surface--internal-use-state-layer-custom-properties:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}.mdc-ripple-surface--internal-use-state-layer-custom-properties.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-pressed-state-layer-opacity, 0.12)}"])));

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/** @soyCompatible */
	let Ripple = class Ripple extends RippleBase {};
	Ripple.styles = [styles$8];
	Ripple = __decorate([e$8('mwc-ripple')], Ripple);

	/**
	 * @license
	 * Copyright 2021 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/**
	 * TypeScript version of the decorator
	 * @see https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators
	 */
	function tsDecorator(prototype, name, descriptor) {
	  const constructor = prototype.constructor;
	  if (!descriptor) {
	    /**
	     * lit uses internal properties with two leading underscores to
	     * provide storage for accessors
	     */
	    const litInternalPropertyKey = "__".concat(name);
	    descriptor = constructor.getPropertyDescriptor(name, litInternalPropertyKey);
	    if (!descriptor) {
	      throw new Error('@ariaProperty must be used after a @property decorator');
	    }
	  }
	  // descriptor must exist at this point, reassign so typescript understands
	  const propDescriptor = descriptor;
	  let attribute = '';
	  if (!propDescriptor.set) {
	    throw new Error("@ariaProperty requires a setter for ".concat(name));
	  }
	  // TODO(b/202853219): Remove this check when internal tooling is
	  // compatible
	  // tslint:disable-next-line:no-any bail if applied to internal generated class
	  if (prototype.dispatchWizEvent) {
	    return descriptor;
	  }
	  const wrappedDescriptor = {
	    configurable: true,
	    enumerable: true,
	    set(value) {
	      if (attribute === '') {
	        const options = constructor.getPropertyOptions(name);
	        // if attribute is not a string, use `name` instead
	        attribute = typeof options.attribute === 'string' ? options.attribute : name;
	      }
	      if (this.hasAttribute(attribute)) {
	        this.removeAttribute(attribute);
	      }
	      propDescriptor.set.call(this, value);
	    }
	  };
	  if (propDescriptor.get) {
	    wrappedDescriptor.get = function () {
	      return propDescriptor.get.call(this);
	    };
	  }
	  return wrappedDescriptor;
	}
	/**
	 * A property decorator proxies an aria attribute to an internal node
	 *
	 * This decorator is only intended for use with ARIA attributes, such as `role`
	 * and `aria-label` due to screenreader needs.
	 *
	 * Upon first render, `@ariaProperty` will remove the attribute from the host
	 * element to prevent screenreaders from reading the host instead of the
	 * internal node.
	 *
	 * This decorator should only be used for non-Symbol public fields decorated
	 * with `@property`, or on a setter with an optional getter.
	 *
	 * @example
	 * ```ts
	 * class MyElement {
	 *   @ariaProperty
	 *   @property({ type: String, attribute: 'aria-label' })
	 *   ariaLabel!: string;
	 * }
	 * ```
	 * @category Decorator
	 * @ExportDecoratedItems
	 */
	function ariaProperty(protoOrDescriptor, name,
	// tslint:disable-next-line:no-any any is required as a return type from decorators
	descriptor) {
	  if (name !== undefined) {
	    return tsDecorator(protoOrDescriptor, name, descriptor);
	  } else {
	    throw new Error('@ariaProperty only supports TypeScript Decorators');
	  }
	}

	/**
	 * @license
	 * Copyright 2020 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/**
	 * Class that encapsulates the events handlers for `mwc-ripple`
	 *
	 *
	 * Example:
	 * ```
	 * class XFoo extends LitElement {
	 *   async getRipple() {
	 *     this.renderRipple = true;
	 *     await this.updateComplete;
	 *     return this.renderRoot.querySelector('mwc-ripple');
	 *   }
	 *   rippleHandlers = new RippleHandlers(() => this.getRipple());
	 *
	 *   render() {
	 *     return html`
	 *       <div @mousedown=${this.rippleHandlers.startPress}></div>
	 *       ${this.renderRipple ? html`<mwc-ripple></mwc-ripple>` : ''}
	 *     `;
	 *   }
	 * }
	 * ```
	 */
	class RippleHandlers {
	  constructor( /** Function that returns a `mwc-ripple` */
	  rippleFn) {
	    this.startPress = ev => {
	      rippleFn().then(r => {
	        r && r.startPress(ev);
	      });
	    };
	    this.endPress = () => {
	      rippleFn().then(r => {
	        r && r.endPress();
	      });
	    };
	    this.startFocus = () => {
	      rippleFn().then(r => {
	        r && r.startFocus();
	      });
	    };
	    this.endFocus = () => {
	      rippleFn().then(r => {
	        r && r.endFocus();
	      });
	    };
	    this.startHover = () => {
	      rippleFn().then(r => {
	        r && r.startHover();
	      });
	    };
	    this.endHover = () => {
	      rippleFn().then(r => {
	        r && r.endHover();
	      });
	    };
	  }
	}

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: BSD-3-Clause
	 */
	const l = l => null != l ? l : A;

	var _templateObject$f, _templateObject2$7, _templateObject3$4;
	/** @soyCompatible */
	class IconButtonBase extends s {
	  constructor() {
	    super(...arguments);
	    this.disabled = false;
	    this.icon = '';
	    this.shouldRenderRipple = false;
	    this.rippleHandlers = new RippleHandlers(() => {
	      this.shouldRenderRipple = true;
	      return this.ripple;
	    });
	  }
	  /** @soyTemplate */
	  renderRipple() {
	    return this.shouldRenderRipple ? x(_templateObject$f || (_templateObject$f = _taggedTemplateLiteral(["\n            <mwc-ripple\n                .disabled=\"", "\"\n                unbounded>\n            </mwc-ripple>"])), this.disabled) : '';
	  }
	  focus() {
	    const buttonElement = this.buttonElement;
	    if (buttonElement) {
	      this.rippleHandlers.startFocus();
	      buttonElement.focus();
	    }
	  }
	  blur() {
	    const buttonElement = this.buttonElement;
	    if (buttonElement) {
	      this.rippleHandlers.endFocus();
	      buttonElement.blur();
	    }
	  }
	  /** @soyTemplate */
	  render() {
	    return x(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteral(["<button\n        class=\"mdc-icon-button mdc-icon-button--display-flex\"\n        aria-label=\"", "\"\n        aria-haspopup=\"", "\"\n        ?disabled=\"", "\"\n        @focus=\"", "\"\n        @blur=\"", "\"\n        @mousedown=\"", "\"\n        @mouseenter=\"", "\"\n        @mouseleave=\"", "\"\n        @touchstart=\"", "\"\n        @touchend=\"", "\"\n        @touchcancel=\"", "\"\n    >", "\n    ", "\n    <span\n      ><slot></slot\n    ></span>\n  </button>"])), this.ariaLabel || this.icon, l(this.ariaHasPopup), this.disabled, this.handleRippleFocus, this.handleRippleBlur, this.handleRippleMouseDown, this.handleRippleMouseEnter, this.handleRippleMouseLeave, this.handleRippleTouchStart, this.handleRippleDeactivate, this.handleRippleDeactivate, this.renderRipple(), this.icon ? x(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteral(["<i class=\"material-icons\">", "</i>"])), this.icon) : '');
	  }
	  handleRippleMouseDown(event) {
	    const onUp = () => {
	      window.removeEventListener('mouseup', onUp);
	      this.handleRippleDeactivate();
	    };
	    window.addEventListener('mouseup', onUp);
	    this.rippleHandlers.startPress(event);
	  }
	  handleRippleTouchStart(event) {
	    this.rippleHandlers.startPress(event);
	  }
	  handleRippleDeactivate() {
	    this.rippleHandlers.endPress();
	  }
	  handleRippleMouseEnter() {
	    this.rippleHandlers.startHover();
	  }
	  handleRippleMouseLeave() {
	    this.rippleHandlers.endHover();
	  }
	  handleRippleFocus() {
	    this.rippleHandlers.startFocus();
	  }
	  handleRippleBlur() {
	    this.rippleHandlers.endFocus();
	  }
	}
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], IconButtonBase.prototype, "disabled", void 0);
	__decorate([n$6({
	  type: String
	})], IconButtonBase.prototype, "icon", void 0);
	__decorate([ariaProperty, n$6({
	  type: String,
	  attribute: 'aria-label'
	})], IconButtonBase.prototype, "ariaLabel", void 0);
	__decorate([ariaProperty, n$6({
	  type: String,
	  attribute: 'aria-haspopup'
	})], IconButtonBase.prototype, "ariaHasPopup", void 0);
	__decorate([i$4('button')], IconButtonBase.prototype, "buttonElement", void 0);
	__decorate([e$5('mwc-ripple')], IconButtonBase.prototype, "ripple", void 0);
	__decorate([t$3()], IconButtonBase.prototype, "shouldRenderRipple", void 0);
	__decorate([e$6({
	  passive: true
	})], IconButtonBase.prototype, "handleRippleMouseDown", null);
	__decorate([e$6({
	  passive: true
	})], IconButtonBase.prototype, "handleRippleTouchStart", null);

	var _templateObject$e;
	const styles$7 = i$3(_templateObject$e || (_templateObject$e = _taggedTemplateLiteral([".material-icons{font-family:var(--mdc-icon-font, \"Material Icons\");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:\"liga\"}.mdc-icon-button{font-size:24px;width:48px;height:48px;padding:12px}.mdc-icon-button .mdc-icon-button__focus-ring{display:none}.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block;max-height:48px;max-width:48px}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%}}@media screen and (forced-colors: active)and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring::after,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring::after{content:\"\";border:2px solid transparent;border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}}@media screen and (forced-colors: active)and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring::after,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:40px;height:40px;margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-icon-button.mdc-icon-button--reduced-size.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button.mdc-icon-button--reduced-size:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{max-height:40px;max-width:40px}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button:disabled{color:rgba(0, 0, 0, 0.38);color:var(--mdc-theme-text-disabled-on-light, rgba(0, 0, 0, 0.38))}.mdc-icon-button svg,.mdc-icon-button img{width:24px;height:24px}.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:transparent;fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:transparent;fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}:host{display:inline-block;outline:none}:host([disabled]){pointer-events:none}.mdc-icon-button i,.mdc-icon-button svg,.mdc-icon-button img,.mdc-icon-button ::slotted(*){display:block}:host{--mdc-ripple-color: currentcolor;-webkit-tap-highlight-color:transparent}:host,.mdc-icon-button{vertical-align:top}.mdc-icon-button{width:var(--mdc-icon-button-size, 48px);height:var(--mdc-icon-button-size, 48px);padding:calc( (var(--mdc-icon-button-size, 48px) - var(--mdc-icon-size, 24px)) / 2 )}.mdc-icon-button i,.mdc-icon-button svg,.mdc-icon-button img,.mdc-icon-button ::slotted(*){display:block;width:var(--mdc-icon-size, 24px);height:var(--mdc-icon-size, 24px)}"])));

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/** @soyCompatible */
	let IconButton = class IconButton extends IconButtonBase {};
	IconButton.styles = [styles$7];
	IconButton = __decorate([e$8('mwc-icon-button')], IconButton);

	/**
	 * @license
	 * Copyright 2016 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	(() => {
	  var _a, _b, _c;
	  /* Symbols for private properties */
	  const _blockingElements = Symbol();
	  const _alreadyInertElements = Symbol();
	  const _topElParents = Symbol();
	  const _siblingsToRestore = Symbol();
	  const _parentMO = Symbol();
	  /* Symbols for private static methods */
	  const _topChanged = Symbol();
	  const _swapInertedSibling = Symbol();
	  const _inertSiblings = Symbol();
	  const _restoreInertedSiblings = Symbol();
	  const _getParents = Symbol();
	  const _getDistributedChildren = Symbol();
	  const _isInertable = Symbol();
	  const _handleMutations = Symbol();
	  class BlockingElementsImpl {
	    constructor() {
	      /**
	       * The blocking elements.
	       */
	      this[_a] = [];
	      /**
	       * Used to keep track of the parents of the top element, from the element
	       * itself up to body. When top changes, the old top might have been removed
	       * from the document, so we need to memoize the inerted parents' siblings
	       * in order to restore their inerteness when top changes.
	       */
	      this[_b] = [];
	      /**
	       * Elements that are already inert before the first blocking element is
	       * pushed.
	       */
	      this[_c] = new Set();
	    }
	    destructor() {
	      // Restore original inertness.
	      this[_restoreInertedSiblings](this[_topElParents]);
	      // Note we don't want to make these properties nullable on the class,
	      // since then we'd need non-null casts in many places. Calling a method on
	      // a BlockingElements instance after calling destructor will result in an
	      // exception.
	      const nullable = this;
	      nullable[_blockingElements] = null;
	      nullable[_topElParents] = null;
	      nullable[_alreadyInertElements] = null;
	    }
	    get top() {
	      const elems = this[_blockingElements];
	      return elems[elems.length - 1] || null;
	    }
	    push(element) {
	      if (!element || element === this.top) {
	        return;
	      }
	      // Remove it from the stack, we'll bring it to the top.
	      this.remove(element);
	      this[_topChanged](element);
	      this[_blockingElements].push(element);
	    }
	    remove(element) {
	      const i = this[_blockingElements].indexOf(element);
	      if (i === -1) {
	        return false;
	      }
	      this[_blockingElements].splice(i, 1);
	      // Top changed only if the removed element was the top element.
	      if (i === this[_blockingElements].length) {
	        this[_topChanged](this.top);
	      }
	      return true;
	    }
	    pop() {
	      const top = this.top;
	      top && this.remove(top);
	      return top;
	    }
	    has(element) {
	      return this[_blockingElements].indexOf(element) !== -1;
	    }
	    /**
	     * Sets `inert` to all document elements except the new top element, its
	     * parents, and its distributed content.
	     */
	    [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
	      const toKeepInert = this[_alreadyInertElements];
	      const oldParents = this[_topElParents];
	      // No new top, reset old top if any.
	      if (!newTop) {
	        this[_restoreInertedSiblings](oldParents);
	        toKeepInert.clear();
	        this[_topElParents] = [];
	        return;
	      }
	      const newParents = this[_getParents](newTop);
	      // New top is not contained in the main document!
	      if (newParents[newParents.length - 1].parentNode !== document.body) {
	        throw Error('Non-connected element cannot be a blocking element');
	      }
	      // Cast here because we know we'll call _inertSiblings on newParents
	      // below.
	      this[_topElParents] = newParents;
	      const toSkip = this[_getDistributedChildren](newTop);
	      // No previous top element.
	      if (!oldParents.length) {
	        this[_inertSiblings](newParents, toSkip, toKeepInert);
	        return;
	      }
	      let i = oldParents.length - 1;
	      let j = newParents.length - 1;
	      // Find common parent. Index 0 is the element itself (so stop before it).
	      while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
	        i--;
	        j--;
	      }
	      // If up the parents tree there are 2 elements that are siblings, swap
	      // the inerted sibling.
	      if (oldParents[i] !== newParents[j]) {
	        this[_swapInertedSibling](oldParents[i], newParents[j]);
	      }
	      // Restore old parents siblings inertness.
	      i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
	      // Make new parents siblings inert.
	      j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
	    }
	    /**
	     * Swaps inertness between two sibling elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */
	    [_swapInertedSibling](oldInert, newInert) {
	      const siblingsToRestore = oldInert[_siblingsToRestore];
	      // oldInert is not contained in siblings to restore, so we have to check
	      // if it's inertable and if already inert.
	      if (this[_isInertable](oldInert) && !oldInert.inert) {
	        oldInert.inert = true;
	        siblingsToRestore.add(oldInert);
	      }
	      // If newInert was already between the siblings to restore, it means it is
	      // inertable and must be restored.
	      if (siblingsToRestore.has(newInert)) {
	        newInert.inert = false;
	        siblingsToRestore.delete(newInert);
	      }
	      newInert[_parentMO] = oldInert[_parentMO];
	      newInert[_siblingsToRestore] = siblingsToRestore;
	      oldInert[_parentMO] = undefined;
	      oldInert[_siblingsToRestore] = undefined;
	    }
	    /**
	     * Restores original inertness to the siblings of the elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */
	    [_restoreInertedSiblings](elements) {
	      for (const element of elements) {
	        const mo = element[_parentMO];
	        mo.disconnect();
	        element[_parentMO] = undefined;
	        const siblings = element[_siblingsToRestore];
	        for (const sibling of siblings) {
	          sibling.inert = false;
	        }
	        element[_siblingsToRestore] = undefined;
	      }
	    }
	    /**
	     * Inerts the siblings of the elements except the elements to skip. Stores
	     * the inerted siblings into the element's symbol `_siblingsToRestore`.
	     * Pass `toKeepInert` to collect the already inert elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */
	    [_inertSiblings](elements, toSkip, toKeepInert) {
	      for (const element of elements) {
	        // Assume element is not a Document, so it must have a parentNode.
	        const parent = element.parentNode;
	        const children = parent.children;
	        const inertedSiblings = new Set();
	        for (let j = 0; j < children.length; j++) {
	          const sibling = children[j];
	          // Skip the input element, if not inertable or to be skipped.
	          if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
	            continue;
	          }
	          // Should be collected since already inerted.
	          if (toKeepInert && sibling.inert) {
	            toKeepInert.add(sibling);
	          } else {
	            sibling.inert = true;
	            inertedSiblings.add(sibling);
	          }
	        }
	        // Store the siblings that were inerted.
	        element[_siblingsToRestore] = inertedSiblings;
	        // Observe only immediate children mutations on the parent.
	        const mo = new MutationObserver(this[_handleMutations].bind(this));
	        element[_parentMO] = mo;
	        let parentToObserve = parent;
	        // If we're using the ShadyDOM polyfill, then our parent could be a
	        // shady root, which is an object that acts like a ShadowRoot, but isn't
	        // actually a node in the real DOM. Observe the real DOM parent instead.
	        const maybeShadyRoot = parentToObserve;
	        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
	          parentToObserve = maybeShadyRoot.host;
	        }
	        mo.observe(parentToObserve, {
	          childList: true
	        });
	      }
	    }
	    /**
	     * Handles newly added/removed nodes by toggling their inertness.
	     * It also checks if the current top Blocking Element has been removed,
	     * notifying and removing it.
	     */
	    [_handleMutations](mutations) {
	      const parents = this[_topElParents];
	      const toKeepInert = this[_alreadyInertElements];
	      for (const mutation of mutations) {
	        // If the target is a shadowRoot, get its host as we skip shadowRoots when
	        // computing _topElParents.
	        const target = mutation.target.host || mutation.target;
	        const idx = target === document.body ? parents.length : parents.indexOf(target);
	        const inertedChild = parents[idx - 1];
	        const inertedSiblings = inertedChild[_siblingsToRestore];
	        // To restore.
	        for (let i = 0; i < mutation.removedNodes.length; i++) {
	          const sibling = mutation.removedNodes[i];
	          if (sibling === inertedChild) {
	            console.info('Detected removal of the top Blocking Element.');
	            this.pop();
	            return;
	          }
	          if (inertedSiblings.has(sibling)) {
	            sibling.inert = false;
	            inertedSiblings.delete(sibling);
	          }
	        }
	        // To inert.
	        for (let i = 0; i < mutation.addedNodes.length; i++) {
	          const sibling = mutation.addedNodes[i];
	          if (!this[_isInertable](sibling)) {
	            continue;
	          }
	          if (toKeepInert && sibling.inert) {
	            toKeepInert.add(sibling);
	          } else {
	            sibling.inert = true;
	            inertedSiblings.add(sibling);
	          }
	        }
	      }
	    }
	    /**
	     * Returns if the element is inertable.
	     */
	    [_isInertable](element) {
	      return false === /^(style|template|script)$/.test(element.localName);
	    }
	    /**
	     * Returns the list of newParents of an element, starting from element
	     * (included) up to `document.body` (excluded).
	     */
	    [_getParents](element) {
	      const parents = [];
	      let current = element;
	      // Stop to body.
	      while (current && current !== document.body) {
	        // Skip shadow roots.
	        if (current.nodeType === Node.ELEMENT_NODE) {
	          parents.push(current);
	        }
	        // ShadowDom v1
	        if (current.assignedSlot) {
	          // Collect slots from deepest slot to top.
	          while (current = current.assignedSlot) {
	            parents.push(current);
	          }
	          // Continue the search on the top slot.
	          current = parents.pop();
	          continue;
	        }
	        current = current.parentNode || current.host;
	      }
	      return parents;
	    }
	    /**
	     * Returns the distributed children of the element's shadow root.
	     * Returns null if the element doesn't have a shadow root.
	     */
	    [_getDistributedChildren](element) {
	      const shadowRoot = element.shadowRoot;
	      if (!shadowRoot) {
	        return null;
	      }
	      const result = new Set();
	      let i;
	      let j;
	      let nodes;
	      const slots = shadowRoot.querySelectorAll('slot');
	      if (slots.length && slots[0].assignedNodes) {
	        for (i = 0; i < slots.length; i++) {
	          nodes = slots[i].assignedNodes({
	            flatten: true
	          });
	          for (j = 0; j < nodes.length; j++) {
	            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
	              result.add(nodes[j]);
	            }
	          }
	        }
	        // No need to search for <content>.
	      }

	      return result;
	    }
	  }
	  document.$blockingElements = new BlockingElementsImpl();
	})();

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	/**
	 * This work is licensed under the W3C Software and Document License
	 * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
	 */

	(function () {
	  // Return early if we're not running inside of the browser.
	  if (typeof window === 'undefined') {
	    return;
	  }

	  // Convenience function for converting NodeLists.
	  /** @type {typeof Array.prototype.slice} */
	  var slice = Array.prototype.slice;

	  /**
	   * IE has a non-standard name for "matches".
	   * @type {typeof Element.prototype.matches}
	   */
	  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

	  /** @type {string} */
	  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

	  /**
	   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
	   * attribute.
	   *
	   * Its main functions are:
	   *
	   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
	   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
	   *   each focusable node in the subtree with the singleton `InertManager` which manages all known
	   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
	   *   instance exists for each focusable node which has at least one inert root as an ancestor.
	   *
	   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
	   *   attribute is removed from the root node). This is handled in the destructor, which calls the
	   *   `deregister` method on `InertManager` for each managed inert node.
	   */

	  var InertRoot = function () {
	    /**
	     * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
	     * @param {!InertManager} inertManager The global singleton InertManager object.
	     */
	    function InertRoot(rootElement, inertManager) {
	      _classCallCheck(this, InertRoot);

	      /** @type {!InertManager} */
	      this._inertManager = inertManager;

	      /** @type {!HTMLElement} */
	      this._rootElement = rootElement;

	      /**
	       * @type {!Set<!InertNode>}
	       * All managed focusable nodes in this InertRoot's subtree.
	       */
	      this._managedNodes = new Set();

	      // Make the subtree hidden from assistive technology
	      if (this._rootElement.hasAttribute('aria-hidden')) {
	        /** @type {?string} */
	        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
	      } else {
	        this._savedAriaHidden = null;
	      }
	      this._rootElement.setAttribute('aria-hidden', 'true');

	      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
	      this._makeSubtreeUnfocusable(this._rootElement);

	      // Watch for:
	      // - any additions in the subtree: make them unfocusable too
	      // - any removals from the subtree: remove them from this inert root's managed nodes
	      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
	      //   element, make that node a managed node.
	      this._observer = new MutationObserver(this._onMutation.bind(this));
	      this._observer.observe(this._rootElement, {
	        attributes: true,
	        childList: true,
	        subtree: true
	      });
	    }

	    /**
	     * Call this whenever this object is about to become obsolete.  This unwinds all of the state
	     * stored in this object and updates the state of all of the managed nodes.
	     */

	    _createClass(InertRoot, [{
	      key: 'destructor',
	      value: function destructor() {
	        this._observer.disconnect();
	        if (this._rootElement) {
	          if (this._savedAriaHidden !== null) {
	            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
	          } else {
	            this._rootElement.removeAttribute('aria-hidden');
	          }
	        }
	        this._managedNodes.forEach(function (inertNode) {
	          this._unmanageNode(inertNode.node);
	        }, this);

	        // Note we cast the nulls to the ANY type here because:
	        // 1) We want the class properties to be declared as non-null, or else we
	        //    need even more casts throughout this code. All bets are off if an
	        //    instance has been destroyed and a method is called.
	        // 2) We don't want to cast "this", because we want type-aware optimizations
	        //    to know which properties we're setting.
	        this._observer = /** @type {?} */null;
	        this._rootElement = /** @type {?} */null;
	        this._managedNodes = /** @type {?} */null;
	        this._inertManager = /** @type {?} */null;
	      }

	      /**
	       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
	       */
	    }, {
	      key: '_makeSubtreeUnfocusable',
	      /**
	       * @param {!Node} startNode
	       */
	      value: function _makeSubtreeUnfocusable(startNode) {
	        var _this2 = this;
	        composedTreeWalk(startNode, function (node) {
	          return _this2._visitNode(node);
	        });
	        var activeElement = document.activeElement;
	        if (!document.body.contains(startNode)) {
	          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
	          var node = startNode;
	          /** @type {!ShadowRoot|undefined} */
	          var root = undefined;
	          while (node) {
	            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	              root = /** @type {!ShadowRoot} */node;
	              break;
	            }
	            node = node.parentNode;
	          }
	          if (root) {
	            activeElement = root.activeElement;
	          }
	        }
	        if (startNode.contains(activeElement)) {
	          activeElement.blur();
	          // In IE11, if an element is already focused, and then set to tabindex=-1
	          // calling blur() will not actually move the focus.
	          // To work around this we call focus() on the body instead.
	          if (activeElement === document.activeElement) {
	            document.body.focus();
	          }
	        }
	      }

	      /**
	       * @param {!Node} node
	       */
	    }, {
	      key: '_visitNode',
	      value: function _visitNode(node) {
	        if (node.nodeType !== Node.ELEMENT_NODE) {
	          return;
	        }
	        var element = /** @type {!HTMLElement} */node;

	        // If a descendant inert root becomes un-inert, its descendants will still be inert because of
	        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
	        if (element !== this._rootElement && element.hasAttribute('inert')) {
	          this._adoptInertRoot(element);
	        }
	        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
	          this._manageNode(element);
	        }
	      }

	      /**
	       * Register the given node with this InertRoot and with InertManager.
	       * @param {!Node} node
	       */
	    }, {
	      key: '_manageNode',
	      value: function _manageNode(node) {
	        var inertNode = this._inertManager.register(node, this);
	        this._managedNodes.add(inertNode);
	      }

	      /**
	       * Unregister the given node with this InertRoot and with InertManager.
	       * @param {!Node} node
	       */
	    }, {
	      key: '_unmanageNode',
	      value: function _unmanageNode(node) {
	        var inertNode = this._inertManager.deregister(node, this);
	        if (inertNode) {
	          this._managedNodes['delete'](inertNode);
	        }
	      }

	      /**
	       * Unregister the entire subtree starting at `startNode`.
	       * @param {!Node} startNode
	       */
	    }, {
	      key: '_unmanageSubtree',
	      value: function _unmanageSubtree(startNode) {
	        var _this3 = this;
	        composedTreeWalk(startNode, function (node) {
	          return _this3._unmanageNode(node);
	        });
	      }

	      /**
	       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
	       * @param {!HTMLElement} node
	       */
	    }, {
	      key: '_adoptInertRoot',
	      value: function _adoptInertRoot(node) {
	        var inertSubroot = this._inertManager.getInertRoot(node);

	        // During initialisation this inert root may not have been registered yet,
	        // so register it now if need be.
	        if (!inertSubroot) {
	          this._inertManager.setInert(node, true);
	          inertSubroot = this._inertManager.getInertRoot(node);
	        }
	        inertSubroot.managedNodes.forEach(function (savedInertNode) {
	          this._manageNode(savedInertNode.node);
	        }, this);
	      }

	      /**
	       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
	       * @param {!Array<!MutationRecord>} records
	       * @param {!MutationObserver} self
	       */
	    }, {
	      key: '_onMutation',
	      value: function _onMutation(records, self) {
	        records.forEach(function (record) {
	          var target = /** @type {!HTMLElement} */record.target;
	          if (record.type === 'childList') {
	            // Manage added nodes
	            slice.call(record.addedNodes).forEach(function (node) {
	              this._makeSubtreeUnfocusable(node);
	            }, this);

	            // Un-manage removed nodes
	            slice.call(record.removedNodes).forEach(function (node) {
	              this._unmanageSubtree(node);
	            }, this);
	          } else if (record.type === 'attributes') {
	            if (record.attributeName === 'tabindex') {
	              // Re-initialise inert node if tabindex changes
	              this._manageNode(target);
	            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
	              // If a new inert root is added, adopt its managed nodes and make sure it knows about the
	              // already managed nodes from this inert subroot.
	              this._adoptInertRoot(target);
	              var inertSubroot = this._inertManager.getInertRoot(target);
	              this._managedNodes.forEach(function (managedNode) {
	                if (target.contains(managedNode.node)) {
	                  inertSubroot._manageNode(managedNode.node);
	                }
	              });
	            }
	          }
	        }, this);
	      }
	    }, {
	      key: 'managedNodes',
	      get: function get() {
	        return new Set(this._managedNodes);
	      }

	      /** @return {boolean} */
	    }, {
	      key: 'hasSavedAriaHidden',
	      get: function get() {
	        return this._savedAriaHidden !== null;
	      }

	      /** @param {?string} ariaHidden */
	    }, {
	      key: 'savedAriaHidden',
	      set: function set(ariaHidden) {
	        this._savedAriaHidden = ariaHidden;
	      }

	      /** @return {?string} */,

	      get: function get() {
	        return this._savedAriaHidden;
	      }
	    }]);
	    return InertRoot;
	  }();

	  /**
	   * `InertNode` initialises and manages a single inert node.
	   * A node is inert if it is a descendant of one or more inert root elements.
	   *
	   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
	   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
	   * is intrinsically focusable or not.
	   *
	   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
	   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
	   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
	   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
	   * or removes the `tabindex` attribute if the element is intrinsically focusable.
	   */

	  var InertNode = function () {
	    /**
	     * @param {!Node} node A focusable element to be made inert.
	     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
	     */
	    function InertNode(node, inertRoot) {
	      _classCallCheck(this, InertNode);

	      /** @type {!Node} */
	      this._node = node;

	      /** @type {boolean} */
	      this._overrodeFocusMethod = false;

	      /**
	       * @type {!Set<!InertRoot>} The set of descendant inert roots.
	       *    If and only if this set becomes empty, this node is no longer inert.
	       */
	      this._inertRoots = new Set([inertRoot]);

	      /** @type {?number} */
	      this._savedTabIndex = null;

	      /** @type {boolean} */
	      this._destroyed = false;

	      // Save any prior tabindex info and make this node untabbable
	      this.ensureUntabbable();
	    }

	    /**
	     * Call this whenever this object is about to become obsolete.
	     * This makes the managed node focusable again and deletes all of the previously stored state.
	     */

	    _createClass(InertNode, [{
	      key: 'destructor',
	      value: function destructor() {
	        this._throwIfDestroyed();
	        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
	          var element = /** @type {!HTMLElement} */this._node;
	          if (this._savedTabIndex !== null) {
	            element.setAttribute('tabindex', this._savedTabIndex);
	          } else {
	            element.removeAttribute('tabindex');
	          }

	          // Use `delete` to restore native focus method.
	          if (this._overrodeFocusMethod) {
	            delete element.focus;
	          }
	        }

	        // See note in InertRoot.destructor for why we cast these nulls to ANY.
	        this._node = /** @type {?} */null;
	        this._inertRoots = /** @type {?} */null;
	        this._destroyed = true;
	      }

	      /**
	       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
	       * If the object has been destroyed, any attempt to access it will cause an exception.
	       */
	    }, {
	      key: '_throwIfDestroyed',
	      /**
	       * Throw if user tries to access destroyed InertNode.
	       */
	      value: function _throwIfDestroyed() {
	        if (this.destroyed) {
	          throw new Error('Trying to access destroyed InertNode');
	        }
	      }

	      /** @return {boolean} */
	    }, {
	      key: 'ensureUntabbable',
	      /** Save the existing tabindex value and make the node untabbable and unfocusable */
	      value: function ensureUntabbable() {
	        if (this.node.nodeType !== Node.ELEMENT_NODE) {
	          return;
	        }
	        var element = /** @type {!HTMLElement} */this.node;
	        if (matches.call(element, _focusableElementsString)) {
	          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
	            return;
	          }
	          if (element.hasAttribute('tabindex')) {
	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
	          }
	          element.setAttribute('tabindex', '-1');
	          if (element.nodeType === Node.ELEMENT_NODE) {
	            element.focus = function () {};
	            this._overrodeFocusMethod = true;
	          }
	        } else if (element.hasAttribute('tabindex')) {
	          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
	          element.removeAttribute('tabindex');
	        }
	      }

	      /**
	       * Add another inert root to this inert node's set of managing inert roots.
	       * @param {!InertRoot} inertRoot
	       */
	    }, {
	      key: 'addInertRoot',
	      value: function addInertRoot(inertRoot) {
	        this._throwIfDestroyed();
	        this._inertRoots.add(inertRoot);
	      }

	      /**
	       * Remove the given inert root from this inert node's set of managing inert roots.
	       * If the set of managing inert roots becomes empty, this node is no longer inert,
	       * so the object should be destroyed.
	       * @param {!InertRoot} inertRoot
	       */
	    }, {
	      key: 'removeInertRoot',
	      value: function removeInertRoot(inertRoot) {
	        this._throwIfDestroyed();
	        this._inertRoots['delete'](inertRoot);
	        if (this._inertRoots.size === 0) {
	          this.destructor();
	        }
	      }
	    }, {
	      key: 'destroyed',
	      get: function get() {
	        return (/** @type {!InertNode} */this._destroyed
	        );
	      }
	    }, {
	      key: 'hasSavedTabIndex',
	      get: function get() {
	        return this._savedTabIndex !== null;
	      }

	      /** @return {!Node} */
	    }, {
	      key: 'node',
	      get: function get() {
	        this._throwIfDestroyed();
	        return this._node;
	      }

	      /** @param {?number} tabIndex */
	    }, {
	      key: 'savedTabIndex',
	      set: function set(tabIndex) {
	        this._throwIfDestroyed();
	        this._savedTabIndex = tabIndex;
	      }

	      /** @return {?number} */,

	      get: function get() {
	        this._throwIfDestroyed();
	        return this._savedTabIndex;
	      }
	    }]);
	    return InertNode;
	  }();

	  /**
	   * InertManager is a per-document singleton object which manages all inert roots and nodes.
	   *
	   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
	   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
	   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
	   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
	   * is created for each such node, via the `_managedNodes` map.
	   */

	  var InertManager = function () {
	    /**
	     * @param {!Document} document
	     */
	    function InertManager(document) {
	      _classCallCheck(this, InertManager);
	      if (!document) {
	        throw new Error('Missing required argument; InertManager needs to wrap a document.');
	      }

	      /** @type {!Document} */
	      this._document = document;

	      /**
	       * All managed nodes known to this InertManager. In a map to allow looking up by Node.
	       * @type {!Map<!Node, !InertNode>}
	       */
	      this._managedNodes = new Map();

	      /**
	       * All inert roots known to this InertManager. In a map to allow looking up by Node.
	       * @type {!Map<!Node, !InertRoot>}
	       */
	      this._inertRoots = new Map();

	      /**
	       * Observer for mutations on `document.body`.
	       * @type {!MutationObserver}
	       */
	      this._observer = new MutationObserver(this._watchForInert.bind(this));

	      // Add inert style.
	      addInertStyle(document.head || document.body || document.documentElement);

	      // Wait for document to be loaded.
	      if (document.readyState === 'loading') {
	        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
	      } else {
	        this._onDocumentLoaded();
	      }
	    }

	    /**
	     * Set whether the given element should be an inert root or not.
	     * @param {!HTMLElement} root
	     * @param {boolean} inert
	     */

	    _createClass(InertManager, [{
	      key: 'setInert',
	      value: function setInert(root, inert) {
	        if (inert) {
	          if (this._inertRoots.has(root)) {
	            // element is already inert
	            return;
	          }
	          var inertRoot = new InertRoot(root, this);
	          root.setAttribute('inert', '');
	          this._inertRoots.set(root, inertRoot);
	          // If not contained in the document, it must be in a shadowRoot.
	          // Ensure inert styles are added there.
	          if (!this._document.body.contains(root)) {
	            var parent = root.parentNode;
	            while (parent) {
	              if (parent.nodeType === 11) {
	                addInertStyle(parent);
	              }
	              parent = parent.parentNode;
	            }
	          }
	        } else {
	          if (!this._inertRoots.has(root)) {
	            // element is already non-inert
	            return;
	          }
	          var _inertRoot = this._inertRoots.get(root);
	          _inertRoot.destructor();
	          this._inertRoots['delete'](root);
	          root.removeAttribute('inert');
	        }
	      }

	      /**
	       * Get the InertRoot object corresponding to the given inert root element, if any.
	       * @param {!Node} element
	       * @return {!InertRoot|undefined}
	       */
	    }, {
	      key: 'getInertRoot',
	      value: function getInertRoot(element) {
	        return this._inertRoots.get(element);
	      }

	      /**
	       * Register the given InertRoot as managing the given node.
	       * In the case where the node has a previously existing inert root, this inert root will
	       * be added to its set of inert roots.
	       * @param {!Node} node
	       * @param {!InertRoot} inertRoot
	       * @return {!InertNode} inertNode
	       */
	    }, {
	      key: 'register',
	      value: function register(node, inertRoot) {
	        var inertNode = this._managedNodes.get(node);
	        if (inertNode !== undefined) {
	          // node was already in an inert subtree
	          inertNode.addInertRoot(inertRoot);
	        } else {
	          inertNode = new InertNode(node, inertRoot);
	        }
	        this._managedNodes.set(node, inertNode);
	        return inertNode;
	      }

	      /**
	       * De-register the given InertRoot as managing the given inert node.
	       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
	       * node from the InertManager's set of managed nodes if it is destroyed.
	       * If the node is not currently managed, this is essentially a no-op.
	       * @param {!Node} node
	       * @param {!InertRoot} inertRoot
	       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
	       */
	    }, {
	      key: 'deregister',
	      value: function deregister(node, inertRoot) {
	        var inertNode = this._managedNodes.get(node);
	        if (!inertNode) {
	          return null;
	        }
	        inertNode.removeInertRoot(inertRoot);
	        if (inertNode.destroyed) {
	          this._managedNodes['delete'](node);
	        }
	        return inertNode;
	      }

	      /**
	       * Callback used when document has finished loading.
	       */
	    }, {
	      key: '_onDocumentLoaded',
	      value: function _onDocumentLoaded() {
	        // Find all inert roots in document and make them actually inert.
	        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
	        inertElements.forEach(function (inertElement) {
	          this.setInert(inertElement, true);
	        }, this);

	        // Comment this out to use programmatic API only.
	        this._observer.observe(this._document.body || this._document.documentElement, {
	          attributes: true,
	          subtree: true,
	          childList: true
	        });
	      }

	      /**
	       * Callback used when mutation observer detects attribute changes.
	       * @param {!Array<!MutationRecord>} records
	       * @param {!MutationObserver} self
	       */
	    }, {
	      key: '_watchForInert',
	      value: function _watchForInert(records, self) {
	        var _this = this;
	        records.forEach(function (record) {
	          switch (record.type) {
	            case 'childList':
	              slice.call(record.addedNodes).forEach(function (node) {
	                if (node.nodeType !== Node.ELEMENT_NODE) {
	                  return;
	                }
	                var inertElements = slice.call(node.querySelectorAll('[inert]'));
	                if (matches.call(node, '[inert]')) {
	                  inertElements.unshift(node);
	                }
	                inertElements.forEach(function (inertElement) {
	                  this.setInert(inertElement, true);
	                }, _this);
	              }, _this);
	              break;
	            case 'attributes':
	              if (record.attributeName !== 'inert') {
	                return;
	              }
	              var target = /** @type {!HTMLElement} */record.target;
	              var inert = target.hasAttribute('inert');
	              _this.setInert(target, inert);
	              break;
	          }
	        }, this);
	      }
	    }]);
	    return InertManager;
	  }();

	  /**
	   * Recursively walk the composed tree from |node|.
	   * @param {!Node} node
	   * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
	   *     before descending into child nodes.
	   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
	   */

	  function composedTreeWalk(node, callback, shadowRootAncestor) {
	    if (node.nodeType == Node.ELEMENT_NODE) {
	      var element = /** @type {!HTMLElement} */node;
	      if (callback) {
	        callback(element);
	      }

	      // Descend into node:
	      // If it has a ShadowRoot, ignore all child elements - these will be picked
	      // up by the <content> or <shadow> elements. Descend straight into the
	      // ShadowRoot.
	      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
	      if (shadowRoot) {
	        composedTreeWalk(shadowRoot, callback);
	        return;
	      }

	      // If it is a <content> element, descend into distributed elements - these
	      // are elements from outside the shadow root which are rendered inside the
	      // shadow DOM.
	      if (element.localName == 'content') {
	        var content = /** @type {!HTMLContentElement} */element;
	        // Verifies if ShadowDom v0 is supported.
	        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
	        for (var i = 0; i < distributedNodes.length; i++) {
	          composedTreeWalk(distributedNodes[i], callback);
	        }
	        return;
	      }

	      // If it is a <slot> element, descend into assigned nodes - these
	      // are elements from outside the shadow root which are rendered inside the
	      // shadow DOM.
	      if (element.localName == 'slot') {
	        var slot = /** @type {!HTMLSlotElement} */element;
	        // Verify if ShadowDom v1 is supported.
	        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
	          flatten: true
	        }) : [];
	        for (var _i = 0; _i < _distributedNodes.length; _i++) {
	          composedTreeWalk(_distributedNodes[_i], callback);
	        }
	        return;
	      }
	    }

	    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
	    // element, nor a <shadow> element recurse normally.
	    var child = node.firstChild;
	    while (child != null) {
	      composedTreeWalk(child, callback);
	      child = child.nextSibling;
	    }
	  }

	  /**
	   * Adds a style element to the node containing the inert specific styles
	   * @param {!Node} node
	   */
	  function addInertStyle(node) {
	    if (node.querySelector('style#inert-style, link#inert-style')) {
	      return;
	    }
	    var style = document.createElement('style');
	    style.setAttribute('id', 'inert-style');
	    style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
	    node.appendChild(style);
	  }
	  if (!HTMLElement.prototype.hasOwnProperty('inert')) {
	    /** @type {!InertManager} */
	    var inertManager = new InertManager(document);
	    Object.defineProperty(HTMLElement.prototype, 'inert', {
	      enumerable: true,
	      /** @this {!HTMLElement} */
	      get: function get() {
	        return this.hasAttribute('inert');
	      },
	      /** @this {!HTMLElement} */
	      set: function set(inert) {
	        inertManager.setInert(this, inert);
	      }
	    });
	  }
	})();

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var cssClasses$3 = {
	  ANIMATE: 'mdc-drawer--animate',
	  CLOSING: 'mdc-drawer--closing',
	  DISMISSIBLE: 'mdc-drawer--dismissible',
	  MODAL: 'mdc-drawer--modal',
	  OPEN: 'mdc-drawer--open',
	  OPENING: 'mdc-drawer--opening',
	  ROOT: 'mdc-drawer'
	};
	var strings$3 = {
	  APP_CONTENT_SELECTOR: '.mdc-drawer-app-content',
	  CLOSE_EVENT: 'MDCDrawer:closed',
	  OPEN_EVENT: 'MDCDrawer:opened',
	  SCRIM_SELECTOR: '.mdc-drawer-scrim',
	  LIST_SELECTOR: '.mdc-list,.mdc-deprecated-list',
	  LIST_ITEM_ACTIVATED_SELECTOR: '.mdc-list-item--activated,.mdc-deprecated-list-item--activated'
	};

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation$3 = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCDismissibleDrawerFoundation = /** @class */function (_super) {
	  __extends(MDCDismissibleDrawerFoundation, _super);
	  function MDCDismissibleDrawerFoundation(adapter) {
	    var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation.defaultAdapter), adapter)) || this;
	    _this.animationFrame = 0;
	    _this.animationTimer = 0;
	    return _this;
	  }
	  Object.defineProperty(MDCDismissibleDrawerFoundation, "strings", {
	    get: function () {
	      return strings$3;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCDismissibleDrawerFoundation, "cssClasses", {
	    get: function () {
	      return cssClasses$3;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCDismissibleDrawerFoundation, "defaultAdapter", {
	    get: function () {
	      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
	      return {
	        addClass: function () {
	          return undefined;
	        },
	        removeClass: function () {
	          return undefined;
	        },
	        hasClass: function () {
	          return false;
	        },
	        elementHasClass: function () {
	          return false;
	        },
	        notifyClose: function () {
	          return undefined;
	        },
	        notifyOpen: function () {
	          return undefined;
	        },
	        saveFocus: function () {
	          return undefined;
	        },
	        restoreFocus: function () {
	          return undefined;
	        },
	        focusActiveNavigationItem: function () {
	          return undefined;
	        },
	        trapFocus: function () {
	          return undefined;
	        },
	        releaseFocus: function () {
	          return undefined;
	        }
	      };
	      // tslint:enable:object-literal-sort-keys
	    },

	    enumerable: false,
	    configurable: true
	  });
	  MDCDismissibleDrawerFoundation.prototype.destroy = function () {
	    if (this.animationFrame) {
	      cancelAnimationFrame(this.animationFrame);
	    }
	    if (this.animationTimer) {
	      clearTimeout(this.animationTimer);
	    }
	  };
	  /**
	   * Opens the drawer from the closed state.
	   */
	  MDCDismissibleDrawerFoundation.prototype.open = function () {
	    var _this = this;
	    if (this.isOpen() || this.isOpening() || this.isClosing()) {
	      return;
	    }
	    this.adapter.addClass(cssClasses$3.OPEN);
	    this.adapter.addClass(cssClasses$3.ANIMATE);
	    // Wait a frame once display is no longer "none", to establish basis for animation
	    this.runNextAnimationFrame(function () {
	      _this.adapter.addClass(cssClasses$3.OPENING);
	    });
	    this.adapter.saveFocus();
	  };
	  /**
	   * Closes the drawer from the open state.
	   */
	  MDCDismissibleDrawerFoundation.prototype.close = function () {
	    if (!this.isOpen() || this.isOpening() || this.isClosing()) {
	      return;
	    }
	    this.adapter.addClass(cssClasses$3.CLOSING);
	  };
	  /**
	   * Returns true if the drawer is in the open position.
	   * @return true if drawer is in open state.
	   */
	  MDCDismissibleDrawerFoundation.prototype.isOpen = function () {
	    return this.adapter.hasClass(cssClasses$3.OPEN);
	  };
	  /**
	   * Returns true if the drawer is animating open.
	   * @return true if drawer is animating open.
	   */
	  MDCDismissibleDrawerFoundation.prototype.isOpening = function () {
	    return this.adapter.hasClass(cssClasses$3.OPENING) || this.adapter.hasClass(cssClasses$3.ANIMATE);
	  };
	  /**
	   * Returns true if the drawer is animating closed.
	   * @return true if drawer is animating closed.
	   */
	  MDCDismissibleDrawerFoundation.prototype.isClosing = function () {
	    return this.adapter.hasClass(cssClasses$3.CLOSING);
	  };
	  /**
	   * Keydown handler to close drawer when key is escape.
	   */
	  MDCDismissibleDrawerFoundation.prototype.handleKeydown = function (evt) {
	    var keyCode = evt.keyCode,
	      key = evt.key;
	    var isEscape = key === 'Escape' || keyCode === 27;
	    if (isEscape) {
	      this.close();
	    }
	  };
	  /**
	   * Handles the `transitionend` event when the drawer finishes opening/closing.
	   */
	  MDCDismissibleDrawerFoundation.prototype.handleTransitionEnd = function (evt) {
	    var OPENING = cssClasses$3.OPENING,
	      CLOSING = cssClasses$3.CLOSING,
	      OPEN = cssClasses$3.OPEN,
	      ANIMATE = cssClasses$3.ANIMATE,
	      ROOT = cssClasses$3.ROOT;
	    // In Edge, transitionend on ripple pseudo-elements yields a target without classList, so check for Element first.
	    var isRootElement = this.isElement(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
	    if (!isRootElement) {
	      return;
	    }
	    if (this.isClosing()) {
	      this.adapter.removeClass(OPEN);
	      this.closed();
	      this.adapter.restoreFocus();
	      this.adapter.notifyClose();
	    } else {
	      this.adapter.focusActiveNavigationItem();
	      this.opened();
	      this.adapter.notifyOpen();
	    }
	    this.adapter.removeClass(ANIMATE);
	    this.adapter.removeClass(OPENING);
	    this.adapter.removeClass(CLOSING);
	  };
	  /**
	   * Extension point for when drawer finishes open animation.
	   */
	  MDCDismissibleDrawerFoundation.prototype.opened = function () {}; // tslint:disable-line:no-empty
	  /**
	   * Extension point for when drawer finishes close animation.
	   */
	  MDCDismissibleDrawerFoundation.prototype.closed = function () {}; // tslint:disable-line:no-empty
	  /**
	   * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
	   */
	  MDCDismissibleDrawerFoundation.prototype.runNextAnimationFrame = function (callback) {
	    var _this = this;
	    cancelAnimationFrame(this.animationFrame);
	    this.animationFrame = requestAnimationFrame(function () {
	      _this.animationFrame = 0;
	      clearTimeout(_this.animationTimer);
	      _this.animationTimer = setTimeout(callback, 0);
	    });
	  };
	  MDCDismissibleDrawerFoundation.prototype.isElement = function (element) {
	    // In Edge, transitionend on ripple pseudo-elements yields a target without classList.
	    return Boolean(element.classList);
	  };
	  return MDCDismissibleDrawerFoundation;
	}(MDCFoundation$3);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCDismissibleDrawerFoundation$1 = MDCDismissibleDrawerFoundation;

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	/* istanbul ignore next: subclass is not a branch statement */
	var MDCModalDrawerFoundation = /** @class */function (_super) {
	  __extends(MDCModalDrawerFoundation, _super);
	  function MDCModalDrawerFoundation() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	  /**
	   * Handles click event on scrim.
	   */
	  MDCModalDrawerFoundation.prototype.handleScrimClick = function () {
	    this.close();
	  };
	  /**
	   * Called when drawer finishes open animation.
	   */
	  MDCModalDrawerFoundation.prototype.opened = function () {
	    this.adapter.trapFocus();
	  };
	  /**
	   * Called when drawer finishes close animation.
	   */
	  MDCModalDrawerFoundation.prototype.closed = function () {
	    this.adapter.releaseFocus();
	  };
	  return MDCModalDrawerFoundation;
	}(MDCDismissibleDrawerFoundation);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCModalDrawerFoundation$1 = MDCModalDrawerFoundation;

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/**
	 * Specifies an observer callback that is run when the decorated property
	 * changes. The observer receives the current and old value as arguments.
	 */
	const observer = observer =>
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	(proto, propName) => {
	  // if we haven't wrapped `updated` in this class, do so
	  if (!proto.constructor._observers) {
	    proto.constructor._observers = new Map();
	    const userUpdated = proto.updated;
	    proto.updated = function (changedProperties) {
	      userUpdated.call(this, changedProperties);
	      changedProperties.forEach((v, k) => {
	        const observers = this.constructor._observers;
	        const observer = observers.get(k);
	        if (observer !== undefined) {
	          // eslint-disable-next-line @typescript-eslint/no-explicit-any
	          observer.call(this, this[k], v);
	        }
	      });
	    };
	    // clone any existing observers (superclasses)
	    // eslint-disable-next-line no-prototype-builtins
	  } else if (!proto.constructor.hasOwnProperty('_observers')) {
	    const observers = proto.constructor._observers;
	    proto.constructor._observers = new Map();
	    observers.forEach(
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    (v, k) => proto.constructor._observers.set(k, v));
	  }
	  // set this method
	  proto.constructor._observers.set(propName, observer);
	};

	var _templateObject$d, _templateObject2$6, _templateObject3$3;
	const blockingElements = document.$blockingElements;
	class DrawerBase extends BaseElement {
	  constructor() {
	    super(...arguments);
	    this._previousFocus = null;
	    this.open = false;
	    this.hasHeader = false;
	    this.type = '';
	  }
	  get mdcFoundationClass() {
	    return this.type === 'modal' ? MDCModalDrawerFoundation$1 : MDCDismissibleDrawerFoundation$1;
	  }
	  createAdapter() {
	    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {
	      elementHasClass: (element, className) => element.classList.contains(className),
	      saveFocus: () => {
	        // Note, casting to avoid cumbersome runtime check.
	        this._previousFocus = this.getRootNode().activeElement;
	      },
	      restoreFocus: () => {
	        const previousFocus = this._previousFocus && this._previousFocus.focus;
	        if (previousFocus) {
	          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	          this._previousFocus.focus();
	        }
	      },
	      notifyClose: () => {
	        this.open = false;
	        this.dispatchEvent(new Event(strings$3.CLOSE_EVENT, {
	          bubbles: true,
	          cancelable: true
	        }));
	      },
	      notifyOpen: () => {
	        this.open = true;
	        this.dispatchEvent(new Event(strings$3.OPEN_EVENT, {
	          bubbles: true,
	          cancelable: true
	        }));
	      },
	      focusActiveNavigationItem: () => {},
	      trapFocus: () => {
	        blockingElements.push(this);
	        this.appContent.inert = true;
	      },
	      releaseFocus: () => {
	        blockingElements.remove(this);
	        this.appContent.inert = false;
	      }
	    });
	  }
	  _handleScrimClick() {
	    if (this.mdcFoundation instanceof MDCModalDrawerFoundation$1) {
	      this.mdcFoundation.handleScrimClick();
	    }
	  }
	  render() {
	    const dismissible = this.type === 'dismissible' || this.type === 'modal';
	    const modal = this.type === 'modal';
	    const header = this.hasHeader ? x(_templateObject$d || (_templateObject$d = _taggedTemplateLiteral(["\n      <div class=\"mdc-drawer__header\">\n        <h3 class=\"mdc-drawer__title\"><slot name=\"title\"></slot></h3>\n        <h6 class=\"mdc-drawer__subtitle\"><slot name=\"subtitle\"></slot></h6>\n        <slot name=\"header\"></slot>\n      </div>\n      "]))) : '';
	    const classes = {
	      'mdc-drawer--dismissible': dismissible,
	      'mdc-drawer--modal': modal
	    };
	    return x(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteral(["\n      <aside class=\"mdc-drawer ", "\">\n        ", "\n        <div class=\"mdc-drawer__content\"><slot></slot></div>\n      </aside>\n      ", "\n      <div class=\"mdc-drawer-app-content\">\n        <slot name=\"appContent\"></slot>\n      </div>\n      "])), o$1(classes), header, modal ? x(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteral(["<div class=\"mdc-drawer-scrim\"\n                          @click=\"", "\"></div>"])), this._handleScrimClick) : '');
	  }
	  // note, we avoid calling `super.firstUpdated()` to control when
	  // `createFoundation()` is called.
	  firstUpdated() {
	    this.mdcRoot.addEventListener('keydown', e => this.mdcFoundation.handleKeydown(e));
	    this.mdcRoot.addEventListener('transitionend', e => this.mdcFoundation.handleTransitionEnd(e));
	  }
	  updated(changedProperties) {
	    if (changedProperties.has('type')) {
	      this.createFoundation();
	    }
	  }
	}
	__decorate([i$4('.mdc-drawer')], DrawerBase.prototype, "mdcRoot", void 0);
	__decorate([i$4('.mdc-drawer-app-content')], DrawerBase.prototype, "appContent", void 0);
	__decorate([observer(function (value) {
	  if (this.type === '') {
	    return;
	  }
	  if (value) {
	    this.mdcFoundation.open();
	  } else {
	    this.mdcFoundation.close();
	  }
	}), n$6({
	  type: Boolean,
	  reflect: true
	})], DrawerBase.prototype, "open", void 0);
	__decorate([n$6({
	  type: Boolean
	})], DrawerBase.prototype, "hasHeader", void 0);
	__decorate([n$6({
	  reflect: true
	})], DrawerBase.prototype, "type", void 0);

	var _templateObject$c;
	const styles$6 = i$3(_templateObject$c || (_templateObject$c = _taggedTemplateLiteral([".mdc-drawer{border-color:rgba(0, 0, 0, 0.12);background-color:#fff;background-color:var(--mdc-theme-surface, #fff);border-top-left-radius:0;border-top-right-radius:0;border-top-right-radius:var(--mdc-shape-large, 0);border-bottom-right-radius:0;border-bottom-right-radius:var(--mdc-shape-large, 0);border-bottom-left-radius:0;z-index:6;width:256px;display:flex;flex-direction:column;flex-shrink:0;box-sizing:border-box;height:100%;border-right-width:1px;border-right-style:solid;overflow:hidden;transition-property:transform;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.mdc-drawer .mdc-drawer__title{color:rgba(0, 0, 0, 0.87)}.mdc-drawer .mdc-deprecated-list-group__subheader{color:rgba(0, 0, 0, 0.6)}.mdc-drawer .mdc-drawer__subtitle{color:rgba(0, 0, 0, 0.6)}.mdc-drawer .mdc-deprecated-list-item__graphic{color:rgba(0, 0, 0, 0.6)}.mdc-drawer .mdc-deprecated-list-item{color:rgba(0, 0, 0, 0.87)}.mdc-drawer .mdc-deprecated-list-item--activated .mdc-deprecated-list-item__graphic{color:#6200ee}.mdc-drawer .mdc-deprecated-list-item--activated{color:rgba(98, 0, 238, 0.87)}[dir=rtl] .mdc-drawer,.mdc-drawer[dir=rtl]{border-top-left-radius:0;border-top-left-radius:var(--mdc-shape-large, 0);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:0;border-bottom-left-radius:var(--mdc-shape-large, 0)}.mdc-drawer .mdc-deprecated-list-item{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content{margin-left:256px;margin-right:0}[dir=rtl] .mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content,.mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content[dir=rtl]{margin-left:0;margin-right:256px}[dir=rtl] .mdc-drawer,.mdc-drawer[dir=rtl]{border-right-width:0;border-left-width:1px;border-right-style:none;border-left-style:solid}.mdc-drawer .mdc-deprecated-list-item{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-subtitle2-font-size, 0.875rem);line-height:1.375rem;line-height:var(--mdc-typography-subtitle2-line-height, 1.375rem);font-weight:500;font-weight:var(--mdc-typography-subtitle2-font-weight, 500);letter-spacing:0.0071428571em;letter-spacing:var(--mdc-typography-subtitle2-letter-spacing, 0.0071428571em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle2-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle2-text-transform, inherit);height:calc(48px - 2 * 4px);margin:8px 8px;padding:0 8px}.mdc-drawer .mdc-deprecated-list-item:nth-child(1){margin-top:2px}.mdc-drawer .mdc-deprecated-list-item:nth-last-child(1){margin-bottom:0}.mdc-drawer .mdc-deprecated-list-group__subheader{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-body2-font-size, 0.875rem);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight, 400);letter-spacing:0.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing, 0.0178571429em);text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform, inherit);display:block;margin-top:0;line-height:normal;margin:0;padding:0 16px}.mdc-drawer .mdc-deprecated-list-group__subheader::before{display:inline-block;width:0;height:24px;content:\"\";vertical-align:0}.mdc-drawer .mdc-deprecated-list-divider{margin:3px 0 4px}.mdc-drawer .mdc-deprecated-list-item__text,.mdc-drawer .mdc-deprecated-list-item__graphic{pointer-events:none}.mdc-drawer--animate{transform:translateX(-100%)}[dir=rtl] .mdc-drawer--animate,.mdc-drawer--animate[dir=rtl]{transform:translateX(100%)}.mdc-drawer--opening{transform:translateX(0);transition-duration:250ms}[dir=rtl] .mdc-drawer--opening,.mdc-drawer--opening[dir=rtl]{transform:translateX(0)}.mdc-drawer--closing{transform:translateX(-100%);transition-duration:200ms}[dir=rtl] .mdc-drawer--closing,.mdc-drawer--closing[dir=rtl]{transform:translateX(100%)}.mdc-drawer__header{flex-shrink:0;box-sizing:border-box;min-height:64px;padding:0 16px 4px}.mdc-drawer__title{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-headline6-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1.25rem;font-size:var(--mdc-typography-headline6-font-size, 1.25rem);line-height:2rem;line-height:var(--mdc-typography-headline6-line-height, 2rem);font-weight:500;font-weight:var(--mdc-typography-headline6-font-weight, 500);letter-spacing:0.0125em;letter-spacing:var(--mdc-typography-headline6-letter-spacing, 0.0125em);text-decoration:inherit;text-decoration:var(--mdc-typography-headline6-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-headline6-text-transform, inherit);display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-drawer__title::before{display:inline-block;width:0;height:36px;content:\"\";vertical-align:0}.mdc-drawer__title::after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}.mdc-drawer__subtitle{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-body2-font-size, 0.875rem);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight, 400);letter-spacing:0.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing, 0.0178571429em);text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform, inherit);display:block;margin-top:0;line-height:normal;margin-bottom:0}.mdc-drawer__subtitle::before{display:inline-block;width:0;height:20px;content:\"\";vertical-align:0}.mdc-drawer__content{height:100%;overflow-y:auto;-webkit-overflow-scrolling:touch}.mdc-drawer--dismissible{left:0;right:initial;display:none;position:absolute}[dir=rtl] .mdc-drawer--dismissible,.mdc-drawer--dismissible[dir=rtl]{left:initial;right:0}.mdc-drawer--dismissible.mdc-drawer--open{display:flex}.mdc-drawer-app-content{margin-left:0;margin-right:0;position:relative}[dir=rtl] .mdc-drawer-app-content,.mdc-drawer-app-content[dir=rtl]{margin-left:0;margin-right:0}.mdc-drawer--modal{box-shadow:0px 8px 10px -5px rgba(0, 0, 0, 0.2),0px 16px 24px 2px rgba(0, 0, 0, 0.14),0px 6px 30px 5px rgba(0,0,0,.12);left:0;right:initial;display:none;position:fixed}.mdc-drawer--modal+.mdc-drawer-scrim{background-color:rgba(0, 0, 0, 0.32)}[dir=rtl] .mdc-drawer--modal,.mdc-drawer--modal[dir=rtl]{left:initial;right:0}.mdc-drawer--modal.mdc-drawer--open{display:flex}.mdc-drawer-scrim{display:none;position:fixed;top:0;left:0;width:100%;height:100%;z-index:5;transition-property:opacity;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.mdc-drawer--open+.mdc-drawer-scrim{display:block}.mdc-drawer--animate+.mdc-drawer-scrim{opacity:0}.mdc-drawer--opening+.mdc-drawer-scrim{transition-duration:250ms;opacity:1}.mdc-drawer--closing+.mdc-drawer-scrim{transition-duration:200ms;opacity:0}.mdc-drawer-app-content{overflow:auto;flex:1}:host{display:flex;height:100%}.mdc-drawer{width:256px;width:var(--mdc-drawer-width, 256px)}.mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content{margin-left:256px;margin-left:var(--mdc-drawer-width, 256px);margin-right:0}[dir=rtl] .mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content,.mdc-drawer.mdc-drawer--open:not(.mdc-drawer--closing)+.mdc-drawer-app-content[dir=rtl]{margin-left:0;margin-right:256px;margin-right:var(--mdc-drawer-width, 256px)}"])));

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let Drawer = class Drawer extends DrawerBase {};
	Drawer.styles = [styles$6];
	Drawer = __decorate([e$8('mwc-drawer')], Drawer);

	var _templateObject$b, _templateObject2$5, _templateObject3$2, _templateObject4$2, _templateObject5$1, _templateObject6$1, _templateObject7$1, _templateObject8$1, _templateObject9, _templateObject10;
	/**
	 * @fires request-selected {RequestSelectedDetail}
	 * @fires list-item-rendered
	 */
	class ListItemBase extends s {
	  constructor() {
	    super(...arguments);
	    this.value = '';
	    this.group = null;
	    this.tabindex = -1;
	    this.disabled = false;
	    this.twoline = false;
	    this.activated = false;
	    this.graphic = null;
	    this.multipleGraphics = false;
	    this.hasMeta = false;
	    this.noninteractive = false;
	    this.selected = false;
	    this.shouldRenderRipple = false;
	    this._managingList = null;
	    this.boundOnClick = this.onClick.bind(this);
	    this._firstChanged = true;
	    this._skipPropRequest = false;
	    this.rippleHandlers = new RippleHandlers(() => {
	      this.shouldRenderRipple = true;
	      return this.ripple;
	    });
	    this.listeners = [{
	      target: this,
	      eventNames: ['click'],
	      cb: () => {
	        this.onClick();
	      }
	    }, {
	      target: this,
	      eventNames: ['mouseenter'],
	      cb: this.rippleHandlers.startHover
	    }, {
	      target: this,
	      eventNames: ['mouseleave'],
	      cb: this.rippleHandlers.endHover
	    }, {
	      target: this,
	      eventNames: ['focus'],
	      cb: this.rippleHandlers.startFocus
	    }, {
	      target: this,
	      eventNames: ['blur'],
	      cb: this.rippleHandlers.endFocus
	    }, {
	      target: this,
	      eventNames: ['mousedown', 'touchstart'],
	      cb: e => {
	        const name = e.type;
	        this.onDown(name === 'mousedown' ? 'mouseup' : 'touchend', e);
	      }
	    }];
	  }
	  get text() {
	    const textContent = this.textContent;
	    return textContent ? textContent.trim() : '';
	  }
	  render() {
	    const text = this.renderText();
	    const graphic = this.graphic ? this.renderGraphic() : x(_templateObject$b || (_templateObject$b = _taggedTemplateLiteral([""])));
	    const meta = this.hasMeta ? this.renderMeta() : x(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteral([""])));
	    return x(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteral(["\n      ", "\n      ", "\n      ", "\n      ", ""])), this.renderRipple(), graphic, text, meta);
	  }
	  renderRipple() {
	    if (this.shouldRenderRipple) {
	      return x(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteral(["\n      <mwc-ripple\n        .activated=", ">\n      </mwc-ripple>"])), this.activated);
	    } else if (this.activated) {
	      return x(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteral(["<div class=\"fake-activated-ripple\"></div>"])));
	    } else {
	      return '';
	    }
	  }
	  renderGraphic() {
	    const graphicClasses = {
	      multi: this.multipleGraphics
	    };
	    return x(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteral(["\n      <span class=\"mdc-deprecated-list-item__graphic material-icons ", "\">\n        <slot name=\"graphic\"></slot>\n      </span>"])), o$1(graphicClasses));
	  }
	  renderMeta() {
	    return x(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteral(["\n      <span class=\"mdc-deprecated-list-item__meta material-icons\">\n        <slot name=\"meta\"></slot>\n      </span>"])));
	  }
	  renderText() {
	    const inner = this.twoline ? this.renderTwoline() : this.renderSingleLine();
	    return x(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteral(["\n      <span class=\"mdc-deprecated-list-item__text\">\n        ", "\n      </span>"])), inner);
	  }
	  renderSingleLine() {
	    return x(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral(["<slot></slot>"])));
	  }
	  renderTwoline() {
	    return x(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral(["\n      <span class=\"mdc-deprecated-list-item__primary-text\">\n        <slot></slot>\n      </span>\n      <span class=\"mdc-deprecated-list-item__secondary-text\">\n        <slot name=\"secondary\"></slot>\n      </span>\n    "])));
	  }
	  onClick() {
	    this.fireRequestSelected(!this.selected, 'interaction');
	  }
	  onDown(upName, evt) {
	    const onUp = () => {
	      window.removeEventListener(upName, onUp);
	      this.rippleHandlers.endPress();
	    };
	    window.addEventListener(upName, onUp);
	    this.rippleHandlers.startPress(evt);
	  }
	  fireRequestSelected(selected, source) {
	    if (this.noninteractive) {
	      return;
	    }
	    const customEv = new CustomEvent('request-selected', {
	      bubbles: true,
	      composed: true,
	      detail: {
	        source,
	        selected
	      }
	    });
	    this.dispatchEvent(customEv);
	  }
	  connectedCallback() {
	    super.connectedCallback();
	    if (!this.noninteractive) {
	      this.setAttribute('mwc-list-item', '');
	    }
	    for (const listener of this.listeners) {
	      for (const eventName of listener.eventNames) {
	        listener.target.addEventListener(eventName, listener.cb, {
	          passive: true
	        });
	      }
	    }
	  }
	  disconnectedCallback() {
	    super.disconnectedCallback();
	    for (const listener of this.listeners) {
	      for (const eventName of listener.eventNames) {
	        listener.target.removeEventListener(eventName, listener.cb);
	      }
	    }
	    if (this._managingList) {
	      this._managingList.debouncedLayout ? this._managingList.debouncedLayout(true) : this._managingList.layout(true);
	    }
	  }
	  // composed flag, event fire through shadow root and up through composed tree
	  firstUpdated() {
	    const ev = new Event('list-item-rendered', {
	      bubbles: true,
	      composed: true
	    });
	    this.dispatchEvent(ev);
	  }
	}
	__decorate([i$4('slot')], ListItemBase.prototype, "slotElement", void 0);
	__decorate([e$5('mwc-ripple')], ListItemBase.prototype, "ripple", void 0);
	__decorate([n$6({
	  type: String
	})], ListItemBase.prototype, "value", void 0);
	__decorate([n$6({
	  type: String,
	  reflect: true
	})], ListItemBase.prototype, "group", void 0);
	__decorate([n$6({
	  type: Number,
	  reflect: true
	})], ListItemBase.prototype, "tabindex", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	}), observer(function (value) {
	  if (value) {
	    this.setAttribute('aria-disabled', 'true');
	  } else {
	    this.setAttribute('aria-disabled', 'false');
	  }
	})], ListItemBase.prototype, "disabled", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ListItemBase.prototype, "twoline", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ListItemBase.prototype, "activated", void 0);
	__decorate([n$6({
	  type: String,
	  reflect: true
	})], ListItemBase.prototype, "graphic", void 0);
	__decorate([n$6({
	  type: Boolean
	})], ListItemBase.prototype, "multipleGraphics", void 0);
	__decorate([n$6({
	  type: Boolean
	})], ListItemBase.prototype, "hasMeta", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	}), observer(function (value) {
	  if (value) {
	    this.removeAttribute('aria-checked');
	    this.removeAttribute('mwc-list-item');
	    this.selected = false;
	    this.activated = false;
	    this.tabIndex = -1;
	  } else {
	    this.setAttribute('mwc-list-item', '');
	  }
	})], ListItemBase.prototype, "noninteractive", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	}), observer(function (value) {
	  const role = this.getAttribute('role');
	  const isAriaSelectable = role === 'gridcell' || role === 'option' || role === 'row' || role === 'tab';
	  if (isAriaSelectable && value) {
	    this.setAttribute('aria-selected', 'true');
	  } else if (isAriaSelectable) {
	    this.setAttribute('aria-selected', 'false');
	  }
	  if (this._firstChanged) {
	    this._firstChanged = false;
	    return;
	  }
	  if (this._skipPropRequest) {
	    return;
	  }
	  this.fireRequestSelected(value, 'property');
	})], ListItemBase.prototype, "selected", void 0);
	__decorate([t$3()], ListItemBase.prototype, "shouldRenderRipple", void 0);
	__decorate([t$3()], ListItemBase.prototype, "_managingList", void 0);

	var _templateObject$a;
	const styles$5 = i$3(_templateObject$a || (_templateObject$a = _taggedTemplateLiteral([":host{cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;height:48px;display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:var(--mdc-list-side-padding, 16px);padding-right:var(--mdc-list-side-padding, 16px);outline:none;height:48px;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87))}:host:focus{outline:none}:host([activated]){color:#6200ee;color:var(--mdc-theme-primary, #6200ee);--mdc-ripple-color: var( --mdc-theme-primary, #6200ee )}:host([activated]) .mdc-deprecated-list-item__graphic{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host([activated]) .fake-activated-ripple::before{position:absolute;display:block;top:0;bottom:0;left:0;right:0;width:100%;height:100%;pointer-events:none;z-index:1;content:\"\";opacity:0.12;opacity:var(--mdc-ripple-activated-opacity, 0.12);background-color:#6200ee;background-color:var(--mdc-ripple-color, var(--mdc-theme-primary, #6200ee))}.mdc-deprecated-list-item__graphic{flex-shrink:0;align-items:center;justify-content:center;fill:currentColor;display:inline-flex}.mdc-deprecated-list-item__graphic ::slotted(*){flex-shrink:0;align-items:center;justify-content:center;fill:currentColor;width:100%;height:100%;text-align:center}.mdc-deprecated-list-item__meta{width:var(--mdc-list-item-meta-size, 24px);height:var(--mdc-list-item-meta-size, 24px);margin-left:auto;margin-right:0;color:rgba(0, 0, 0, 0.38);color:var(--mdc-theme-text-hint-on-background, rgba(0, 0, 0, 0.38))}.mdc-deprecated-list-item__meta.multi{width:auto}.mdc-deprecated-list-item__meta ::slotted(*){width:var(--mdc-list-item-meta-size, 24px);line-height:var(--mdc-list-item-meta-size, 24px)}.mdc-deprecated-list-item__meta ::slotted(.material-icons),.mdc-deprecated-list-item__meta ::slotted(mwc-icon){line-height:var(--mdc-list-item-meta-size, 24px) !important}.mdc-deprecated-list-item__meta ::slotted(:not(.material-icons):not(mwc-icon)){-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-caption-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.75rem;font-size:var(--mdc-typography-caption-font-size, 0.75rem);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight, 400);letter-spacing:0.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing, 0.0333333333em);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform, inherit)}[dir=rtl] .mdc-deprecated-list-item__meta,.mdc-deprecated-list-item__meta[dir=rtl]{margin-left:0;margin-right:auto}.mdc-deprecated-list-item__meta ::slotted(*){width:100%;height:100%}.mdc-deprecated-list-item__text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.mdc-deprecated-list-item__text ::slotted([for]),.mdc-deprecated-list-item__text[for]{pointer-events:none}.mdc-deprecated-list-item__primary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;line-height:normal;margin-bottom:-20px;display:block}.mdc-deprecated-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:\"\";vertical-align:0}.mdc-deprecated-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}.mdc-deprecated-list-item__secondary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-body2-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-body2-font-size, 0.875rem);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight, 400);letter-spacing:0.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing, 0.0178571429em);text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform, inherit);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;line-height:normal;display:block}.mdc-deprecated-list-item__secondary-text::before{display:inline-block;width:0;height:20px;content:\"\";vertical-align:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__secondary-text{font-size:inherit}* ::slotted(a),a{color:inherit;text-decoration:none}:host([twoline]){height:72px}:host([twoline]) .mdc-deprecated-list-item__text{align-self:flex-start}:host([disabled]),:host([noninteractive]){cursor:default;pointer-events:none}:host([disabled]) .mdc-deprecated-list-item__text ::slotted(*){opacity:.38}:host([disabled]) .mdc-deprecated-list-item__text ::slotted(*),:host([disabled]) .mdc-deprecated-list-item__primary-text ::slotted(*),:host([disabled]) .mdc-deprecated-list-item__secondary-text ::slotted(*){color:#000;color:var(--mdc-theme-on-surface, #000)}.mdc-deprecated-list-item__secondary-text ::slotted(*){color:rgba(0, 0, 0, 0.54);color:var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54))}.mdc-deprecated-list-item__graphic ::slotted(*){background-color:transparent;color:rgba(0, 0, 0, 0.38);color:var(--mdc-theme-text-icon-on-background, rgba(0, 0, 0, 0.38))}.mdc-deprecated-list-group__subheader ::slotted(*){color:rgba(0, 0, 0, 0.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87))}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic{width:var(--mdc-list-item-graphic-size, 40px);height:var(--mdc-list-item-graphic-size, 40px)}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic.multi{width:auto}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic ::slotted(*){width:var(--mdc-list-item-graphic-size, 40px);line-height:var(--mdc-list-item-graphic-size, 40px)}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic ::slotted(.material-icons),:host([graphic=avatar]) .mdc-deprecated-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 40px) !important}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic ::slotted(*){border-radius:50%}:host([graphic=avatar]) .mdc-deprecated-list-item__graphic,:host([graphic=medium]) .mdc-deprecated-list-item__graphic,:host([graphic=large]) .mdc-deprecated-list-item__graphic,:host([graphic=control]) .mdc-deprecated-list-item__graphic{margin-left:0;margin-right:var(--mdc-list-item-graphic-margin, 16px)}[dir=rtl] :host([graphic=avatar]) .mdc-deprecated-list-item__graphic,[dir=rtl] :host([graphic=medium]) .mdc-deprecated-list-item__graphic,[dir=rtl] :host([graphic=large]) .mdc-deprecated-list-item__graphic,[dir=rtl] :host([graphic=control]) .mdc-deprecated-list-item__graphic,:host([graphic=avatar]) .mdc-deprecated-list-item__graphic[dir=rtl],:host([graphic=medium]) .mdc-deprecated-list-item__graphic[dir=rtl],:host([graphic=large]) .mdc-deprecated-list-item__graphic[dir=rtl],:host([graphic=control]) .mdc-deprecated-list-item__graphic[dir=rtl]{margin-left:var(--mdc-list-item-graphic-margin, 16px);margin-right:0}:host([graphic=icon]) .mdc-deprecated-list-item__graphic{width:var(--mdc-list-item-graphic-size, 24px);height:var(--mdc-list-item-graphic-size, 24px);margin-left:0;margin-right:var(--mdc-list-item-graphic-margin, 32px)}:host([graphic=icon]) .mdc-deprecated-list-item__graphic.multi{width:auto}:host([graphic=icon]) .mdc-deprecated-list-item__graphic ::slotted(*){width:var(--mdc-list-item-graphic-size, 24px);line-height:var(--mdc-list-item-graphic-size, 24px)}:host([graphic=icon]) .mdc-deprecated-list-item__graphic ::slotted(.material-icons),:host([graphic=icon]) .mdc-deprecated-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 24px) !important}[dir=rtl] :host([graphic=icon]) .mdc-deprecated-list-item__graphic,:host([graphic=icon]) .mdc-deprecated-list-item__graphic[dir=rtl]{margin-left:var(--mdc-list-item-graphic-margin, 32px);margin-right:0}:host([graphic=avatar]:not([twoLine])),:host([graphic=icon]:not([twoLine])){height:56px}:host([graphic=medium]:not([twoLine])),:host([graphic=large]:not([twoLine])){height:72px}:host([graphic=medium]) .mdc-deprecated-list-item__graphic,:host([graphic=large]) .mdc-deprecated-list-item__graphic{width:var(--mdc-list-item-graphic-size, 56px);height:var(--mdc-list-item-graphic-size, 56px)}:host([graphic=medium]) .mdc-deprecated-list-item__graphic.multi,:host([graphic=large]) .mdc-deprecated-list-item__graphic.multi{width:auto}:host([graphic=medium]) .mdc-deprecated-list-item__graphic ::slotted(*),:host([graphic=large]) .mdc-deprecated-list-item__graphic ::slotted(*){width:var(--mdc-list-item-graphic-size, 56px);line-height:var(--mdc-list-item-graphic-size, 56px)}:host([graphic=medium]) .mdc-deprecated-list-item__graphic ::slotted(.material-icons),:host([graphic=medium]) .mdc-deprecated-list-item__graphic ::slotted(mwc-icon),:host([graphic=large]) .mdc-deprecated-list-item__graphic ::slotted(.material-icons),:host([graphic=large]) .mdc-deprecated-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 56px) !important}:host([graphic=large]){padding-left:0px}"])));

	/**
	 * @license
	 * Copyright 2020 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let ListItem = class ListItem extends ListItemBase {};
	ListItem.styles = [styles$5];
	ListItem = __decorate([e$8('mwc-list-item')], ListItem);

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation$2 = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2020 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	/**
	 * KEY provides normalized string values for keys.
	 */
	var KEY = {
	  UNKNOWN: 'Unknown',
	  BACKSPACE: 'Backspace',
	  ENTER: 'Enter',
	  SPACEBAR: 'Spacebar',
	  PAGE_UP: 'PageUp',
	  PAGE_DOWN: 'PageDown',
	  END: 'End',
	  HOME: 'Home',
	  ARROW_LEFT: 'ArrowLeft',
	  ARROW_UP: 'ArrowUp',
	  ARROW_RIGHT: 'ArrowRight',
	  ARROW_DOWN: 'ArrowDown',
	  DELETE: 'Delete',
	  ESCAPE: 'Escape',
	  TAB: 'Tab'
	};
	var normalizedKeys = new Set();
	// IE11 has no support for new Map with iterable so we need to initialize this
	// by hand.
	normalizedKeys.add(KEY.BACKSPACE);
	normalizedKeys.add(KEY.ENTER);
	normalizedKeys.add(KEY.SPACEBAR);
	normalizedKeys.add(KEY.PAGE_UP);
	normalizedKeys.add(KEY.PAGE_DOWN);
	normalizedKeys.add(KEY.END);
	normalizedKeys.add(KEY.HOME);
	normalizedKeys.add(KEY.ARROW_LEFT);
	normalizedKeys.add(KEY.ARROW_UP);
	normalizedKeys.add(KEY.ARROW_RIGHT);
	normalizedKeys.add(KEY.ARROW_DOWN);
	normalizedKeys.add(KEY.DELETE);
	normalizedKeys.add(KEY.ESCAPE);
	normalizedKeys.add(KEY.TAB);
	var KEY_CODE = {
	  BACKSPACE: 8,
	  ENTER: 13,
	  SPACEBAR: 32,
	  PAGE_UP: 33,
	  PAGE_DOWN: 34,
	  END: 35,
	  HOME: 36,
	  ARROW_LEFT: 37,
	  ARROW_UP: 38,
	  ARROW_RIGHT: 39,
	  ARROW_DOWN: 40,
	  DELETE: 46,
	  ESCAPE: 27,
	  TAB: 9
	};
	var mappedKeyCodes = new Map();
	// IE11 has no support for new Map with iterable so we need to initialize this
	// by hand.
	mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
	mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
	mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
	mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
	mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
	mappedKeyCodes.set(KEY_CODE.END, KEY.END);
	mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
	mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
	mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
	mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
	mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
	mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
	mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
	mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
	var navigationKeys = new Set();
	// IE11 has no support for new Set with iterable so we need to initialize this
	// by hand.
	navigationKeys.add(KEY.PAGE_UP);
	navigationKeys.add(KEY.PAGE_DOWN);
	navigationKeys.add(KEY.END);
	navigationKeys.add(KEY.HOME);
	navigationKeys.add(KEY.ARROW_LEFT);
	navigationKeys.add(KEY.ARROW_UP);
	navigationKeys.add(KEY.ARROW_RIGHT);
	navigationKeys.add(KEY.ARROW_DOWN);
	/**
	 * normalizeKey returns the normalized string for a navigational action.
	 */
	function normalizeKey(evt) {
	  var key = evt.key;
	  // If the event already has a normalized key, return it
	  if (normalizedKeys.has(key)) {
	    return key;
	  }
	  // tslint:disable-next-line:deprecation
	  var mappedKey = mappedKeyCodes.get(evt.keyCode);
	  if (mappedKey) {
	    return mappedKey;
	  }
	  return KEY.UNKNOWN;
	}

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var _a, _b;
	var cssClasses$2 = {
	  LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
	  LIST_ITEM_CLASS: 'mdc-list-item',
	  LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
	  LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
	  LIST_ITEM_TEXT_CLASS: 'mdc-list-item__text',
	  LIST_ITEM_PRIMARY_TEXT_CLASS: 'mdc-list-item__primary-text',
	  ROOT: 'mdc-list'
	};
	(_a = {}, _a["" + cssClasses$2.LIST_ITEM_ACTIVATED_CLASS] = 'mdc-list-item--activated', _a["" + cssClasses$2.LIST_ITEM_CLASS] = 'mdc-list-item', _a["" + cssClasses$2.LIST_ITEM_DISABLED_CLASS] = 'mdc-list-item--disabled', _a["" + cssClasses$2.LIST_ITEM_SELECTED_CLASS] = 'mdc-list-item--selected', _a["" + cssClasses$2.LIST_ITEM_PRIMARY_TEXT_CLASS] = 'mdc-list-item__primary-text', _a["" + cssClasses$2.ROOT] = 'mdc-list', _a);
	var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses$2.LIST_ITEM_ACTIVATED_CLASS] = 'mdc-deprecated-list-item--activated', _b["" + cssClasses$2.LIST_ITEM_CLASS] = 'mdc-deprecated-list-item', _b["" + cssClasses$2.LIST_ITEM_DISABLED_CLASS] = 'mdc-deprecated-list-item--disabled', _b["" + cssClasses$2.LIST_ITEM_SELECTED_CLASS] = 'mdc-deprecated-list-item--selected', _b["" + cssClasses$2.LIST_ITEM_TEXT_CLASS] = 'mdc-deprecated-list-item__text', _b["" + cssClasses$2.LIST_ITEM_PRIMARY_TEXT_CLASS] = 'mdc-deprecated-list-item__primary-text', _b["" + cssClasses$2.ROOT] = 'mdc-deprecated-list', _b);
	var strings$2 = {
	  ACTION_EVENT: 'MDCList:action',
	  SELECTION_CHANGE_EVENT: 'MDCList:selectionChange',
	  ARIA_CHECKED: 'aria-checked',
	  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
	  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
	  ARIA_CURRENT: 'aria-current',
	  ARIA_DISABLED: 'aria-disabled',
	  ARIA_ORIENTATION: 'aria-orientation',
	  ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
	  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
	  ARIA_SELECTED: 'aria-selected',
	  ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
	  ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
	  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
	  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
	  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$2.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$2.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " a\n  ",
	  DEPRECATED_SELECTOR: '.mdc-deprecated-list',
	  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$2.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$2.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$2.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses$2.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " input[type=\"radio\"]:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$2.LIST_ITEM_CLASS] + " input[type=\"checkbox\"]:not(:disabled)\n  ",
	  RADIO_SELECTOR: 'input[type="radio"]',
	  SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
	};
	var numbers$2 = {
	  UNSET_INDEX: -1,
	  TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
	};

	const integerSort = (a, b) => {
	  return a - b;
	};
	const findIndexDiff = (oldSet, newSet) => {
	  const oldArr = Array.from(oldSet);
	  const newArr = Array.from(newSet);
	  const diff = {
	    added: [],
	    removed: []
	  };
	  const oldSorted = oldArr.sort(integerSort);
	  const newSorted = newArr.sort(integerSort);
	  let i = 0;
	  let j = 0;
	  while (i < oldSorted.length || j < newSorted.length) {
	    const oldVal = oldSorted[i];
	    const newVal = newSorted[j];
	    if (oldVal === newVal) {
	      i++;
	      j++;
	      continue;
	    }
	    if (oldVal !== undefined && (newVal === undefined || oldVal < newVal)) {
	      diff.removed.push(oldVal);
	      i++;
	      continue;
	    }
	    if (newVal !== undefined && (oldVal === undefined || newVal < oldVal)) {
	      diff.added.push(newVal);
	      j++;
	      continue;
	    }
	  }
	  return diff;
	};
	const ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
	function isIndexSet(selectedIndex) {
	  return selectedIndex instanceof Set;
	}
	const createSetFromIndex = index => {
	  const entry = index === numbers$2.UNSET_INDEX ? new Set() : index;
	  return isIndexSet(entry) ? new Set(entry) : new Set([entry]);
	};
	class MDCListFoundation extends MDCFoundation$2 {
	  constructor(adapter) {
	    super(Object.assign(Object.assign({}, MDCListFoundation.defaultAdapter), adapter));
	    this.isMulti_ = false;
	    this.wrapFocus_ = false;
	    this.isVertical_ = true;
	    this.selectedIndex_ = numbers$2.UNSET_INDEX;
	    this.focusedItemIndex_ = numbers$2.UNSET_INDEX;
	    this.useActivatedClass_ = false;
	    this.ariaCurrentAttrValue_ = null;
	  }
	  static get strings() {
	    return strings$2;
	  }
	  static get numbers() {
	    return numbers$2;
	  }
	  static get defaultAdapter() {
	    return {
	      focusItemAtIndex: () => undefined,
	      getFocusedElementIndex: () => 0,
	      getListItemCount: () => 0,
	      isFocusInsideList: () => false,
	      isRootFocused: () => false,
	      notifyAction: () => undefined,
	      notifySelected: () => undefined,
	      getSelectedStateForElementIndex: () => false,
	      setDisabledStateForElementIndex: () => undefined,
	      getDisabledStateForElementIndex: () => false,
	      setSelectedStateForElementIndex: () => undefined,
	      setActivatedStateForElementIndex: () => undefined,
	      setTabIndexForElementIndex: () => undefined,
	      setAttributeForElementIndex: () => undefined,
	      getAttributeForElementIndex: () => null
	    };
	  }
	  /**
	   * Sets the private wrapFocus_ variable.
	   */
	  setWrapFocus(value) {
	    this.wrapFocus_ = value;
	  }
	  /**
	   * Sets the private wrapFocus_ variable.
	   */
	  setMulti(value) {
	    this.isMulti_ = value;
	    const currentIndex = this.selectedIndex_;
	    if (value) {
	      // number to set
	      if (!isIndexSet(currentIndex)) {
	        const isUnset = currentIndex === numbers$2.UNSET_INDEX;
	        this.selectedIndex_ = isUnset ? new Set() : new Set([currentIndex]);
	      }
	    } else {
	      // set to first sorted number in set
	      if (isIndexSet(currentIndex)) {
	        if (currentIndex.size) {
	          const vals = Array.from(currentIndex).sort(integerSort);
	          this.selectedIndex_ = vals[0];
	        } else {
	          this.selectedIndex_ = numbers$2.UNSET_INDEX;
	        }
	      }
	    }
	  }
	  /**
	   * Sets the isVertical_ private variable.
	   */
	  setVerticalOrientation(value) {
	    this.isVertical_ = value;
	  }
	  /**
	   * Sets the useActivatedClass_ private variable.
	   */
	  setUseActivatedClass(useActivated) {
	    this.useActivatedClass_ = useActivated;
	  }
	  getSelectedIndex() {
	    return this.selectedIndex_;
	  }
	  setSelectedIndex(index) {
	    if (!this.isIndexValid_(index)) {
	      return;
	    }
	    if (this.isMulti_) {
	      this.setMultiSelectionAtIndex_(createSetFromIndex(index));
	    } else {
	      this.setSingleSelectionAtIndex_(index);
	    }
	  }
	  /**
	   * Focus in handler for the list items.
	   */
	  handleFocusIn(_, listItemIndex) {
	    if (listItemIndex >= 0) {
	      this.adapter.setTabIndexForElementIndex(listItemIndex, 0);
	    }
	  }
	  /**
	   * Focus out handler for the list items.
	   */
	  handleFocusOut(_, listItemIndex) {
	    if (listItemIndex >= 0) {
	      this.adapter.setTabIndexForElementIndex(listItemIndex, -1);
	    }
	    /**
	     * Between Focusout & Focusin some browsers do not have focus on any
	     * element. Setting a delay to wait till the focus is moved to next element.
	     */
	    setTimeout(() => {
	      if (!this.adapter.isFocusInsideList()) {
	        this.setTabindexToFirstSelectedItem_();
	      }
	    }, 0);
	  }
	  /**
	   * Key handler for the list.
	   */
	  handleKeydown(event, isRootListItem, listItemIndex) {
	    const isArrowLeft = normalizeKey(event) === 'ArrowLeft';
	    const isArrowUp = normalizeKey(event) === 'ArrowUp';
	    const isArrowRight = normalizeKey(event) === 'ArrowRight';
	    const isArrowDown = normalizeKey(event) === 'ArrowDown';
	    const isHome = normalizeKey(event) === 'Home';
	    const isEnd = normalizeKey(event) === 'End';
	    const isEnter = normalizeKey(event) === 'Enter';
	    const isSpace = normalizeKey(event) === 'Spacebar';
	    if (this.adapter.isRootFocused()) {
	      if (isArrowUp || isEnd) {
	        event.preventDefault();
	        this.focusLastElement();
	      } else if (isArrowDown || isHome) {
	        event.preventDefault();
	        this.focusFirstElement();
	      }
	      return;
	    }
	    let currentIndex = this.adapter.getFocusedElementIndex();
	    if (currentIndex === -1) {
	      currentIndex = listItemIndex;
	      if (currentIndex < 0) {
	        // If this event doesn't have a mdc-deprecated-list-item ancestor from
	        // the current list (not from a sublist), return early.
	        return;
	      }
	    }
	    let nextIndex;
	    if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
	      this.preventDefaultEvent(event);
	      nextIndex = this.focusNextElement(currentIndex);
	    } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
	      this.preventDefaultEvent(event);
	      nextIndex = this.focusPrevElement(currentIndex);
	    } else if (isHome) {
	      this.preventDefaultEvent(event);
	      nextIndex = this.focusFirstElement();
	    } else if (isEnd) {
	      this.preventDefaultEvent(event);
	      nextIndex = this.focusLastElement();
	    } else if (isEnter || isSpace) {
	      if (isRootListItem) {
	        // Return early if enter key is pressed on anchor element which triggers
	        // synthetic MouseEvent event.
	        const target = event.target;
	        if (target && target.tagName === 'A' && isEnter) {
	          return;
	        }
	        this.preventDefaultEvent(event);
	        this.setSelectedIndexOnAction_(currentIndex, true);
	      }
	    }
	    this.focusedItemIndex_ = currentIndex;
	    if (nextIndex !== undefined) {
	      this.setTabindexAtIndex_(nextIndex);
	      this.focusedItemIndex_ = nextIndex;
	    }
	  }
	  /**
	   * Click handler for the list.
	   */
	  handleSingleSelection(index, isInteraction, force) {
	    if (index === numbers$2.UNSET_INDEX) {
	      return;
	    }
	    this.setSelectedIndexOnAction_(index, isInteraction, force);
	    this.setTabindexAtIndex_(index);
	    this.focusedItemIndex_ = index;
	  }
	  /**
	   * Focuses the next element on the list.
	   */
	  focusNextElement(index) {
	    const count = this.adapter.getListItemCount();
	    let nextIndex = index + 1;
	    if (nextIndex >= count) {
	      if (this.wrapFocus_) {
	        nextIndex = 0;
	      } else {
	        // Return early because last item is already focused.
	        return index;
	      }
	    }
	    this.adapter.focusItemAtIndex(nextIndex);
	    return nextIndex;
	  }
	  /**
	   * Focuses the previous element on the list.
	   */
	  focusPrevElement(index) {
	    let prevIndex = index - 1;
	    if (prevIndex < 0) {
	      if (this.wrapFocus_) {
	        prevIndex = this.adapter.getListItemCount() - 1;
	      } else {
	        // Return early because first item is already focused.
	        return index;
	      }
	    }
	    this.adapter.focusItemAtIndex(prevIndex);
	    return prevIndex;
	  }
	  focusFirstElement() {
	    this.adapter.focusItemAtIndex(0);
	    return 0;
	  }
	  focusLastElement() {
	    const lastIndex = this.adapter.getListItemCount() - 1;
	    this.adapter.focusItemAtIndex(lastIndex);
	    return lastIndex;
	  }
	  /**
	   * @param itemIndex Index of the list item
	   * @param isEnabled Sets the list item to enabled or disabled.
	   */
	  setEnabled(itemIndex, isEnabled) {
	    if (!this.isIndexValid_(itemIndex)) {
	      return;
	    }
	    this.adapter.setDisabledStateForElementIndex(itemIndex, !isEnabled);
	  }
	  /**
	   * Ensures that preventDefault is only called if the containing element
	   * doesn't consume the event, and it will cause an unintended scroll.
	   */
	  preventDefaultEvent(evt) {
	    const target = evt.target;
	    const tagName = "".concat(target.tagName).toLowerCase();
	    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
	      evt.preventDefault();
	    }
	  }
	  setSingleSelectionAtIndex_(index) {
	    let isInteraction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    if (this.selectedIndex_ === index) {
	      return;
	    }
	    // unset previous
	    if (this.selectedIndex_ !== numbers$2.UNSET_INDEX) {
	      this.adapter.setSelectedStateForElementIndex(this.selectedIndex_, false);
	      if (this.useActivatedClass_) {
	        this.adapter.setActivatedStateForElementIndex(this.selectedIndex_, false);
	      }
	    }
	    // set new
	    if (isInteraction) {
	      this.adapter.setSelectedStateForElementIndex(index, true);
	    }
	    if (this.useActivatedClass_) {
	      this.adapter.setActivatedStateForElementIndex(index, true);
	    }
	    this.setAriaForSingleSelectionAtIndex_(index);
	    this.selectedIndex_ = index;
	    this.adapter.notifySelected(index);
	  }
	  setMultiSelectionAtIndex_(newIndex) {
	    let isInteraction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    const oldIndex = createSetFromIndex(this.selectedIndex_);
	    const diff = findIndexDiff(oldIndex, newIndex);
	    if (!diff.removed.length && !diff.added.length) {
	      return;
	    }
	    for (const removed of diff.removed) {
	      if (isInteraction) {
	        this.adapter.setSelectedStateForElementIndex(removed, false);
	      }
	      if (this.useActivatedClass_) {
	        this.adapter.setActivatedStateForElementIndex(removed, false);
	      }
	    }
	    for (const added of diff.added) {
	      if (isInteraction) {
	        this.adapter.setSelectedStateForElementIndex(added, true);
	      }
	      if (this.useActivatedClass_) {
	        this.adapter.setActivatedStateForElementIndex(added, true);
	      }
	    }
	    this.selectedIndex_ = newIndex;
	    this.adapter.notifySelected(newIndex, diff);
	  }
	  /**
	   * Sets aria attribute for single selection at given index.
	   */
	  setAriaForSingleSelectionAtIndex_(index) {
	    // Detect the presence of aria-current and get the value only during list
	    // initialization when it is in unset state.
	    if (this.selectedIndex_ === numbers$2.UNSET_INDEX) {
	      this.ariaCurrentAttrValue_ = this.adapter.getAttributeForElementIndex(index, strings$2.ARIA_CURRENT);
	    }
	    const isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
	    const ariaAttribute = isAriaCurrent ? strings$2.ARIA_CURRENT : strings$2.ARIA_SELECTED;
	    if (this.selectedIndex_ !== numbers$2.UNSET_INDEX) {
	      this.adapter.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
	    }
	    const ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
	    this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
	  }
	  setTabindexAtIndex_(index) {
	    if (this.focusedItemIndex_ === numbers$2.UNSET_INDEX && index !== 0) {
	      // If no list item was selected set first list item's tabindex to -1.
	      // Generally, tabindex is set to 0 on first list item of list that has no
	      // preselected items.
	      this.adapter.setTabIndexForElementIndex(0, -1);
	    } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
	      this.adapter.setTabIndexForElementIndex(this.focusedItemIndex_, -1);
	    }
	    this.adapter.setTabIndexForElementIndex(index, 0);
	  }
	  setTabindexToFirstSelectedItem_() {
	    let targetIndex = 0;
	    if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== numbers$2.UNSET_INDEX) {
	      targetIndex = this.selectedIndex_;
	    } else if (isIndexSet(this.selectedIndex_) && this.selectedIndex_.size > 0) {
	      targetIndex = Math.min(...this.selectedIndex_);
	    }
	    this.setTabindexAtIndex_(targetIndex);
	  }
	  isIndexValid_(index) {
	    if (index instanceof Set) {
	      if (!this.isMulti_) {
	        throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
	      }
	      if (index.size === 0) {
	        return true;
	      } else {
	        let isOneInRange = false;
	        for (const entry of index) {
	          isOneInRange = this.isIndexInRange_(entry);
	          if (isOneInRange) {
	            break;
	          }
	        }
	        return isOneInRange;
	      }
	    } else if (typeof index === 'number') {
	      if (this.isMulti_) {
	        throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
	      }
	      return index === numbers$2.UNSET_INDEX || this.isIndexInRange_(index);
	    } else {
	      return false;
	    }
	  }
	  isIndexInRange_(index) {
	    const listSize = this.adapter.getListItemCount();
	    return index >= 0 && index < listSize;
	  }
	  /**
	   * Sets selected index on user action, toggles checkbox / radio based on
	   * toggleCheckbox value. User interaction should not toggle list item(s) when
	   * disabled.
	   */
	  setSelectedIndexOnAction_(index, isInteraction, force) {
	    if (this.adapter.getDisabledStateForElementIndex(index)) {
	      return;
	    }
	    let checkedIndex = index;
	    if (this.isMulti_) {
	      checkedIndex = new Set([index]);
	    }
	    if (!this.isIndexValid_(checkedIndex)) {
	      return;
	    }
	    if (this.isMulti_) {
	      this.toggleMultiAtIndex(index, force, isInteraction);
	    } else {
	      if (isInteraction || force) {
	        this.setSingleSelectionAtIndex_(index, isInteraction);
	      } else {
	        const isDeselection = this.selectedIndex_ === index;
	        if (isDeselection) {
	          this.setSingleSelectionAtIndex_(numbers$2.UNSET_INDEX);
	        }
	      }
	    }
	    if (isInteraction) {
	      this.adapter.notifyAction(index);
	    }
	  }
	  toggleMultiAtIndex(index, force) {
	    let isInteraction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	    let newSelectionValue = false;
	    if (force === undefined) {
	      newSelectionValue = !this.adapter.getSelectedStateForElementIndex(index);
	    } else {
	      newSelectionValue = force;
	    }
	    const newSet = createSetFromIndex(this.selectedIndex_);
	    if (newSelectionValue) {
	      newSet.add(index);
	    } else {
	      newSet.delete(index);
	    }
	    this.setMultiSelectionAtIndex_(newSet, isInteraction);
	  }
	}

	var _templateObject$9, _templateObject2$4;
	function debounceLayout(callback) {
	  let waitInMS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;
	  let timeoutId;
	  // tslint:disable-next-line
	  return function () {
	    let updateItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    clearTimeout(timeoutId);
	    timeoutId = setTimeout(() => {
	      callback(updateItems);
	    }, waitInMS);
	  };
	}
	const isListItem = element => {
	  return element.hasAttribute('mwc-list-item');
	};
	function clearAndCreateItemsReadyPromise() {
	  const oldResolver = this.itemsReadyResolver;
	  this.itemsReady = new Promise(res => {
	    // TODO(b/175626389): Type '(value: never[] | PromiseLike<never[]>) => void'
	    // is not assignable to type '(value?: never[] | PromiseLike<never[]> |
	    // undefined) => void'.
	    return this.itemsReadyResolver = res;
	  });
	  oldResolver();
	}
	/**
	 * @fires selected {SelectedDetail}
	 * @fires action {ActionDetail}
	 * @fires items-updated
	 */
	class ListBase extends BaseElement {
	  constructor() {
	    var _this;
	    super();
	    _this = this;
	    this.mdcAdapter = null;
	    this.mdcFoundationClass = MDCListFoundation;
	    this.activatable = false;
	    this.multi = false;
	    this.wrapFocus = false;
	    this.itemRoles = null;
	    this.innerRole = null;
	    this.innerAriaLabel = null;
	    this.rootTabbable = false;
	    this.previousTabindex = null;
	    this.noninteractive = false;
	    this.itemsReadyResolver = () => {
	      //
	    };
	    this.itemsReady = Promise.resolve([]);
	    // tslint:enable:ban-ts-ignore
	    this.items_ = [];
	    const debouncedFunction = debounceLayout(this.layout.bind(this));
	    this.debouncedLayout = function () {
	      let updateItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      clearAndCreateItemsReadyPromise.call(_this);
	      debouncedFunction(updateItems);
	    };
	  }
	  // tslint:disable:ban-ts-ignore
	  async getUpdateComplete() {
	    // @ts-ignore
	    const result = await super.getUpdateComplete();
	    await this.itemsReady;
	    return result;
	  }
	  get items() {
	    return this.items_;
	  }
	  updateItems() {
	    var _a;
	    const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];
	    const listItems = [];
	    for (const node of nodes) {
	      if (isListItem(node)) {
	        listItems.push(node);
	        node._managingList = this;
	      }
	      if (node.hasAttribute('divider') && !node.hasAttribute('role')) {
	        node.setAttribute('role', 'separator');
	      }
	    }
	    this.items_ = listItems;
	    const selectedIndices = new Set();
	    this.items_.forEach((item, index) => {
	      if (this.itemRoles) {
	        item.setAttribute('role', this.itemRoles);
	      } else {
	        item.removeAttribute('role');
	      }
	      if (item.selected) {
	        selectedIndices.add(index);
	      }
	    });
	    if (this.multi) {
	      this.select(selectedIndices);
	    } else {
	      const index = selectedIndices.size ? selectedIndices.entries().next().value[1] : -1;
	      this.select(index);
	    }
	    const itemsUpdatedEv = new Event('items-updated', {
	      bubbles: true,
	      composed: true
	    });
	    this.dispatchEvent(itemsUpdatedEv);
	  }
	  get selected() {
	    const index = this.index;
	    if (!isIndexSet(index)) {
	      if (index === -1) {
	        return null;
	      }
	      return this.items[index];
	    }
	    const selected = [];
	    for (const entry of index) {
	      selected.push(this.items[entry]);
	    }
	    return selected;
	  }
	  get index() {
	    if (this.mdcFoundation) {
	      return this.mdcFoundation.getSelectedIndex();
	    }
	    return -1;
	  }
	  render() {
	    const role = this.innerRole === null ? undefined : this.innerRole;
	    const ariaLabel = this.innerAriaLabel === null ? undefined : this.innerAriaLabel;
	    const tabindex = this.rootTabbable ? '0' : '-1';
	    return x(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteral(["\n      <!-- @ts-ignore -->\n      <ul\n          tabindex=", "\n          role=\"", "\"\n          aria-label=\"", "\"\n          class=\"mdc-deprecated-list\"\n          @keydown=", "\n          @focusin=", "\n          @focusout=", "\n          @request-selected=", "\n          @list-item-rendered=", ">\n        <slot></slot>\n        ", "\n      </ul>\n    "])), tabindex, l(role), l(ariaLabel), this.onKeydown, this.onFocusIn, this.onFocusOut, this.onRequestSelected, this.onListItemConnected, this.renderPlaceholder());
	  }
	  renderPlaceholder() {
	    var _a;
	    const nodes = (_a = this.assignedElements) !== null && _a !== void 0 ? _a : [];
	    if (this.emptyMessage !== undefined && nodes.length === 0) {
	      return x(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteral(["\n        <mwc-list-item noninteractive>", "</mwc-list-item>\n      "])), this.emptyMessage);
	    }
	    return null;
	  }
	  firstUpdated() {
	    super.firstUpdated();
	    if (!this.items.length) {
	      // required because this is called before observers
	      this.mdcFoundation.setMulti(this.multi);
	      // for when children upgrade before list
	      this.layout();
	    }
	  }
	  onFocusIn(evt) {
	    if (this.mdcFoundation && this.mdcRoot) {
	      const index = this.getIndexOfTarget(evt);
	      this.mdcFoundation.handleFocusIn(evt, index);
	    }
	  }
	  onFocusOut(evt) {
	    if (this.mdcFoundation && this.mdcRoot) {
	      const index = this.getIndexOfTarget(evt);
	      this.mdcFoundation.handleFocusOut(evt, index);
	    }
	  }
	  onKeydown(evt) {
	    if (this.mdcFoundation && this.mdcRoot) {
	      const index = this.getIndexOfTarget(evt);
	      const target = evt.target;
	      const isRootListItem = isListItem(target);
	      this.mdcFoundation.handleKeydown(evt, isRootListItem, index);
	    }
	  }
	  onRequestSelected(evt) {
	    if (this.mdcFoundation) {
	      let index = this.getIndexOfTarget(evt);
	      // might happen in shady dom slowness. Recalc children
	      if (index === -1) {
	        this.layout();
	        index = this.getIndexOfTarget(evt);
	        // still not found; may not be mwc-list-item. Unsupported case.
	        if (index === -1) {
	          return;
	        }
	      }
	      const element = this.items[index];
	      if (element.disabled) {
	        return;
	      }
	      const selected = evt.detail.selected;
	      const source = evt.detail.source;
	      this.mdcFoundation.handleSingleSelection(index, source === 'interaction', selected);
	      evt.stopPropagation();
	    }
	  }
	  getIndexOfTarget(evt) {
	    const elements = this.items;
	    const path = evt.composedPath();
	    for (const pathItem of path) {
	      let index = -1;
	      if (isNodeElement(pathItem) && isListItem(pathItem)) {
	        index = elements.indexOf(pathItem);
	      }
	      if (index !== -1) {
	        return index;
	      }
	    }
	    return -1;
	  }
	  createAdapter() {
	    this.mdcAdapter = {
	      getListItemCount: () => {
	        if (this.mdcRoot) {
	          return this.items.length;
	        }
	        return 0;
	      },
	      getFocusedElementIndex: this.getFocusedItemIndex,
	      getAttributeForElementIndex: (index, attr) => {
	        const listElement = this.mdcRoot;
	        if (!listElement) {
	          return '';
	        }
	        const element = this.items[index];
	        return element ? element.getAttribute(attr) : '';
	      },
	      setAttributeForElementIndex: (index, attr, val) => {
	        if (!this.mdcRoot) {
	          return;
	        }
	        const element = this.items[index];
	        if (element) {
	          element.setAttribute(attr, val);
	        }
	      },
	      focusItemAtIndex: index => {
	        const element = this.items[index];
	        if (element) {
	          element.focus();
	        }
	      },
	      setTabIndexForElementIndex: (index, value) => {
	        const item = this.items[index];
	        if (item) {
	          item.tabindex = value;
	        }
	      },
	      notifyAction: index => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        init.detail = {
	          index
	        };
	        const ev = new CustomEvent('action', init);
	        this.dispatchEvent(ev);
	      },
	      notifySelected: (index, diff) => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        init.detail = {
	          index,
	          diff
	        };
	        const ev = new CustomEvent('selected', init);
	        this.dispatchEvent(ev);
	      },
	      isFocusInsideList: () => {
	        return doesElementContainFocus(this);
	      },
	      isRootFocused: () => {
	        const mdcRoot = this.mdcRoot;
	        const root = mdcRoot.getRootNode();
	        return root.activeElement === mdcRoot;
	      },
	      setDisabledStateForElementIndex: (index, value) => {
	        const item = this.items[index];
	        if (!item) {
	          return;
	        }
	        item.disabled = value;
	      },
	      getDisabledStateForElementIndex: index => {
	        const item = this.items[index];
	        if (!item) {
	          return false;
	        }
	        return item.disabled;
	      },
	      setSelectedStateForElementIndex: (index, value) => {
	        const item = this.items[index];
	        if (!item) {
	          return;
	        }
	        item.selected = value;
	      },
	      getSelectedStateForElementIndex: index => {
	        const item = this.items[index];
	        if (!item) {
	          return false;
	        }
	        return item.selected;
	      },
	      setActivatedStateForElementIndex: (index, value) => {
	        const item = this.items[index];
	        if (!item) {
	          return;
	        }
	        item.activated = value;
	      }
	    };
	    return this.mdcAdapter;
	  }
	  selectUi(index) {
	    let activate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    const item = this.items[index];
	    if (item) {
	      item.selected = true;
	      item.activated = activate;
	    }
	  }
	  deselectUi(index) {
	    const item = this.items[index];
	    if (item) {
	      item.selected = false;
	      item.activated = false;
	    }
	  }
	  select(index) {
	    if (!this.mdcFoundation) {
	      return;
	    }
	    this.mdcFoundation.setSelectedIndex(index);
	  }
	  toggle(index, force) {
	    if (this.multi) {
	      this.mdcFoundation.toggleMultiAtIndex(index, force);
	    }
	  }
	  onListItemConnected(e) {
	    const target = e.target;
	    this.layout(this.items.indexOf(target) === -1);
	  }
	  layout() {
	    let updateItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    if (updateItems) {
	      this.updateItems();
	    }
	    const first = this.items[0];
	    for (const item of this.items) {
	      item.tabindex = -1;
	    }
	    if (first) {
	      if (this.noninteractive) {
	        if (!this.previousTabindex) {
	          this.previousTabindex = first;
	        }
	      } else {
	        first.tabindex = 0;
	      }
	    }
	    this.itemsReadyResolver();
	  }
	  getFocusedItemIndex() {
	    if (!this.mdcRoot) {
	      return -1;
	    }
	    if (!this.items.length) {
	      return -1;
	    }
	    const activeElementPath = deepActiveElementPath();
	    if (!activeElementPath.length) {
	      return -1;
	    }
	    for (let i = activeElementPath.length - 1; i >= 0; i--) {
	      const activeItem = activeElementPath[i];
	      if (isListItem(activeItem)) {
	        return this.items.indexOf(activeItem);
	      }
	    }
	    return -1;
	  }
	  focusItemAtIndex(index) {
	    for (const item of this.items) {
	      if (item.tabindex === 0) {
	        item.tabindex = -1;
	        break;
	      }
	    }
	    this.items[index].tabindex = 0;
	    this.items[index].focus();
	  }
	  focus() {
	    const root = this.mdcRoot;
	    if (root) {
	      root.focus();
	    }
	  }
	  blur() {
	    const root = this.mdcRoot;
	    if (root) {
	      root.blur();
	    }
	  }
	}
	__decorate([n$6({
	  type: String
	})], ListBase.prototype, "emptyMessage", void 0);
	__decorate([i$4('.mdc-deprecated-list')], ListBase.prototype, "mdcRoot", void 0);
	__decorate([o$6('', true, '*')], ListBase.prototype, "assignedElements", void 0);
	__decorate([o$6('', true, '[tabindex="0"]')], ListBase.prototype, "tabbableElements", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    this.mdcFoundation.setUseActivatedClass(value);
	  }
	})], ListBase.prototype, "activatable", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (newValue, oldValue) {
	  if (this.mdcFoundation) {
	    this.mdcFoundation.setMulti(newValue);
	  }
	  if (oldValue !== undefined) {
	    this.layout();
	  }
	})], ListBase.prototype, "multi", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    this.mdcFoundation.setWrapFocus(value);
	  }
	})], ListBase.prototype, "wrapFocus", void 0);
	__decorate([n$6({
	  type: String
	}), observer(function (_newValue, oldValue) {
	  if (oldValue !== undefined) {
	    this.updateItems();
	  }
	})], ListBase.prototype, "itemRoles", void 0);
	__decorate([n$6({
	  type: String
	})], ListBase.prototype, "innerRole", void 0);
	__decorate([n$6({
	  type: String
	})], ListBase.prototype, "innerAriaLabel", void 0);
	__decorate([n$6({
	  type: Boolean
	})], ListBase.prototype, "rootTabbable", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	}), observer(function (value) {
	  var _a, _b;
	  if (value) {
	    const tabbable = (_b = (_a = this.tabbableElements) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
	    this.previousTabindex = tabbable;
	    if (tabbable) {
	      tabbable.setAttribute('tabindex', '-1');
	    }
	  } else if (!value && this.previousTabindex) {
	    this.previousTabindex.setAttribute('tabindex', '0');
	    this.previousTabindex = null;
	  }
	})], ListBase.prototype, "noninteractive", void 0);

	var _templateObject$8;
	const styles$4 = i$3(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteral(["@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{display:block}.mdc-deprecated-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height, 1.75rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);line-height:1.5rem;margin:0;padding:8px 0;list-style-type:none;color:rgba(0, 0, 0, 0.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87));padding:var(--mdc-list-vertical-padding, 8px) 0}.mdc-deprecated-list:focus{outline:none}.mdc-deprecated-list-item{height:48px}.mdc-deprecated-list--dense{padding-top:4px;padding-bottom:4px;font-size:.812rem}.mdc-deprecated-list ::slotted([divider]){height:0;margin:0;border:none;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgba(0, 0, 0, 0.12)}.mdc-deprecated-list ::slotted([divider][padded]){margin:0 var(--mdc-list-side-padding, 16px)}.mdc-deprecated-list ::slotted([divider][inset]){margin-left:var(--mdc-list-inset-margin, 72px);margin-right:0;width:calc( 100% - var(--mdc-list-inset-margin, 72px) )}[dir=rtl] .mdc-deprecated-list ::slotted([divider][inset]),.mdc-deprecated-list ::slotted([divider][inset][dir=rtl]){margin-left:0;margin-right:var(--mdc-list-inset-margin, 72px)}.mdc-deprecated-list ::slotted([divider][inset][padded]){width:calc( 100% - var(--mdc-list-inset-margin, 72px) - var(--mdc-list-side-padding, 16px) )}.mdc-deprecated-list--dense ::slotted([mwc-list-item]){height:40px}.mdc-deprecated-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 20px}.mdc-deprecated-list--two-line.mdc-deprecated-list--dense ::slotted([mwc-list-item]),.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense ::slotted([mwc-list-item]){height:60px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 36px}:host([noninteractive]){pointer-events:none;cursor:default}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text){display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text)::before{display:inline-block;width:0;height:24px;content:\"\";vertical-align:0}.mdc-deprecated-list--dense ::slotted(.mdc-deprecated-list-item__primary-text)::after{display:inline-block;width:0;height:20px;content:\"\";vertical-align:-20px}"])));

	/**
	 * @license
	 * Copyright 2020 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let List = class List extends ListBase {};
	List.styles = [styles$4];
	List = __decorate([e$8('mwc-list')], List);

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var cssClasses$1 = {
	  ANCHOR: 'mdc-menu-surface--anchor',
	  ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
	  ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
	  FIXED: 'mdc-menu-surface--fixed',
	  IS_OPEN_BELOW: 'mdc-menu-surface--is-open-below',
	  OPEN: 'mdc-menu-surface--open',
	  ROOT: 'mdc-menu-surface'
	};
	// tslint:disable:object-literal-sort-keys
	var strings$1 = {
	  CLOSED_EVENT: 'MDCMenuSurface:closed',
	  CLOSING_EVENT: 'MDCMenuSurface:closing',
	  OPENED_EVENT: 'MDCMenuSurface:opened',
	  OPENING_EVENT: 'MDCMenuSurface:opening',
	  FOCUSABLE_ELEMENTS: ['button:not(:disabled)', '[href]:not([aria-disabled="true"])', 'input:not(:disabled)', 'select:not(:disabled)', 'textarea:not(:disabled)', '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'].join(', ')
	};
	// tslint:enable:object-literal-sort-keys
	var numbers$1 = {
	  /** Total duration of menu-surface open animation. */
	  TRANSITION_OPEN_DURATION: 120,
	  /** Total duration of menu-surface close animation. */
	  TRANSITION_CLOSE_DURATION: 75,
	  /**
	   * Margin left to the edge of the viewport when menu-surface is at maximum
	   * possible height. Also used as a viewport margin.
	   */
	  MARGIN_TO_EDGE: 32,
	  /**
	   * Ratio of anchor width to menu-surface width for switching from corner
	   * positioning to center positioning.
	   */
	  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
	  /**
	   * Amount of time to wait before restoring focus when closing the menu
	   * surface. This is important because if a touch event triggered the menu
	   * close, and the subsequent mouse event occurs after focus is restored, then
	   * the restored focus would be lost.
	   */
	  TOUCH_EVENT_WAIT_MS: 30
	};
	/**
	 * Enum for bits in the {@see Corner) bitmap.
	 */
	var CornerBit;
	(function (CornerBit) {
	  CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
	  CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
	  CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
	  CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
	})(CornerBit || (CornerBit = {}));
	/**
	 * Enum for representing an element corner for positioning the menu-surface.
	 *
	 * The START constants map to LEFT if element directionality is left
	 * to right and RIGHT if the directionality is right to left.
	 * Likewise END maps to RIGHT or LEFT depending on the directionality.
	 */
	var Corner;
	(function (Corner) {
	  Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
	  Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
	  Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
	  Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
	  Corner[Corner["TOP_START"] = 8] = "TOP_START";
	  Corner[Corner["TOP_END"] = 12] = "TOP_END";
	  Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
	  Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
	})(Corner || (Corner = {}));

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation$1 = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCMenuSurfaceFoundation = /** @class */function (_super) {
	  __extends(MDCMenuSurfaceFoundation, _super);
	  function MDCMenuSurfaceFoundation(adapter) {
	    var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation.defaultAdapter), adapter)) || this;
	    _this.isSurfaceOpen = false;
	    _this.isQuickOpen = false;
	    _this.isHoistedElement = false;
	    _this.isFixedPosition = false;
	    _this.isHorizontallyCenteredOnViewport = false;
	    _this.maxHeight = 0;
	    _this.openBottomBias = 0;
	    _this.openAnimationEndTimerId = 0;
	    _this.closeAnimationEndTimerId = 0;
	    _this.animationRequestId = 0;
	    _this.anchorCorner = Corner.TOP_START;
	    /**
	     * Corner of the menu surface to which menu surface is attached to anchor.
	     *
	     *  Anchor corner --->+----------+
	     *                    |  ANCHOR  |
	     *                    +----------+
	     *  Origin corner --->+--------------+
	     *                    |              |
	     *                    |              |
	     *                    | MENU SURFACE |
	     *                    |              |
	     *                    |              |
	     *                    +--------------+
	     */
	    _this.originCorner = Corner.TOP_START;
	    _this.anchorMargin = {
	      top: 0,
	      right: 0,
	      bottom: 0,
	      left: 0
	    };
	    _this.position = {
	      x: 0,
	      y: 0
	    };
	    return _this;
	  }
	  Object.defineProperty(MDCMenuSurfaceFoundation, "cssClasses", {
	    get: function () {
	      return cssClasses$1;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuSurfaceFoundation, "strings", {
	    get: function () {
	      return strings$1;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuSurfaceFoundation, "numbers", {
	    get: function () {
	      return numbers$1;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuSurfaceFoundation, "Corner", {
	    get: function () {
	      return Corner;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuSurfaceFoundation, "defaultAdapter", {
	    /**
	     * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
	     */
	    get: function () {
	      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
	      return {
	        addClass: function () {
	          return undefined;
	        },
	        removeClass: function () {
	          return undefined;
	        },
	        hasClass: function () {
	          return false;
	        },
	        hasAnchor: function () {
	          return false;
	        },
	        isElementInContainer: function () {
	          return false;
	        },
	        isFocused: function () {
	          return false;
	        },
	        isRtl: function () {
	          return false;
	        },
	        getInnerDimensions: function () {
	          return {
	            height: 0,
	            width: 0
	          };
	        },
	        getAnchorDimensions: function () {
	          return null;
	        },
	        getWindowDimensions: function () {
	          return {
	            height: 0,
	            width: 0
	          };
	        },
	        getBodyDimensions: function () {
	          return {
	            height: 0,
	            width: 0
	          };
	        },
	        getWindowScroll: function () {
	          return {
	            x: 0,
	            y: 0
	          };
	        },
	        setPosition: function () {
	          return undefined;
	        },
	        setMaxHeight: function () {
	          return undefined;
	        },
	        setTransformOrigin: function () {
	          return undefined;
	        },
	        saveFocus: function () {
	          return undefined;
	        },
	        restoreFocus: function () {
	          return undefined;
	        },
	        notifyClose: function () {
	          return undefined;
	        },
	        notifyClosing: function () {
	          return undefined;
	        },
	        notifyOpen: function () {
	          return undefined;
	        },
	        notifyOpening: function () {
	          return undefined;
	        }
	      };
	      // tslint:enable:object-literal-sort-keys
	    },

	    enumerable: false,
	    configurable: true
	  });
	  MDCMenuSurfaceFoundation.prototype.init = function () {
	    var _a = MDCMenuSurfaceFoundation.cssClasses,
	      ROOT = _a.ROOT,
	      OPEN = _a.OPEN;
	    if (!this.adapter.hasClass(ROOT)) {
	      throw new Error(ROOT + " class required in root element.");
	    }
	    if (this.adapter.hasClass(OPEN)) {
	      this.isSurfaceOpen = true;
	    }
	  };
	  MDCMenuSurfaceFoundation.prototype.destroy = function () {
	    clearTimeout(this.openAnimationEndTimerId);
	    clearTimeout(this.closeAnimationEndTimerId);
	    // Cancel any currently running animations.
	    cancelAnimationFrame(this.animationRequestId);
	  };
	  /**
	   * @param corner Default anchor corner alignment of top-left menu surface
	   *     corner.
	   */
	  MDCMenuSurfaceFoundation.prototype.setAnchorCorner = function (corner) {
	    this.anchorCorner = corner;
	  };
	  /**
	   * Flip menu corner horizontally.
	   */
	  MDCMenuSurfaceFoundation.prototype.flipCornerHorizontally = function () {
	    this.originCorner = this.originCorner ^ CornerBit.RIGHT;
	  };
	  /**
	   * @param margin Set of margin values from anchor.
	   */
	  MDCMenuSurfaceFoundation.prototype.setAnchorMargin = function (margin) {
	    this.anchorMargin.top = margin.top || 0;
	    this.anchorMargin.right = margin.right || 0;
	    this.anchorMargin.bottom = margin.bottom || 0;
	    this.anchorMargin.left = margin.left || 0;
	  };
	  /** Used to indicate if the menu-surface is hoisted to the body. */
	  MDCMenuSurfaceFoundation.prototype.setIsHoisted = function (isHoisted) {
	    this.isHoistedElement = isHoisted;
	  };
	  /**
	   * Used to set the menu-surface calculations based on a fixed position menu.
	   */
	  MDCMenuSurfaceFoundation.prototype.setFixedPosition = function (isFixedPosition) {
	    this.isFixedPosition = isFixedPosition;
	  };
	  /**
	   * @return Returns true if menu is in fixed (`position: fixed`) position.
	   */
	  MDCMenuSurfaceFoundation.prototype.isFixed = function () {
	    return this.isFixedPosition;
	  };
	  /** Sets the menu-surface position on the page. */
	  MDCMenuSurfaceFoundation.prototype.setAbsolutePosition = function (x, y) {
	    this.position.x = this.isFinite(x) ? x : 0;
	    this.position.y = this.isFinite(y) ? y : 0;
	  };
	  /** Sets whether menu-surface should be horizontally centered to viewport. */
	  MDCMenuSurfaceFoundation.prototype.setIsHorizontallyCenteredOnViewport = function (isCentered) {
	    this.isHorizontallyCenteredOnViewport = isCentered;
	  };
	  MDCMenuSurfaceFoundation.prototype.setQuickOpen = function (quickOpen) {
	    this.isQuickOpen = quickOpen;
	  };
	  /**
	   * Sets maximum menu-surface height on open.
	   * @param maxHeight The desired max-height. Set to 0 (default) to
	   *     automatically calculate max height based on available viewport space.
	   */
	  MDCMenuSurfaceFoundation.prototype.setMaxHeight = function (maxHeight) {
	    this.maxHeight = maxHeight;
	  };
	  /**
	   * Set to a positive integer to influence the menu to preferentially open
	   * below the anchor instead of above.
	   * @param bias A value of `x` simulates an extra `x` pixels of available space
	   *     below the menu during positioning calculations.
	   */
	  MDCMenuSurfaceFoundation.prototype.setOpenBottomBias = function (bias) {
	    this.openBottomBias = bias;
	  };
	  MDCMenuSurfaceFoundation.prototype.isOpen = function () {
	    return this.isSurfaceOpen;
	  };
	  /**
	   * Open the menu surface.
	   */
	  MDCMenuSurfaceFoundation.prototype.open = function () {
	    var _this = this;
	    if (this.isSurfaceOpen) {
	      return;
	    }
	    this.adapter.notifyOpening();
	    this.adapter.saveFocus();
	    if (this.isQuickOpen) {
	      this.isSurfaceOpen = true;
	      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
	      this.dimensions = this.adapter.getInnerDimensions();
	      this.autoposition();
	      this.adapter.notifyOpen();
	    } else {
	      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
	      this.animationRequestId = requestAnimationFrame(function () {
	        _this.dimensions = _this.adapter.getInnerDimensions();
	        _this.autoposition();
	        _this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
	        _this.openAnimationEndTimerId = setTimeout(function () {
	          _this.openAnimationEndTimerId = 0;
	          _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
	          _this.adapter.notifyOpen();
	        }, numbers$1.TRANSITION_OPEN_DURATION);
	      });
	      this.isSurfaceOpen = true;
	    }
	  };
	  /**
	   * Closes the menu surface.
	   */
	  MDCMenuSurfaceFoundation.prototype.close = function (skipRestoreFocus) {
	    var _this = this;
	    if (skipRestoreFocus === void 0) {
	      skipRestoreFocus = false;
	    }
	    if (!this.isSurfaceOpen) {
	      return;
	    }
	    this.adapter.notifyClosing();
	    if (this.isQuickOpen) {
	      this.isSurfaceOpen = false;
	      if (!skipRestoreFocus) {
	        this.maybeRestoreFocus();
	      }
	      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
	      this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
	      this.adapter.notifyClose();
	      return;
	    }
	    this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
	    requestAnimationFrame(function () {
	      _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);
	      _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
	      _this.closeAnimationEndTimerId = setTimeout(function () {
	        _this.closeAnimationEndTimerId = 0;
	        _this.adapter.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
	        _this.adapter.notifyClose();
	      }, numbers$1.TRANSITION_CLOSE_DURATION);
	    });
	    this.isSurfaceOpen = false;
	    if (!skipRestoreFocus) {
	      this.maybeRestoreFocus();
	    }
	  };
	  /** Handle clicks and close if not within menu-surface element. */
	  MDCMenuSurfaceFoundation.prototype.handleBodyClick = function (evt) {
	    var el = evt.target;
	    if (this.adapter.isElementInContainer(el)) {
	      return;
	    }
	    this.close();
	  };
	  /** Handle keys that close the surface. */
	  MDCMenuSurfaceFoundation.prototype.handleKeydown = function (evt) {
	    var keyCode = evt.keyCode,
	      key = evt.key;
	    var isEscape = key === 'Escape' || keyCode === 27;
	    if (isEscape) {
	      this.close();
	    }
	  };
	  MDCMenuSurfaceFoundation.prototype.autoposition = function () {
	    var _a;
	    // Compute measurements for autoposition methods reuse.
	    this.measurements = this.getAutoLayoutmeasurements();
	    var corner = this.getoriginCorner();
	    var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
	    var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';
	    var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? 'right' : 'left';
	    var horizontalOffset = this.getHorizontalOriginOffset(corner);
	    var verticalOffset = this.getVerticalOriginOffset(corner);
	    var _b = this.measurements,
	      anchorSize = _b.anchorSize,
	      surfaceSize = _b.surfaceSize;
	    var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a);
	    // Center align when anchor width is comparable or greater than menu
	    // surface, otherwise keep corner.
	    if (anchorSize.width / surfaceSize.width > numbers$1.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
	      horizontalAlignment = 'center';
	    }
	    // If the menu-surface has been hoisted to the body, it's no longer relative
	    // to the anchor element
	    if (this.isHoistedElement || this.isFixedPosition) {
	      this.adjustPositionForHoistedElement(position);
	    }
	    this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
	    this.adapter.setPosition(position);
	    this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : '');
	    // If it is opened from the top then add is-open-below class
	    if (!this.hasBit(corner, CornerBit.BOTTOM)) {
	      this.adapter.addClass(MDCMenuSurfaceFoundation.cssClasses.IS_OPEN_BELOW);
	    }
	  };
	  /**
	   * @return Measurements used to position menu surface popup.
	   */
	  MDCMenuSurfaceFoundation.prototype.getAutoLayoutmeasurements = function () {
	    var anchorRect = this.adapter.getAnchorDimensions();
	    var bodySize = this.adapter.getBodyDimensions();
	    var viewportSize = this.adapter.getWindowDimensions();
	    var windowScroll = this.adapter.getWindowScroll();
	    if (!anchorRect) {
	      // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
	      anchorRect = {
	        top: this.position.y,
	        right: this.position.x,
	        bottom: this.position.y,
	        left: this.position.x,
	        width: 0,
	        height: 0
	      };
	      // tslint:enable:object-literal-sort-keys
	    }

	    return {
	      anchorSize: anchorRect,
	      bodySize: bodySize,
	      surfaceSize: this.dimensions,
	      viewportDistance: {
	        // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
	        top: anchorRect.top,
	        right: viewportSize.width - anchorRect.right,
	        bottom: viewportSize.height - anchorRect.bottom,
	        left: anchorRect.left
	        // tslint:enable:object-literal-sort-keys
	      },

	      viewportSize: viewportSize,
	      windowScroll: windowScroll
	    };
	  };
	  /**
	   * Computes the corner of the anchor from which to animate and position the
	   * menu surface.
	   *
	   * Only LEFT or RIGHT bit is used to position the menu surface ignoring RTL
	   * context. E.g., menu surface will be positioned from right side on TOP_END.
	   */
	  MDCMenuSurfaceFoundation.prototype.getoriginCorner = function () {
	    var corner = this.originCorner;
	    var _a = this.measurements,
	      viewportDistance = _a.viewportDistance,
	      anchorSize = _a.anchorSize,
	      surfaceSize = _a.surfaceSize;
	    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
	    var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
	    var availableTop;
	    var availableBottom;
	    if (isAnchoredToBottom) {
	      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
	      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
	    } else {
	      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
	      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
	    }
	    var isAvailableBottom = availableBottom - surfaceSize.height > 0;
	    if (!isAvailableBottom && availableTop > availableBottom + this.openBottomBias) {
	      // Attach bottom side of surface to the anchor.
	      corner = this.setBit(corner, CornerBit.BOTTOM);
	    }
	    var isRtl = this.adapter.isRtl();
	    var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
	    var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
	    // Whether surface attached to right side of anchor element.
	    var isAnchoredToRight = false;
	    // Anchored to start
	    if (isRtl && isFlipRtl) {
	      isAnchoredToRight = !hasRightBit;
	    } else {
	      // Anchored to right
	      isAnchoredToRight = hasRightBit;
	    }
	    var availableLeft;
	    var availableRight;
	    if (isAnchoredToRight) {
	      availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
	      availableRight = viewportDistance.right - this.anchorMargin.right;
	    } else {
	      availableLeft = viewportDistance.left + this.anchorMargin.left;
	      availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
	    }
	    var isAvailableLeft = availableLeft - surfaceSize.width > 0;
	    var isAvailableRight = availableRight - surfaceSize.width > 0;
	    var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
	    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
	      // Attach left side of surface to the anchor.
	      corner = this.unsetBit(corner, CornerBit.RIGHT);
	    } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
	      // Attach right side of surface to the anchor.
	      corner = this.setBit(corner, CornerBit.RIGHT);
	    }
	    return corner;
	  };
	  /**
	   * @param corner Origin corner of the menu surface.
	   * @return Maximum height of the menu surface, based on available space. 0
	   *     indicates should not be set.
	   */
	  MDCMenuSurfaceFoundation.prototype.getMenuSurfaceMaxHeight = function (corner) {
	    if (this.maxHeight > 0) {
	      return this.maxHeight;
	    }
	    var viewportDistance = this.measurements.viewportDistance;
	    var maxHeight = 0;
	    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
	    var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
	    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE;
	    // When maximum height is not specified, it is handled from CSS.
	    if (isBottomAligned) {
	      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
	      if (!isBottomAnchored) {
	        maxHeight += this.measurements.anchorSize.height;
	      }
	    } else {
	      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
	      if (isBottomAnchored) {
	        maxHeight -= this.measurements.anchorSize.height;
	      }
	    }
	    return maxHeight;
	  };
	  /**
	   * @param corner Origin corner of the menu surface.
	   * @return Horizontal offset of menu surface origin corner from corresponding
	   *     anchor corner.
	   */
	  MDCMenuSurfaceFoundation.prototype.getHorizontalOriginOffset = function (corner) {
	    var anchorSize = this.measurements.anchorSize;
	    // isRightAligned corresponds to using the 'right' property on the surface.
	    var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
	    var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
	    if (isRightAligned) {
	      var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
	      // For hoisted or fixed elements, adjust the offset by the difference
	      // between viewport width and body width so when we calculate the right
	      // value (`adjustPositionForHoistedElement`) based on the element
	      // position, the right property is correct.
	      if (this.isHoistedElement || this.isFixedPosition) {
	        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
	      }
	      return rightOffset;
	    }
	    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
	  };
	  /**
	   * @param corner Origin corner of the menu surface.
	   * @return Vertical offset of menu surface origin corner from corresponding
	   *     anchor corner.
	   */
	  MDCMenuSurfaceFoundation.prototype.getVerticalOriginOffset = function (corner) {
	    var anchorSize = this.measurements.anchorSize;
	    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
	    var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
	    var y = 0;
	    if (isBottomAligned) {
	      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
	    } else {
	      y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
	    }
	    return y;
	  };
	  /**
	   * Calculates the offsets for positioning the menu-surface when the
	   * menu-surface has been hoisted to the body.
	   */
	  MDCMenuSurfaceFoundation.prototype.adjustPositionForHoistedElement = function (position) {
	    var e_1, _a;
	    var _b = this.measurements,
	      windowScroll = _b.windowScroll,
	      viewportDistance = _b.viewportDistance,
	      surfaceSize = _b.surfaceSize,
	      viewportSize = _b.viewportSize;
	    var props = Object.keys(position);
	    try {
	      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
	        var prop = props_1_1.value;
	        var value = position[prop] || 0;
	        if (this.isHorizontallyCenteredOnViewport && (prop === 'left' || prop === 'right')) {
	          position[prop] = (viewportSize.width - surfaceSize.width) / 2;
	          continue;
	        }
	        // Hoisted surfaces need to have the anchor elements location on the page
	        // added to the position properties for proper alignment on the body.
	        value += viewportDistance[prop];
	        // Surfaces that are absolutely positioned need to have additional
	        // calculations for scroll and bottom positioning.
	        if (!this.isFixedPosition) {
	          if (prop === 'top') {
	            value += windowScroll.y;
	          } else if (prop === 'bottom') {
	            value -= windowScroll.y;
	          } else if (prop === 'left') {
	            value += windowScroll.x;
	          } else {
	            // prop === 'right'
	            value -= windowScroll.x;
	          }
	        }
	        position[prop] = value;
	      }
	    } catch (e_1_1) {
	      e_1 = {
	        error: e_1_1
	      };
	    } finally {
	      try {
	        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
	      } finally {
	        if (e_1) throw e_1.error;
	      }
	    }
	  };
	  /**
	   * The last focused element when the menu surface was opened should regain
	   * focus, if the user is focused on or within the menu surface when it is
	   * closed.
	   */
	  MDCMenuSurfaceFoundation.prototype.maybeRestoreFocus = function () {
	    var _this = this;
	    var isRootFocused = this.adapter.isFocused();
	    var ownerDocument = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document;
	    var childHasFocus = ownerDocument.activeElement && this.adapter.isElementInContainer(ownerDocument.activeElement);
	    if (isRootFocused || childHasFocus) {
	      // Wait before restoring focus when closing the menu surface. This is
	      // important because if a touch event triggered the menu close, and the
	      // subsequent mouse event occurs after focus is restored, then the
	      // restored focus would be lost.
	      setTimeout(function () {
	        _this.adapter.restoreFocus();
	      }, numbers$1.TOUCH_EVENT_WAIT_MS);
	    }
	  };
	  MDCMenuSurfaceFoundation.prototype.hasBit = function (corner, bit) {
	    return Boolean(corner & bit); // tslint:disable-line:no-bitwise
	  };

	  MDCMenuSurfaceFoundation.prototype.setBit = function (corner, bit) {
	    return corner | bit; // tslint:disable-line:no-bitwise
	  };

	  MDCMenuSurfaceFoundation.prototype.unsetBit = function (corner, bit) {
	    return corner ^ bit;
	  };
	  /**
	   * isFinite that doesn't force conversion to number type.
	   * Equivalent to Number.isFinite in ES2015, which is not supported in IE.
	   */
	  MDCMenuSurfaceFoundation.prototype.isFinite = function (num) {
	    return typeof num === 'number' && isFinite(num);
	  };
	  return MDCMenuSurfaceFoundation;
	}(MDCFoundation$1);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCMenuSurfaceFoundation$1 = MDCMenuSurfaceFoundation;

	var _templateObject$7, _templateObject2$3;
	// tslint:disable:no-bitwise
	// required for closure compiler
	const stringToCorner = {
	  'TOP_LEFT': Corner.TOP_LEFT,
	  'TOP_RIGHT': Corner.TOP_RIGHT,
	  'BOTTOM_LEFT': Corner.BOTTOM_LEFT,
	  'BOTTOM_RIGHT': Corner.BOTTOM_RIGHT,
	  'TOP_START': Corner.TOP_START,
	  'TOP_END': Corner.TOP_END,
	  'BOTTOM_START': Corner.BOTTOM_START,
	  'BOTTOM_END': Corner.BOTTOM_END
	};
	/**
	 * @fires opened
	 * @fires closed
	 */
	class MenuSurfaceBase extends BaseElement {
	  constructor() {
	    super(...arguments);
	    this.mdcFoundationClass = MDCMenuSurfaceFoundation$1;
	    this.absolute = false;
	    this.fullwidth = false;
	    this.fixed = false;
	    this.x = null;
	    this.y = null;
	    // must be defined before open or else race condition in foundation occurs.
	    this.quick = false;
	    this.open = false;
	    this.stayOpenOnBodyClick = false;
	    this.bitwiseCorner = Corner.TOP_START;
	    this.previousMenuCorner = null;
	    // must be defined before observer of anchor corner for initialization
	    this.menuCorner = 'START';
	    this.corner = 'TOP_START';
	    this.styleTop = '';
	    this.styleLeft = '';
	    this.styleRight = '';
	    this.styleBottom = '';
	    this.styleMaxHeight = '';
	    this.styleTransformOrigin = '';
	    this.anchor = null;
	    this.previouslyFocused = null;
	    this.previousAnchor = null;
	    this.onBodyClickBound = () => undefined;
	  }
	  render() {
	    return this.renderSurface();
	  }
	  renderSurface() {
	    const classes = this.getRootClasses();
	    const styles = this.getRootStyles();
	    return x(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteral(["\n      <div\n          class=", "\n          style=\"", "\"\n          @keydown=", "\n          @opened=", "\n          @closed=", ">\n        ", "\n      </div>"])), o$1(classes), o(styles), this.onKeydown, this.registerBodyClick, this.deregisterBodyClick, this.renderContent());
	  }
	  getRootClasses() {
	    return {
	      'mdc-menu-surface': true,
	      'mdc-menu-surface--fixed': this.fixed,
	      'mdc-menu-surface--fullwidth': this.fullwidth
	    };
	  }
	  getRootStyles() {
	    return {
	      'top': this.styleTop,
	      'left': this.styleLeft,
	      'right': this.styleRight,
	      'bottom': this.styleBottom,
	      'max-height': this.styleMaxHeight,
	      'transform-origin': this.styleTransformOrigin
	    };
	  }
	  renderContent() {
	    return x(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteral(["<slot></slot>"])));
	  }
	  createAdapter() {
	    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {
	      hasAnchor: () => {
	        return !!this.anchor;
	      },
	      notifyClose: () => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        const ev = new CustomEvent('closed', init);
	        this.open = false;
	        this.mdcRoot.dispatchEvent(ev);
	      },
	      notifyClosing: () => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        const ev = new CustomEvent('closing', init);
	        this.mdcRoot.dispatchEvent(ev);
	      },
	      notifyOpen: () => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        const ev = new CustomEvent('opened', init);
	        this.open = true;
	        this.mdcRoot.dispatchEvent(ev);
	      },
	      notifyOpening: () => {
	        const init = {
	          bubbles: true,
	          composed: true
	        };
	        const ev = new CustomEvent('opening', init);
	        this.mdcRoot.dispatchEvent(ev);
	      },
	      isElementInContainer: () => false,
	      isRtl: () => {
	        if (this.mdcRoot) {
	          return getComputedStyle(this.mdcRoot).direction === 'rtl';
	        }
	        return false;
	      },
	      setTransformOrigin: origin => {
	        const root = this.mdcRoot;
	        if (!root) {
	          return;
	        }
	        this.styleTransformOrigin = origin;
	      },
	      isFocused: () => {
	        return doesElementContainFocus(this);
	      },
	      saveFocus: () => {
	        const activeElementPath = deepActiveElementPath();
	        const pathLength = activeElementPath.length;
	        if (!pathLength) {
	          this.previouslyFocused = null;
	        }
	        this.previouslyFocused = activeElementPath[pathLength - 1];
	      },
	      restoreFocus: () => {
	        if (!this.previouslyFocused) {
	          return;
	        }
	        if ('focus' in this.previouslyFocused) {
	          this.previouslyFocused.focus();
	        }
	      },
	      getInnerDimensions: () => {
	        const mdcRoot = this.mdcRoot;
	        if (!mdcRoot) {
	          return {
	            width: 0,
	            height: 0
	          };
	        }
	        return {
	          width: mdcRoot.offsetWidth,
	          height: mdcRoot.offsetHeight
	        };
	      },
	      getAnchorDimensions: () => {
	        const anchorElement = this.anchor;
	        return anchorElement ? anchorElement.getBoundingClientRect() : null;
	      },
	      getBodyDimensions: () => {
	        return {
	          width: document.body.clientWidth,
	          height: document.body.clientHeight
	        };
	      },
	      getWindowDimensions: () => {
	        return {
	          width: window.innerWidth,
	          height: window.innerHeight
	        };
	      },
	      getWindowScroll: () => {
	        return {
	          x: window.pageXOffset,
	          y: window.pageYOffset
	        };
	      },
	      setPosition: position => {
	        const mdcRoot = this.mdcRoot;
	        if (!mdcRoot) {
	          return;
	        }
	        this.styleLeft = 'left' in position ? "".concat(position.left, "px") : '';
	        this.styleRight = 'right' in position ? "".concat(position.right, "px") : '';
	        this.styleTop = 'top' in position ? "".concat(position.top, "px") : '';
	        this.styleBottom = 'bottom' in position ? "".concat(position.bottom, "px") : '';
	      },
	      setMaxHeight: async height => {
	        const mdcRoot = this.mdcRoot;
	        if (!mdcRoot) {
	          return;
	        }
	        // must set both for IE support as IE will not set a var
	        this.styleMaxHeight = height;
	        await this.updateComplete;
	        this.styleMaxHeight = "var(--mdc-menu-max-height, ".concat(height, ")");
	      }
	    });
	  }
	  onKeydown(evt) {
	    if (this.mdcFoundation) {
	      this.mdcFoundation.handleKeydown(evt);
	    }
	  }
	  onBodyClick(evt) {
	    if (this.stayOpenOnBodyClick) {
	      return;
	    }
	    const path = evt.composedPath();
	    if (path.indexOf(this) === -1) {
	      this.close();
	    }
	  }
	  registerBodyClick() {
	    this.onBodyClickBound = this.onBodyClick.bind(this);
	    // capture otherwise listener closes menu after quick menu opens
	    document.body.addEventListener('click', this.onBodyClickBound, {
	      passive: true,
	      capture: true
	    });
	  }
	  deregisterBodyClick() {
	    document.body.removeEventListener('click', this.onBodyClickBound, {
	      capture: true
	    });
	  }
	  onOpenChanged(isOpen, wasOpen) {
	    if (this.mdcFoundation) {
	      if (isOpen) {
	        this.mdcFoundation.open();
	        // wasOpen helps with first render (when it is `undefined`) perf
	      } else if (wasOpen !== undefined) {
	        this.mdcFoundation.close();
	      }
	    }
	  }
	  close() {
	    this.open = false;
	  }
	  show() {
	    this.open = true;
	  }
	}
	__decorate([i$4('.mdc-menu-surface')], MenuSurfaceBase.prototype, "mdcRoot", void 0);
	__decorate([i$4('slot')], MenuSurfaceBase.prototype, "slotElement", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (isAbsolute) {
	  if (this.mdcFoundation && !this.fixed) {
	    this.mdcFoundation.setIsHoisted(isAbsolute);
	  }
	})], MenuSurfaceBase.prototype, "absolute", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuSurfaceBase.prototype, "fullwidth", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (isFixed) {
	  if (this.mdcFoundation && !this.absolute) {
	    this.mdcFoundation.setFixedPosition(isFixed);
	  }
	})], MenuSurfaceBase.prototype, "fixed", void 0);
	__decorate([n$6({
	  type: Number
	}), observer(function (value) {
	  if (this.mdcFoundation && this.y !== null && value !== null) {
	    this.mdcFoundation.setAbsolutePosition(value, this.y);
	    this.mdcFoundation.setAnchorMargin({
	      left: value,
	      top: this.y,
	      right: -value,
	      bottom: this.y
	    });
	  }
	})], MenuSurfaceBase.prototype, "x", void 0);
	__decorate([n$6({
	  type: Number
	}), observer(function (value) {
	  if (this.mdcFoundation && this.x !== null && value !== null) {
	    this.mdcFoundation.setAbsolutePosition(this.x, value);
	    this.mdcFoundation.setAnchorMargin({
	      left: this.x,
	      top: value,
	      right: -this.x,
	      bottom: value
	    });
	  }
	})], MenuSurfaceBase.prototype, "y", void 0);
	__decorate([n$6({
	  type: Boolean
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    this.mdcFoundation.setQuickOpen(value);
	  }
	})], MenuSurfaceBase.prototype, "quick", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	}), observer(function (isOpen, wasOpen) {
	  this.onOpenChanged(isOpen, wasOpen);
	})], MenuSurfaceBase.prototype, "open", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuSurfaceBase.prototype, "stayOpenOnBodyClick", void 0);
	__decorate([t$3(), observer(function (value) {
	  if (this.mdcFoundation) {
	    if (value) {
	      this.mdcFoundation.setAnchorCorner(value);
	    } else {
	      this.mdcFoundation.setAnchorCorner(value);
	    }
	  }
	})], MenuSurfaceBase.prototype, "bitwiseCorner", void 0);
	__decorate([n$6({
	  type: String
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    const isValidValue = value === 'START' || value === 'END';
	    const isFirstTimeSet = this.previousMenuCorner === null;
	    const cornerChanged = !isFirstTimeSet && value !== this.previousMenuCorner;
	    const initiallySetToEnd = isFirstTimeSet && value === 'END';
	    if (isValidValue && (cornerChanged || initiallySetToEnd)) {
	      this.bitwiseCorner = this.bitwiseCorner ^ CornerBit.RIGHT;
	      this.mdcFoundation.flipCornerHorizontally();
	      this.previousMenuCorner = value;
	    }
	  }
	})], MenuSurfaceBase.prototype, "menuCorner", void 0);
	__decorate([n$6({
	  type: String
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    if (value) {
	      let newCorner = stringToCorner[value];
	      if (this.menuCorner === 'END') {
	        newCorner = newCorner ^ CornerBit.RIGHT;
	      }
	      this.bitwiseCorner = newCorner;
	    }
	  }
	})], MenuSurfaceBase.prototype, "corner", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleTop", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleLeft", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleRight", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleBottom", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleMaxHeight", void 0);
	__decorate([t$3()], MenuSurfaceBase.prototype, "styleTransformOrigin", void 0);

	var _templateObject$6;
	const styles$3 = i$3(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteral([".mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;transition:opacity .03s linear,transform .12s cubic-bezier(0, 0, 0.2, 1),height 250ms cubic-bezier(0, 0, 0.2, 1);box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12);background-color:#fff;background-color:var(--mdc-theme-surface, #fff);color:#000;color:var(--mdc-theme-on-surface, #000);border-radius:4px;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0;transition:opacity .075s linear}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}:host(:not([open])){display:none}.mdc-menu-surface{z-index:8;z-index:var(--mdc-menu-z-index, 8);min-width:112px;min-width:var(--mdc-menu-min-width, 112px)}"])));

	/**
	 * @license
	 * Copyright 2020 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let MenuSurface = class MenuSurface extends MenuSurfaceBase {};
	MenuSurface.styles = [styles$3];
	MenuSurface = __decorate([e$8('mwc-menu-surface')], MenuSurface);

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var cssClasses = {
	  MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
	  MENU_SELECTION_GROUP: 'mdc-menu__selection-group',
	  ROOT: 'mdc-menu'
	};
	var strings = {
	  ARIA_CHECKED_ATTR: 'aria-checked',
	  ARIA_DISABLED_ATTR: 'aria-disabled',
	  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
	  LIST_SELECTOR: '.mdc-list,.mdc-deprecated-list',
	  SELECTED_EVENT: 'MDCMenu:selected',
	  SKIP_RESTORE_FOCUS: 'data-menu-item-skip-restore-focus'
	};
	var numbers = {
	  FOCUS_ROOT_INDEX: -1
	};
	var DefaultFocusState;
	(function (DefaultFocusState) {
	  DefaultFocusState[DefaultFocusState["NONE"] = 0] = "NONE";
	  DefaultFocusState[DefaultFocusState["LIST_ROOT"] = 1] = "LIST_ROOT";
	  DefaultFocusState[DefaultFocusState["FIRST_ITEM"] = 2] = "FIRST_ITEM";
	  DefaultFocusState[DefaultFocusState["LAST_ITEM"] = 3] = "LAST_ITEM";
	})(DefaultFocusState || (DefaultFocusState = {}));

	/**
	 * @license
	 * Copyright 2016 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCFoundation = /** @class */function () {
	  function MDCFoundation(adapter) {
	    if (adapter === void 0) {
	      adapter = {};
	    }
	    this.adapter = adapter;
	  }
	  Object.defineProperty(MDCFoundation, "cssClasses", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports every
	      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "strings", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "numbers", {
	    get: function () {
	      // Classes extending MDCFoundation should implement this method to return an object which exports all
	      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCFoundation, "defaultAdapter", {
	    get: function () {
	      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
	      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
	      // validation.
	      return {};
	    },
	    enumerable: false,
	    configurable: true
	  });
	  MDCFoundation.prototype.init = function () {
	    // Subclasses should override this method to perform initialization routines (registering events, etc.)
	  };
	  MDCFoundation.prototype.destroy = function () {
	    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
	  };
	  return MDCFoundation;
	}();

	/**
	 * @license
	 * Copyright 2018 Google Inc.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 */
	var MDCMenuFoundation = /** @class */function (_super) {
	  __extends(MDCMenuFoundation, _super);
	  function MDCMenuFoundation(adapter) {
	    var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation.defaultAdapter), adapter)) || this;
	    _this.closeAnimationEndTimerId = 0;
	    _this.defaultFocusState = DefaultFocusState.LIST_ROOT;
	    _this.selectedIndex = -1;
	    return _this;
	  }
	  Object.defineProperty(MDCMenuFoundation, "cssClasses", {
	    get: function () {
	      return cssClasses;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuFoundation, "strings", {
	    get: function () {
	      return strings;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuFoundation, "numbers", {
	    get: function () {
	      return numbers;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(MDCMenuFoundation, "defaultAdapter", {
	    /**
	     * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
	     */
	    get: function () {
	      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
	      return {
	        addClassToElementAtIndex: function () {
	          return undefined;
	        },
	        removeClassFromElementAtIndex: function () {
	          return undefined;
	        },
	        addAttributeToElementAtIndex: function () {
	          return undefined;
	        },
	        removeAttributeFromElementAtIndex: function () {
	          return undefined;
	        },
	        getAttributeFromElementAtIndex: function () {
	          return null;
	        },
	        elementContainsClass: function () {
	          return false;
	        },
	        closeSurface: function () {
	          return undefined;
	        },
	        getElementIndex: function () {
	          return -1;
	        },
	        notifySelected: function () {
	          return undefined;
	        },
	        getMenuItemCount: function () {
	          return 0;
	        },
	        focusItemAtIndex: function () {
	          return undefined;
	        },
	        focusListRoot: function () {
	          return undefined;
	        },
	        getSelectedSiblingOfItemAtIndex: function () {
	          return -1;
	        },
	        isSelectableItemAtIndex: function () {
	          return false;
	        }
	      };
	      // tslint:enable:object-literal-sort-keys
	    },

	    enumerable: false,
	    configurable: true
	  });
	  MDCMenuFoundation.prototype.destroy = function () {
	    if (this.closeAnimationEndTimerId) {
	      clearTimeout(this.closeAnimationEndTimerId);
	    }
	    this.adapter.closeSurface();
	  };
	  MDCMenuFoundation.prototype.handleKeydown = function (evt) {
	    var key = evt.key,
	      keyCode = evt.keyCode;
	    var isTab = key === 'Tab' || keyCode === 9;
	    if (isTab) {
	      this.adapter.closeSurface( /** skipRestoreFocus */true);
	    }
	  };
	  MDCMenuFoundation.prototype.handleItemAction = function (listItem) {
	    var _this = this;
	    var index = this.adapter.getElementIndex(listItem);
	    if (index < 0) {
	      return;
	    }
	    this.adapter.notifySelected({
	      index: index
	    });
	    var skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(index, strings.SKIP_RESTORE_FOCUS) === 'true';
	    this.adapter.closeSurface(skipRestoreFocus);
	    // Wait for the menu to close before adding/removing classes that affect styles.
	    this.closeAnimationEndTimerId = setTimeout(function () {
	      // Recompute the index in case the menu contents have changed.
	      var recomputedIndex = _this.adapter.getElementIndex(listItem);
	      if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
	        _this.setSelectedIndex(recomputedIndex);
	      }
	    }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
	  };
	  MDCMenuFoundation.prototype.handleMenuSurfaceOpened = function () {
	    switch (this.defaultFocusState) {
	      case DefaultFocusState.FIRST_ITEM:
	        this.adapter.focusItemAtIndex(0);
	        break;
	      case DefaultFocusState.LAST_ITEM:
	        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
	        break;
	      case DefaultFocusState.NONE:
	        // Do nothing.
	        break;
	      default:
	        this.adapter.focusListRoot();
	        break;
	    }
	  };
	  /**
	   * Sets default focus state where the menu should focus every time when menu
	   * is opened. Focuses the list root (`DefaultFocusState.LIST_ROOT`) element by
	   * default.
	   */
	  MDCMenuFoundation.prototype.setDefaultFocusState = function (focusState) {
	    this.defaultFocusState = focusState;
	  };
	  /** @return Index of the currently selected list item within the menu. */
	  MDCMenuFoundation.prototype.getSelectedIndex = function () {
	    return this.selectedIndex;
	  };
	  /**
	   * Selects the list item at `index` within the menu.
	   * @param index Index of list item within the menu.
	   */
	  MDCMenuFoundation.prototype.setSelectedIndex = function (index) {
	    this.validatedIndex(index);
	    if (!this.adapter.isSelectableItemAtIndex(index)) {
	      throw new Error('MDCMenuFoundation: No selection group at specified index.');
	    }
	    var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
	    if (prevSelectedIndex >= 0) {
	      this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings.ARIA_CHECKED_ATTR);
	      this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses.MENU_SELECTED_LIST_ITEM);
	    }
	    this.adapter.addClassToElementAtIndex(index, cssClasses.MENU_SELECTED_LIST_ITEM);
	    this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_CHECKED_ATTR, 'true');
	    this.selectedIndex = index;
	  };
	  /**
	   * Sets the enabled state to isEnabled for the menu item at the given index.
	   * @param index Index of the menu item
	   * @param isEnabled The desired enabled state of the menu item.
	   */
	  MDCMenuFoundation.prototype.setEnabled = function (index, isEnabled) {
	    this.validatedIndex(index);
	    if (isEnabled) {
	      this.adapter.removeClassFromElementAtIndex(index, cssClasses$2.LIST_ITEM_DISABLED_CLASS);
	      this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_DISABLED_ATTR, 'false');
	    } else {
	      this.adapter.addClassToElementAtIndex(index, cssClasses$2.LIST_ITEM_DISABLED_CLASS);
	      this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_DISABLED_ATTR, 'true');
	    }
	  };
	  MDCMenuFoundation.prototype.validatedIndex = function (index) {
	    var menuSize = this.adapter.getMenuItemCount();
	    var isIndexInRange = index >= 0 && index < menuSize;
	    if (!isIndexInRange) {
	      throw new Error('MDCMenuFoundation: No list item at specified index.');
	    }
	  };
	  return MDCMenuFoundation;
	}(MDCFoundation);
	// tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.
	var MDCMenuFoundation$1 = MDCMenuFoundation;

	var _templateObject$5, _templateObject2$2;
	/**
	 * @fires selected {SelectedDetail}
	 * @fires action {ActionDetail}
	 * @fires items-updated
	 * @fires opened
	 * @fires closed
	 */
	class MenuBase extends BaseElement {
	  constructor() {
	    super(...arguments);
	    this.mdcFoundationClass = MDCMenuFoundation$1;
	    this.listElement_ = null;
	    this.anchor = null;
	    this.open = false;
	    this.quick = false;
	    this.wrapFocus = false;
	    this.innerRole = 'menu';
	    this.innerAriaLabel = null;
	    this.corner = 'TOP_START';
	    this.x = null;
	    this.y = null;
	    this.absolute = false;
	    this.multi = false;
	    this.activatable = false;
	    this.fixed = false;
	    this.forceGroupSelection = false;
	    this.fullwidth = false;
	    this.menuCorner = 'START';
	    this.stayOpenOnBodyClick = false;
	    this.defaultFocus = 'LIST_ROOT';
	    this._listUpdateComplete = null;
	  }
	  get listElement() {
	    if (!this.listElement_) {
	      this.listElement_ = this.renderRoot.querySelector('mwc-list');
	      return this.listElement_;
	    }
	    return this.listElement_;
	  }
	  get items() {
	    const listElement = this.listElement;
	    if (listElement) {
	      return listElement.items;
	    }
	    return [];
	  }
	  get index() {
	    const listElement = this.listElement;
	    if (listElement) {
	      return listElement.index;
	    }
	    return -1;
	  }
	  get selected() {
	    const listElement = this.listElement;
	    if (listElement) {
	      return listElement.selected;
	    }
	    return null;
	  }
	  render() {
	    return this.renderSurface();
	  }
	  renderSurface() {
	    const classes = this.getSurfaceClasses();
	    return x(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteral(["\n      <mwc-menu-surface\n        ?hidden=", "\n        .anchor=", "\n        .open=", "\n        .quick=", "\n        .corner=", "\n        .x=", "\n        .y=", "\n        .absolute=", "\n        .fixed=", "\n        .fullwidth=", "\n        .menuCorner=", "\n        ?stayOpenOnBodyClick=", "\n        class=", "\n        @closed=", "\n        @opened=", "\n        @keydown=", ">\n      ", "\n    </mwc-menu-surface>"])), !this.open, this.anchor, this.open, this.quick, this.corner, this.x, this.y, this.absolute, this.fixed, this.fullwidth, this.menuCorner, this.stayOpenOnBodyClick, o$1(classes), this.onClosed, this.onOpened, this.onKeydown, this.renderList());
	  }
	  getSurfaceClasses() {
	    return {
	      'mdc-menu': true,
	      'mdc-menu-surface': true
	    };
	  }
	  renderList() {
	    const itemRoles = this.innerRole === 'menu' ? 'menuitem' : 'option';
	    const classes = this.renderListClasses();
	    return x(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteral(["\n      <mwc-list\n          rootTabbable\n          .innerAriaLabel=", "\n          .innerRole=", "\n          .multi=", "\n          class=", "\n          .itemRoles=", "\n          .wrapFocus=", "\n          .activatable=", "\n          @action=", ">\n        <slot></slot>\n      </mwc-list>"])), this.innerAriaLabel, this.innerRole, this.multi, o$1(classes), itemRoles, this.wrapFocus, this.activatable, this.onAction);
	  }
	  renderListClasses() {
	    return {
	      'mdc-deprecated-list': true
	    };
	  }
	  createAdapter() {
	    return {
	      addClassToElementAtIndex: (index, className) => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return;
	        }
	        const element = listElement.items[index];
	        if (!element) {
	          return;
	        }
	        if (className === 'mdc-menu-item--selected') {
	          if (this.forceGroupSelection && !element.selected) {
	            listElement.toggle(index, true);
	          }
	        } else {
	          element.classList.add(className);
	        }
	      },
	      removeClassFromElementAtIndex: (index, className) => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return;
	        }
	        const element = listElement.items[index];
	        if (!element) {
	          return;
	        }
	        if (className === 'mdc-menu-item--selected') {
	          if (element.selected) {
	            listElement.toggle(index, false);
	          }
	        } else {
	          element.classList.remove(className);
	        }
	      },
	      addAttributeToElementAtIndex: (index, attr, value) => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return;
	        }
	        const element = listElement.items[index];
	        if (!element) {
	          return;
	        }
	        element.setAttribute(attr, value);
	      },
	      removeAttributeFromElementAtIndex: (index, attr) => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return;
	        }
	        const element = listElement.items[index];
	        if (!element) {
	          return;
	        }
	        element.removeAttribute(attr);
	      },
	      getAttributeFromElementAtIndex: (index, attr) => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return null;
	        }
	        const element = listElement.items[index];
	        if (!element) {
	          return null;
	        }
	        return element.getAttribute(attr);
	      },
	      elementContainsClass: (element, className) => element.classList.contains(className),
	      closeSurface: () => {
	        this.open = false;
	      },
	      getElementIndex: element => {
	        const listElement = this.listElement;
	        if (listElement) {
	          return listElement.items.indexOf(element);
	        }
	        return -1;
	      },
	      notifySelected: () => {},
	      getMenuItemCount: () => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return 0;
	        }
	        return listElement.items.length;
	      },
	      focusItemAtIndex: index => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return;
	        }
	        const element = listElement.items[index];
	        if (element) {
	          element.focus();
	        }
	      },
	      focusListRoot: () => {
	        if (this.listElement) {
	          this.listElement.focus();
	        }
	      },
	      getSelectedSiblingOfItemAtIndex: index => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return -1;
	        }
	        const elementAtIndex = listElement.items[index];
	        if (!elementAtIndex || !elementAtIndex.group) {
	          return -1;
	        }
	        for (let i = 0; i < listElement.items.length; i++) {
	          if (i === index) {
	            continue;
	          }
	          const current = listElement.items[i];
	          if (current.selected && current.group === elementAtIndex.group) {
	            return i;
	          }
	        }
	        return -1;
	      },
	      isSelectableItemAtIndex: index => {
	        const listElement = this.listElement;
	        if (!listElement) {
	          return false;
	        }
	        const elementAtIndex = listElement.items[index];
	        if (!elementAtIndex) {
	          return false;
	        }
	        return elementAtIndex.hasAttribute('group');
	      }
	    };
	  }
	  onKeydown(evt) {
	    if (this.mdcFoundation) {
	      this.mdcFoundation.handleKeydown(evt);
	    }
	  }
	  onAction(evt) {
	    const listElement = this.listElement;
	    if (this.mdcFoundation && listElement) {
	      const index = evt.detail.index;
	      const el = listElement.items[index];
	      if (el) {
	        this.mdcFoundation.handleItemAction(el);
	      }
	    }
	  }
	  onOpened() {
	    this.open = true;
	    if (this.mdcFoundation) {
	      this.mdcFoundation.handleMenuSurfaceOpened();
	    }
	  }
	  onClosed() {
	    this.open = false;
	  }
	  // tslint:disable:ban-ts-ignore
	  async getUpdateComplete() {
	    await this._listUpdateComplete;
	    // @ts-ignore
	    const result = await super.getUpdateComplete();
	    return result;
	  }
	  // tslint:enable:ban-ts-ignore
	  async firstUpdated() {
	    super.firstUpdated();
	    const listElement = this.listElement;
	    if (listElement) {
	      this._listUpdateComplete = listElement.updateComplete;
	      await this._listUpdateComplete;
	    }
	  }
	  select(index) {
	    const listElement = this.listElement;
	    if (listElement) {
	      listElement.select(index);
	    }
	  }
	  close() {
	    this.open = false;
	  }
	  show() {
	    this.open = true;
	  }
	  getFocusedItemIndex() {
	    const listElement = this.listElement;
	    if (listElement) {
	      return listElement.getFocusedItemIndex();
	    }
	    return -1;
	  }
	  focusItemAtIndex(index) {
	    const listElement = this.listElement;
	    if (listElement) {
	      listElement.focusItemAtIndex(index);
	    }
	  }
	  layout() {
	    let updateItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	    const listElement = this.listElement;
	    if (listElement) {
	      listElement.layout(updateItems);
	    }
	  }
	}
	__decorate([i$4('.mdc-menu')], MenuBase.prototype, "mdcRoot", void 0);
	__decorate([i$4('slot')], MenuBase.prototype, "slotElement", void 0);
	__decorate([n$6({
	  type: Object
	})], MenuBase.prototype, "anchor", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], MenuBase.prototype, "open", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "quick", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "wrapFocus", void 0);
	__decorate([n$6({
	  type: String
	})], MenuBase.prototype, "innerRole", void 0);
	__decorate([n$6({
	  type: String
	})], MenuBase.prototype, "innerAriaLabel", void 0);
	__decorate([n$6({
	  type: String
	})], MenuBase.prototype, "corner", void 0);
	__decorate([n$6({
	  type: Number
	})], MenuBase.prototype, "x", void 0);
	__decorate([n$6({
	  type: Number
	})], MenuBase.prototype, "y", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "absolute", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "multi", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "activatable", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "fixed", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "forceGroupSelection", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "fullwidth", void 0);
	__decorate([n$6({
	  type: String
	})], MenuBase.prototype, "menuCorner", void 0);
	__decorate([n$6({
	  type: Boolean
	})], MenuBase.prototype, "stayOpenOnBodyClick", void 0);
	__decorate([n$6({
	  type: String
	}), observer(function (value) {
	  if (this.mdcFoundation) {
	    this.mdcFoundation.setDefaultFocusState(DefaultFocusState[value]);
	  }
	})], MenuBase.prototype, "defaultFocus", void 0);

	var _templateObject$4;
	const styles$2 = i$3(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteral(["mwc-list ::slotted([mwc-list-item]:not([twoline])),mwc-list ::slotted([noninteractive]:not([twoline])){height:var(--mdc-menu-item-height, 48px)}"])));

	/**
	 * @license
	 * Copyright 2020 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	let Menu = class Menu extends MenuBase {};
	Menu.styles = [styles$2];
	Menu = __decorate([e$8('mwc-menu')], Menu);

	const file$8 = "src/components/Navbar.svelte";
	function create_fragment$9(ctx) {
	  let mwc_drawer;
	  let span0;
	  let t0_value = /*presets*/ctx[0].title + "";
	  let t0;
	  let t1;
	  let span1;
	  let t3;
	  let span2;
	  let t4_value = /*presets*/ctx[0].subtitle + "";
	  let t4;
	  let t5;
	  let div0;
	  let mwc_list;
	  let li0;
	  let t6;
	  let a0;
	  let mwc_list_item0;
	  let span3;
	  let t8;
	  let mwc_icon0;
	  let homebutton;
	  let t9;
	  let li1;
	  let t10;
	  let a1;
	  let mwc_list_item1;
	  let span4;
	  let t12;
	  let mwc_icon1;
	  let headphone0;
	  let t13;
	  let li2;
	  let t14;
	  let a2;
	  let mwc_list_item2;
	  let span5;
	  let t16;
	  let mwc_icon2;
	  let headphone1;
	  let t17;
	  let li3;
	  let t18;
	  let a3;
	  let mwc_list_item3;
	  let span6;
	  let t20;
	  let mwc_icon3;
	  let help0;
	  let t21;
	  let li4;
	  let t22;
	  let div7;
	  let mwc_top_app_bar_fixed;
	  let mwc_icon_button0;
	  let menubutton;
	  let t23;
	  let a4;
	  let t24;
	  let t25_value = /*presets*/ctx[0].title + "";
	  let t25;
	  let t26;
	  let t27;
	  let mwc_icon_button1;
	  let a5;
	  let help1;
	  let t28;
	  let mwc_icon_button2;
	  let morevert;
	  let t29;
	  let mwc_menu;
	  let div3;
	  let accountbalance;
	  let t30;
	  let span7;
	  let t31;
	  let t32_value = /*presets*/ctx[0].title + "";
	  let t32;
	  let t33;
	  let t34;
	  let div1;
	  let t36;
	  let div2;
	  let t37_value = /*presets*/ctx[0].subtitle + "";
	  let t37;
	  let t38;
	  let li5;
	  let t39;
	  let div5;
	  let div4;
	  let t41;
	  let li6;
	  let t42;
	  let div6;
	  let h4;
	  let a6;
	  let span8;
	  let t44;
	  let span9;
	  let github;
	  let current;
	  let mounted;
	  let dispose;
	  homebutton = new Home$1({
	    props: {
	      size: "1.6em",
	      color: "#6ec7ff"
	    },
	    $$inline: true
	  });
	  headphone0 = new Headphone({
	    props: {
	      size: "1.6em",
	      color: "#d9f0bc"
	    },
	    $$inline: true
	  });
	  headphone1 = new Headphone({
	    props: {
	      size: "1.6em",
	      color: "#d9f0bc"
	    },
	    $$inline: true
	  });
	  help0 = new Help$1({
	    props: {
	      size: "1.6em",
	      color: "#ff6883"
	    },
	    $$inline: true
	  });
	  menubutton = new Menu$1({
	    $$inline: true
	  });
	  help1 = new Help$1({
	    props: {
	      color: "#fff"
	    },
	    $$inline: true
	  });
	  morevert = new More_vert({
	    props: {
	      size: "1.2em"
	    },
	    $$inline: true
	  });
	  accountbalance = new Account_balance({
	    props: {
	      size: "1.4em"
	    },
	    $$inline: true
	  });
	  github = new Github({
	    props: {
	      size: "2em"
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      mwc_drawer = element("mwc-drawer");
	      span0 = element("span");
	      t0 = text(t0_value);
	      t1 = space();
	      span1 = element("span");
	      span1.textContent = "åç´ç·¨ / å¿ç¨ç·¨";
	      t3 = space();
	      span2 = element("span");
	      t4 = text(t4_value);
	      t5 = space();
	      div0 = element("div");
	      mwc_list = element("mwc-list");
	      li0 = element("li");
	      t6 = space();
	      a0 = element("a");
	      mwc_list_item0 = element("mwc-list-item");
	      span3 = element("span");
	      span3.textContent = "HOME";
	      t8 = space();
	      mwc_icon0 = element("mwc-icon");
	      create_component(homebutton.$$.fragment);
	      t9 = space();
	      li1 = element("li");
	      t10 = space();
	      a1 = element("a");
	      mwc_list_item1 = element("mwc-list-item");
	      span4 = element("span");
	      span4.textContent = "åç´ç·¨";
	      t12 = space();
	      mwc_icon1 = element("mwc-icon");
	      create_component(headphone0.$$.fragment);
	      t13 = space();
	      li2 = element("li");
	      t14 = space();
	      a2 = element("a");
	      mwc_list_item2 = element("mwc-list-item");
	      span5 = element("span");
	      span5.textContent = "å¿ç¨ç·¨";
	      t16 = space();
	      mwc_icon2 = element("mwc-icon");
	      create_component(headphone1.$$.fragment);
	      t17 = space();
	      li3 = element("li");
	      t18 = space();
	      a3 = element("a");
	      mwc_list_item3 = element("mwc-list-item");
	      span6 = element("span");
	      span6.textContent = "è¦è´æ¹æ³";
	      t20 = space();
	      mwc_icon3 = element("mwc-icon");
	      create_component(help0.$$.fragment);
	      t21 = space();
	      li4 = element("li");
	      t22 = space();
	      div7 = element("div");
	      mwc_top_app_bar_fixed = element("mwc-top-app-bar-fixed");
	      mwc_icon_button0 = element("mwc-icon-button");
	      create_component(menubutton.$$.fragment);
	      t23 = space();
	      a4 = element("a");
	      t24 = text("ã");
	      t25 = text(t25_value);
	      t26 = text("ã");
	      t27 = space();
	      mwc_icon_button1 = element("mwc-icon-button");
	      a5 = element("a");
	      create_component(help1.$$.fragment);
	      t28 = space();
	      mwc_icon_button2 = element("mwc-icon-button");
	      create_component(morevert.$$.fragment);
	      t29 = space();
	      mwc_menu = element("mwc-menu");
	      div3 = element("div");
	      create_component(accountbalance.$$.fragment);
	      t30 = space();
	      span7 = element("span");
	      t31 = text("ã");
	      t32 = text(t32_value);
	      t33 = text("ã");
	      t34 = space();
	      div1 = element("div");
	      div1.textContent = "Â åç´ç·¨ / å¿ç¨ç·¨";
	      t36 = space();
	      div2 = element("div");
	      t37 = text(t37_value);
	      t38 = space();
	      li5 = element("li");
	      t39 = space();
	      div5 = element("div");
	      div4 = element("div");
	      div4.textContent = "å¯¾å¿ï¼Android 4.4-, IE11";
	      t41 = space();
	      li6 = element("li");
	      t42 = space();
	      div6 = element("div");
	      h4 = element("h4");
	      a6 = element("a");
	      span8 = element("span");
	      span8.textContent = "ru_museum";
	      t44 = space();
	      span9 = element("span");
	      create_component(github.$$.fragment);
	      attr_dev(span0, "slot", "title");
	      attr_dev(span0, "class", "title svelte-91d6g1");
	      add_location(span0, file$8, 64, 4, 2153);
	      attr_dev(span1, "slot", "title");
	      attr_dev(span1, "class", "subtitle svelte-91d6g1");
	      add_location(span1, file$8, 65, 4, 2213);
	      attr_dev(span2, "slot", "subtitle");
	      attr_dev(span2, "class", "ssubtitle svelte-91d6g1");
	      add_location(span2, file$8, 66, 4, 2270);
	      attr_dev(li0, "divider", "");
	      attr_dev(li0, "role", "separator");
	      add_location(li0, file$8, 73, 12, 2518);
	      add_location(span3, file$8, 76, 16, 2646);
	      set_custom_element_data(mwc_icon0, "slot", "graphic");
	      add_location(mwc_icon0, file$8, 77, 16, 2680);
	      set_custom_element_data(mwc_list_item0, "graphic", "avatar");
	      add_location(mwc_list_item0, file$8, 75, 14, 2597);
	      attr_dev(a0, "href", "#/home");
	      add_location(a0, file$8, 74, 12, 2565);
	      attr_dev(li1, "divider", "");
	      attr_dev(li1, "padded", "");
	      attr_dev(li1, "role", "separator");
	      add_location(li1, file$8, 82, 12, 2856);
	      add_location(span4, file$8, 85, 16, 2994);
	      set_custom_element_data(mwc_icon1, "slot", "graphic");
	      add_location(mwc_icon1, file$8, 86, 16, 3027);
	      set_custom_element_data(mwc_list_item1, "graphic", "avatar");
	      add_location(mwc_list_item1, file$8, 84, 14, 2945);
	      attr_dev(a1, "href", "#/shokyu");
	      add_location(a1, file$8, 83, 12, 2911);
	      attr_dev(li2, "divider", "");
	      attr_dev(li2, "padded", "");
	      attr_dev(li2, "role", "separator");
	      add_location(li2, file$8, 91, 12, 3202);
	      add_location(span5, file$8, 94, 16, 3339);
	      set_custom_element_data(mwc_icon2, "slot", "graphic");
	      add_location(mwc_icon2, file$8, 95, 16, 3372);
	      set_custom_element_data(mwc_list_item2, "graphic", "avatar");
	      add_location(mwc_list_item2, file$8, 93, 14, 3290);
	      attr_dev(a2, "href", "#/ouyou");
	      add_location(a2, file$8, 92, 12, 3257);
	      attr_dev(li3, "divider", "");
	      attr_dev(li3, "padded", "");
	      attr_dev(li3, "role", "separator");
	      add_location(li3, file$8, 100, 12, 3547);
	      add_location(span6, file$8, 103, 16, 3682);
	      set_custom_element_data(mwc_icon3, "slot", "graphic");
	      add_location(mwc_icon3, file$8, 104, 16, 3716);
	      set_custom_element_data(mwc_list_item3, "graphic", "avatar");
	      add_location(mwc_list_item3, file$8, 102, 14, 3633);
	      attr_dev(a3, "href", "#/help");
	      add_location(a3, file$8, 101, 12, 3601);
	      attr_dev(li4, "divider", "");
	      attr_dev(li4, "role", "separator");
	      add_location(li4, file$8, 109, 12, 3886);
	      add_location(mwc_list, file$8, 72, 9, 2495);
	      attr_dev(div0, "tabindex", "0");
	      attr_dev(div0, "role", "button");
	      attr_dev(div0, "aria-pressed", "false");
	      add_location(div0, file$8, 67, 4, 2340);
	      set_custom_element_data(mwc_icon_button0, "slot", "navigationIcon");
	      add_location(mwc_icon_button0, file$8, 115, 12, 4025);
	      attr_dev(a4, "href", "#/home");
	      set_style(a4, "color", "white");
	      attr_dev(a4, "slot", "title");
	      add_location(a4, file$8, 118, 12, 4137);
	      attr_dev(a5, "href", "#/help");
	      add_location(a5, file$8, 123, 14, 4316);
	      set_custom_element_data(mwc_icon_button1, "slot", "actionItems");
	      add_location(mwc_icon_button1, file$8, 122, 12, 4265);
	      set_custom_element_data(mwc_icon_button2, "slot", "actionItems");
	      set_custom_element_data(mwc_icon_button2, "id", "button");
	      set_custom_element_data(mwc_icon_button2, "label", "Open Menu");
	      add_location(mwc_icon_button2, file$8, 127, 12, 4436);
	      attr_dev(span7, "class", "fs1-6 svelte-91d6g1");
	      add_location(span7, file$8, 135, 20, 4803);
	      attr_dev(div1, "slot", "title");
	      attr_dev(div1, "class", "subtitle svelte-91d6g1");
	      add_location(div1, file$8, 136, 20, 4868);
	      attr_dev(div2, "class", "subtitle2 svelte-91d6g1");
	      add_location(div2, file$8, 137, 20, 4945);
	      set_style(div3, "padding", "20px");
	      add_location(div3, file$8, 133, 16, 4703);
	      attr_dev(li5, "divider", "");
	      attr_dev(li5, "role", "separator");
	      add_location(li5, file$8, 139, 16, 5036);
	      attr_dev(div4, "class", "");
	      add_location(div4, file$8, 141, 18, 5134);
	      set_style(div5, "padding", "20px");
	      add_location(div5, file$8, 140, 16, 5088);
	      attr_dev(li6, "divider", "");
	      attr_dev(li6, "role", "separator");
	      add_location(li6, file$8, 147, 16, 5272);
	      set_style(span8, "vertical-align", "top");
	      add_location(span8, file$8, 155, 22, 5590);
	      set_style(span9, "vertical-align", "middle");
	      add_location(span9, file$8, 158, 22, 5711);
	      attr_dev(a6, "href", "https://github.com/ru-museum");
	      attr_dev(a6, "target", "_blank");
	      attr_dev(a6, "rel", "noreferrer");
	      set_style(a6, "color", "#b9cbff");
	      add_location(a6, file$8, 151, 20, 5401);
	      add_location(h4, file$8, 150, 18, 5376);
	      set_style(div6, "text-align", "center");
	      add_location(div6, file$8, 149, 16, 5325);
	      set_custom_element_data(mwc_menu, "fixed", "");
	      set_custom_element_data(mwc_menu, "id", "menu");
	      set_custom_element_data(mwc_menu, "x", "20");
	      set_custom_element_data(mwc_menu, "y", "6");
	      set_custom_element_data(mwc_menu, "class", "svelte-91d6g1");
	      add_location(mwc_menu, file$8, 132, 14, 4647);
	      add_location(mwc_top_app_bar_fixed, file$8, 114, 8, 3989);
	      attr_dev(div7, "slot", "appContent");
	      add_location(div7, file$8, 113, 4, 3957);
	      set_custom_element_data(mwc_drawer, "hasheader", "");
	      set_custom_element_data(mwc_drawer, "type", "modal");
	      set_style(mwc_drawer, "height", "60px");
	      add_location(mwc_drawer, file$8, 63, 0, 2092);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, mwc_drawer, anchor);
	      append_dev(mwc_drawer, span0);
	      append_dev(span0, t0);
	      append_dev(mwc_drawer, t1);
	      append_dev(mwc_drawer, span1);
	      append_dev(mwc_drawer, t3);
	      append_dev(mwc_drawer, span2);
	      append_dev(span2, t4);
	      append_dev(mwc_drawer, t5);
	      append_dev(mwc_drawer, div0);
	      append_dev(div0, mwc_list);
	      append_dev(mwc_list, li0);
	      append_dev(mwc_list, t6);
	      append_dev(mwc_list, a0);
	      append_dev(a0, mwc_list_item0);
	      append_dev(mwc_list_item0, span3);
	      append_dev(mwc_list_item0, t8);
	      append_dev(mwc_list_item0, mwc_icon0);
	      mount_component(homebutton, mwc_icon0, null);
	      append_dev(mwc_list, t9);
	      append_dev(mwc_list, li1);
	      append_dev(mwc_list, t10);
	      append_dev(mwc_list, a1);
	      append_dev(a1, mwc_list_item1);
	      append_dev(mwc_list_item1, span4);
	      append_dev(mwc_list_item1, t12);
	      append_dev(mwc_list_item1, mwc_icon1);
	      mount_component(headphone0, mwc_icon1, null);
	      append_dev(mwc_list, t13);
	      append_dev(mwc_list, li2);
	      append_dev(mwc_list, t14);
	      append_dev(mwc_list, a2);
	      append_dev(a2, mwc_list_item2);
	      append_dev(mwc_list_item2, span5);
	      append_dev(mwc_list_item2, t16);
	      append_dev(mwc_list_item2, mwc_icon2);
	      mount_component(headphone1, mwc_icon2, null);
	      append_dev(mwc_list, t17);
	      append_dev(mwc_list, li3);
	      append_dev(mwc_list, t18);
	      append_dev(mwc_list, a3);
	      append_dev(a3, mwc_list_item3);
	      append_dev(mwc_list_item3, span6);
	      append_dev(mwc_list_item3, t20);
	      append_dev(mwc_list_item3, mwc_icon3);
	      mount_component(help0, mwc_icon3, null);
	      append_dev(mwc_list, t21);
	      append_dev(mwc_list, li4);
	      append_dev(mwc_drawer, t22);
	      append_dev(mwc_drawer, div7);
	      append_dev(div7, mwc_top_app_bar_fixed);
	      append_dev(mwc_top_app_bar_fixed, mwc_icon_button0);
	      mount_component(menubutton, mwc_icon_button0, null);
	      append_dev(mwc_top_app_bar_fixed, t23);
	      append_dev(mwc_top_app_bar_fixed, a4);
	      append_dev(a4, t24);
	      append_dev(a4, t25);
	      append_dev(a4, t26);
	      append_dev(mwc_top_app_bar_fixed, t27);
	      append_dev(mwc_top_app_bar_fixed, mwc_icon_button1);
	      append_dev(mwc_icon_button1, a5);
	      mount_component(help1, a5, null);
	      append_dev(mwc_top_app_bar_fixed, t28);
	      append_dev(mwc_top_app_bar_fixed, mwc_icon_button2);
	      mount_component(morevert, mwc_icon_button2, null);
	      append_dev(mwc_top_app_bar_fixed, t29);
	      append_dev(mwc_top_app_bar_fixed, mwc_menu);
	      append_dev(mwc_menu, div3);
	      mount_component(accountbalance, div3, null);
	      append_dev(div3, t30);
	      append_dev(div3, span7);
	      append_dev(span7, t31);
	      append_dev(span7, t32);
	      append_dev(span7, t33);
	      append_dev(div3, t34);
	      append_dev(div3, div1);
	      append_dev(div3, t36);
	      append_dev(div3, div2);
	      append_dev(div2, t37);
	      append_dev(mwc_menu, t38);
	      append_dev(mwc_menu, li5);
	      append_dev(mwc_menu, t39);
	      append_dev(mwc_menu, div5);
	      append_dev(div5, div4);
	      append_dev(mwc_menu, t41);
	      append_dev(mwc_menu, li6);
	      append_dev(mwc_menu, t42);
	      append_dev(mwc_menu, div6);
	      append_dev(div6, h4);
	      append_dev(h4, a6);
	      append_dev(a6, span8);
	      append_dev(a6, t44);
	      append_dev(a6, span9);
	      mount_component(github, span9, null);
	      current = true;
	      if (!mounted) {
	        dispose = [listen_dev(div0, "click", /*click_handler*/ctx[3], false, false, false, false), listen_dev(div0, "keydown", /*keydown_handler*/ctx[2], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if ((!current || dirty & /*presets*/1) && t0_value !== (t0_value = /*presets*/ctx[0].title + "")) set_data_dev(t0, t0_value);
	      if ((!current || dirty & /*presets*/1) && t4_value !== (t4_value = /*presets*/ctx[0].subtitle + "")) set_data_dev(t4, t4_value);
	      if ((!current || dirty & /*presets*/1) && t25_value !== (t25_value = /*presets*/ctx[0].title + "")) set_data_dev(t25, t25_value);
	      if ((!current || dirty & /*presets*/1) && t32_value !== (t32_value = /*presets*/ctx[0].title + "")) set_data_dev(t32, t32_value);
	      if ((!current || dirty & /*presets*/1) && t37_value !== (t37_value = /*presets*/ctx[0].subtitle + "")) set_data_dev(t37, t37_value);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(homebutton.$$.fragment, local);
	      transition_in(headphone0.$$.fragment, local);
	      transition_in(headphone1.$$.fragment, local);
	      transition_in(help0.$$.fragment, local);
	      transition_in(menubutton.$$.fragment, local);
	      transition_in(help1.$$.fragment, local);
	      transition_in(morevert.$$.fragment, local);
	      transition_in(accountbalance.$$.fragment, local);
	      transition_in(github.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(homebutton.$$.fragment, local);
	      transition_out(headphone0.$$.fragment, local);
	      transition_out(headphone1.$$.fragment, local);
	      transition_out(help0.$$.fragment, local);
	      transition_out(menubutton.$$.fragment, local);
	      transition_out(help1.$$.fragment, local);
	      transition_out(morevert.$$.fragment, local);
	      transition_out(accountbalance.$$.fragment, local);
	      transition_out(github.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(mwc_drawer);
	      }
	      destroy_component(homebutton);
	      destroy_component(headphone0);
	      destroy_component(headphone1);
	      destroy_component(help0);
	      destroy_component(menubutton);
	      destroy_component(help1);
	      destroy_component(morevert);
	      destroy_component(accountbalance);
	      destroy_component(github);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$9.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$9($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Navbar', slots, []);
	  let {
	    presets
	  } = $$props;
	  let drawer;

	  // import "@material/mwc-menu "
	  // import "@material/mwc-"
	  // import "@material/mwc-"
	  onMount(() => {
	    drawer = document.getElementsByTagName('mwc-drawer')[0];
	    if (drawer) {
	      const container = drawer.parentNode;
	      container.addEventListener('MDCTopAppBar:nav', () => {
	        drawer.open = !drawer.open;
	      });
	    }

	    // anchor must share a parent with menu that is `position: relative`
	    menu.anchor = button;
	    button.addEventListener('click', function (e) {
	      menu.open = true;
	    }); // alternatively you can use menu.show();
	  });

	  // DRAWER ãéãã
	  function closeDrawer() {
	    drawer.open = !drawer.open;
	  }
	  $$self.$$.on_mount.push(function () {
	    if (presets === undefined && !('presets' in $$props || $$self.$$.bound[$$self.$$.props['presets']])) {
	      console.warn("<Navbar> was created without expected prop 'presets'");
	    }
	  });
	  const writable_props = ['presets'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Navbar> was created with unknown prop '".concat(key, "'"));
	  });
	  function keydown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  const click_handler = () => closeDrawer();
	  $$self.$$set = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	  };
	  $$self.$capture_state = () => ({
	    presets,
	    onMount,
	    drawer,
	    AccountBalance: Account_balance,
	    AddBox: Add_box,
	    AddCircle: Add_circle,
	    Apps,
	    ArrowBack: Arrow_back,
	    ArrowCircleUp: Arrow_circle_up,
	    ArrowDropDown: Arrow_drop_down,
	    ArrowDownward: Arrow_downward,
	    ArrowDropUp: Arrow_drop_up,
	    ArrowForward: Arrow_forward,
	    ArrowRight: Arrow_right,
	    ArrowUpward: Arrow_upward,
	    Article,
	    Bookmark: Bookmark_black,
	    Build,
	    CalendarToday: Calendar_today,
	    Cancel,
	    CancelPresentation: Cancel_presentation,
	    CheckCircle: Check_circle,
	    ChevronLeft: Chevron_left,
	    ChevronRight: Chevron_right,
	    Circle,
	    Close,
	    ContentCopy: Content_copy,
	    DoubleArrow: Double_arrow,
	    Download,
	    DownloadWhite: Download_white,
	    Drafts,
	    Edit,
	    ExpandLess: Expand_less,
	    ExpandMore: Expand_more,
	    FileText: File_text,
	    FilePdf: File_pdf,
	    FilePdfFill: File_pdf_fill,
	    FirstPage: First_page,
	    Folder,
	    FolderOpen: Folder_open,
	    GitHub: Github,
	    Headphone,
	    Help: Help$1,
	    HomeButton: Home$1,
	    Inbox,
	    Info,
	    Keyboard,
	    KeyboardArrowUp: Keyboard_arrow_up,
	    LastPage: Last_page,
	    Launch,
	    MailOutline: Mail_outline,
	    MenuButton: Menu$1,
	    MoreVert: More_vert,
	    OpenInNew: Open_in_new,
	    Person,
	    PictureAsPdf: Picture_as_pdf,
	    PlayCircleFilled: Play_circle_filled,
	    Print,
	    PrintWhite: Print_white,
	    RemoveCircle: Remove_circle,
	    Reply,
	    Settings,
	    Send,
	    Share,
	    ShoppingBasket: Shopping_basket,
	    ShoppingCart: Shopping_cart,
	    SkipNext: Skip_next,
	    SkipPrevious: Skip_previous,
	    Source,
	    Spinner,
	    Star,
	    Stop: Stop_black,
	    Storage,
	    DirArrowRight: Subdirectory_arrow_right,
	    YouTube: Youtube,
	    ViewList: View_list,
	    XCircleFill: X_circle_fill,
	    closeDrawer
	  });
	  $$self.$inject_state = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	    if ('drawer' in $$props) drawer = $$props.drawer;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [presets, closeDrawer, keydown_handler, click_handler];
	}
	class Navbar extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$9, create_fragment$9, safe_not_equal, {
	      presets: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Navbar",
	      options,
	      id: create_fragment$9.name
	    });
	  }
	  get presets() {
	    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set presets(value) {
	    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	/* src/components/Footer.svelte generated by Svelte v4.2.1 */
	const file$7 = "src/components/Footer.svelte";
	function create_fragment$8(ctx) {
	  let div;
	  let h4;
	  let a0;
	  let span0;
	  let github;
	  let t0;
	  let span1;
	  let t2;
	  let a1;
	  let img;
	  let img_src_value;
	  let current;
	  github = new Github({
	    props: {
	      size: "2em"
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      h4 = element("h4");
	      a0 = element("a");
	      span0 = element("span");
	      create_component(github.$$.fragment);
	      t0 = space();
	      span1 = element("span");
	      span1.textContent = "ru_museum";
	      t2 = space();
	      a1 = element("a");
	      img = element("img");
	      set_style(span0, "vertical-align", "middle");
	      add_location(span0, file$7, 13, 6, 243);
	      set_style(span1, "vertical-align", "top");
	      add_location(span1, file$7, 16, 6, 330);
	      attr_dev(a0, "href", "https://github.com/ru-museum");
	      attr_dev(a0, "target", "_blank");
	      attr_dev(a0, "rel", "noreferrer");
	      set_style(a0, "color", "#b9cbff");
	      attr_dev(a0, "class", "svelte-13l1iks");
	      add_location(a0, file$7, 9, 4, 118);
	      add_location(h4, file$7, 8, 2, 109);
	      if (!src_url_equal(img.src, img_src_value = "https://www.gnu.org/gnu40/GNU40_badge-sm.png")) attr_dev(img, "src", img_src_value);
	      attr_dev(img, "alt", "[ Celebrate 40 years of GNU! ]");
	      attr_dev(img, "title", "[ Celebrate 40 years of GNU! ]");
	      set_style(img, "width", "80px");
	      add_location(img, file$7, 23, 2, 472);
	      attr_dev(a1, "href", "https://www.gnu.org/gnu40");
	      attr_dev(a1, "target", "_blank");
	      attr_dev(a1, "class", "svelte-13l1iks");
	      add_location(a1, file$7, 22, 0, 417);
	      attr_dev(div, "class", "footer svelte-13l1iks");
	      add_location(div, file$7, 7, 0, 84);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, h4);
	      append_dev(h4, a0);
	      append_dev(a0, span0);
	      mount_component(github, span0, null);
	      append_dev(a0, t0);
	      append_dev(a0, span1);
	      append_dev(div, t2);
	      append_dev(div, a1);
	      append_dev(a1, img);
	      current = true;
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(github.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(github.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(github);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$8.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$8($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Footer', slots, []);
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Footer> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$capture_state = () => ({
	    GitHub: Github
	  });
	  return [];
	}
	class Footer extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Footer",
	      options,
	      id: create_fragment$8.name
	    });
	  }
	}

	var _templateObject$3, _templateObject2$1, _templateObject3$1, _templateObject4$1, _templateObject5, _templateObject6, _templateObject7, _templateObject8;
	/**
	 * Fab Base class logic and template definition
	 * @soyCompatible
	 */
	class FabBase extends s {
	  constructor() {
	    super(...arguments);
	    this.mini = false;
	    this.exited = false;
	    this.disabled = false;
	    this.extended = false;
	    this.showIconAtEnd = false;
	    this.reducedTouchTarget = false;
	    this.icon = '';
	    this.label = '';
	    this.shouldRenderRipple = false;
	    this.useStateLayerCustomProperties = false;
	    this.rippleHandlers = new RippleHandlers(() => {
	      this.shouldRenderRipple = true;
	      return this.ripple;
	    });
	  }
	  /**
	   * @soyTemplate
	   * @soyClasses fabClasses: .mdc-fab
	   */
	  render() {
	    const hasTouchTarget = this.mini && !this.reducedTouchTarget;
	    /** @classMap */
	    const classes = {
	      'mdc-fab--mini': this.mini,
	      'mdc-fab--touch': hasTouchTarget,
	      'mdc-fab--exited': this.exited,
	      'mdc-fab--extended': this.extended,
	      'icon-end': this.showIconAtEnd
	    };
	    const ariaLabel = this.label ? this.label : this.icon;
	    /*
	     * Some internal styling is sensitive to whitespace in this template, take
	     * care when modifying it.
	     */
	    return x(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteral(["<button\n          class=\"mdc-fab ", "\"\n          ?disabled=\"", "\"\n          aria-label=\"", "\"\n          @mouseenter=", "\n          @mouseleave=", "\n          @focus=", "\n          @blur=", "\n          @mousedown=", "\n          @touchstart=", "\n          @touchend=", "\n          @touchcancel=", "><!--\n        -->", "<!--\n        -->", "<!--\n        -->", "<!--\n        --><span class=\"material-icons mdc-fab__icon\"><!--\n          --><slot name=\"icon\">", "</slot><!--\n       --></span><!--\n        -->", "<!--\n        -->", "<!--\n      --></button>"])), o$1(classes), this.disabled, ariaLabel, this.handleRippleMouseEnter, this.handleRippleMouseLeave, this.handleRippleFocus, this.handleRippleBlur, this.handleRippleActivate, this.handleRippleStartPress, this.handleRippleDeactivate, this.handleRippleDeactivate, this.renderBeforeRipple(), this.renderRipple(), this.showIconAtEnd ? this.renderLabel() : '', this.icon, !this.showIconAtEnd ? this.renderLabel() : '', this.renderTouchTarget());
	  }
	  /** @soyTemplate */
	  renderIcon() {
	    // TODO(b/191914389): reimplement once Wit issue is resolved
	    return x(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteral([""])));
	  }
	  /** @soyTemplate */
	  renderTouchTarget() {
	    const hasTouchTarget = this.mini && !this.reducedTouchTarget;
	    return x(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteral(["", ""])), hasTouchTarget ? x(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteral(["<div class=\"mdc-fab__touch\"></div>"]))) : '');
	  }
	  /** @soyTemplate */
	  renderLabel() {
	    const showLabel = this.label !== '' && this.extended;
	    return x(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral(["", ""])), showLabel ? x(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral(["<span class=\"mdc-fab__label\">", "</span>"])), this.label) : '');
	  }
	  /** @soyTemplate */
	  renderBeforeRipple() {
	    return x(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([""])));
	  }
	  /** @soyTemplate */
	  renderRipple() {
	    return this.shouldRenderRipple ? x(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral(["<mwc-ripple class=\"ripple\"\n        .internalUseStateLayerCustomProperties=\"", "\"\n         ></mwc-ripple>"])), this.useStateLayerCustomProperties) : '';
	  }
	  handleRippleActivate(event) {
	    const onUp = () => {
	      window.removeEventListener('mouseup', onUp);
	      this.handleRippleDeactivate();
	    };
	    window.addEventListener('mouseup', onUp);
	    this.handleRippleStartPress(event);
	  }
	  handleRippleStartPress(event) {
	    this.rippleHandlers.startPress(event);
	  }
	  handleRippleDeactivate() {
	    this.rippleHandlers.endPress();
	  }
	  handleRippleMouseEnter() {
	    this.rippleHandlers.startHover();
	  }
	  handleRippleMouseLeave() {
	    this.rippleHandlers.endHover();
	  }
	  handleRippleFocus() {
	    this.rippleHandlers.startFocus();
	  }
	  handleRippleBlur() {
	    this.rippleHandlers.endFocus();
	  }
	}
	FabBase.shadowRootOptions = {
	  mode: 'open',
	  delegatesFocus: true
	};
	__decorate([e$5('mwc-ripple')], FabBase.prototype, "ripple", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "mini", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "exited", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "disabled", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "extended", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "showIconAtEnd", void 0);
	__decorate([n$6({
	  type: Boolean
	})], FabBase.prototype, "reducedTouchTarget", void 0);
	__decorate([n$6()], FabBase.prototype, "icon", void 0);
	__decorate([n$6()], FabBase.prototype, "label", void 0);
	__decorate([t$3()], FabBase.prototype, "shouldRenderRipple", void 0);
	__decorate([t$3()], FabBase.prototype, "useStateLayerCustomProperties", void 0);
	__decorate([e$6({
	  passive: true
	})], FabBase.prototype, "handleRippleStartPress", null);

	var _templateObject$2;
	const styles$1 = i$3(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteral([":host .mdc-fab .material-icons{font-family:var(--mdc-icon-font, \"Material Icons\");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:\"liga\"}:host{outline:none;--mdc-ripple-color: currentcolor;user-select:none;-webkit-tap-highlight-color:transparent;display:inline-flex;-webkit-tap-highlight-color:transparent;display:inline-flex;outline:none;user-select:none}:host .mdc-touch-target-wrapper{display:inline}:host .mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:0;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff;background-color:var(--mdc-elevation-overlay-color, #fff)}:host .mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}:host .mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}:host .mdc-fab::-moz-focus-inner{padding:0;border:0}:host .mdc-fab:hover{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}:host .mdc-fab.mdc-ripple-upgraded--background-focused,:host .mdc-fab:not(.mdc-ripple-upgraded):focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}:host .mdc-fab .mdc-fab__focus-ring{position:absolute}:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc( 100% + 4px );width:calc( 100% + 4px )}@media screen and (forced-colors: active){:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:\"\";border:2px solid transparent;border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}:host .mdc-fab:active,:host .mdc-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2),0px 12px 17px 2px rgba(0, 0, 0, 0.14),0px 5px 22px 4px rgba(0,0,0,.12)}:host .mdc-fab:active,:host .mdc-fab:focus{outline:none}:host .mdc-fab:hover{cursor:pointer}:host .mdc-fab>svg{width:100%}:host .mdc-fab--mini{width:40px;height:40px}:host .mdc-fab--extended{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-button-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-button-font-size, 0.875rem);line-height:2.25rem;line-height:var(--mdc-typography-button-line-height, 2.25rem);font-weight:500;font-weight:var(--mdc-typography-button-font-weight, 500);letter-spacing:0.0892857143em;letter-spacing:var(--mdc-typography-button-letter-spacing, 0.0892857143em);text-decoration:none;text-decoration:var(--mdc-typography-button-text-decoration, none);text-transform:uppercase;text-transform:var(--mdc-typography-button-text-transform, uppercase);border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}:host .mdc-fab--extended .mdc-fab__ripple{border-radius:24px}:host .mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] :host .mdc-fab--extended .mdc-fab__icon,:host .mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}:host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] :host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,:host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}:host .mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}:host .mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}:host .mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid transparent;border-radius:inherit;content:\"\";pointer-events:none}@media screen and (forced-colors: active){:host .mdc-fab::before{border-color:CanvasText}}:host .mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}:host .mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}:host .mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}:host .mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}:host .mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}:host .mdc-fab{background-color:#018786;background-color:var(--mdc-theme-secondary, #018786);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2),0px 6px 10px 0px rgba(0, 0, 0, 0.14),0px 1px 18px 0px rgba(0,0,0,.12)}:host .mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}:host .mdc-fab,:host .mdc-fab:not(:disabled) .mdc-fab__icon,:host .mdc-fab:not(:disabled) .mdc-fab__label,:host .mdc-fab:disabled .mdc-fab__icon,:host .mdc-fab:disabled .mdc-fab__label{color:#fff;color:var(--mdc-theme-on-secondary, #fff)}:host .mdc-fab:not(.mdc-fab--extended){border-radius:50%}:host .mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}:host .mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}:host .mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}:host .mdc-fab::-moz-focus-inner{padding:0;border:0}:host .mdc-fab:hover{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}:host .mdc-fab.mdc-ripple-upgraded--background-focused,:host .mdc-fab:not(.mdc-ripple-upgraded):focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}:host .mdc-fab .mdc-fab__focus-ring{position:absolute}:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc( 100% + 4px );width:calc( 100% + 4px )}@media screen and (forced-colors: active){:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:\"\";border:2px solid transparent;border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){:host .mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,:host .mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}:host .mdc-fab:active,:host .mdc-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2),0px 12px 17px 2px rgba(0, 0, 0, 0.14),0px 5px 22px 4px rgba(0,0,0,.12)}:host .mdc-fab:active,:host .mdc-fab:focus{outline:none}:host .mdc-fab:hover{cursor:pointer}:host .mdc-fab>svg{width:100%}:host .mdc-fab--mini{width:40px;height:40px}:host .mdc-fab--extended{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-button-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-button-font-size, 0.875rem);line-height:2.25rem;line-height:var(--mdc-typography-button-line-height, 2.25rem);font-weight:500;font-weight:var(--mdc-typography-button-font-weight, 500);letter-spacing:0.0892857143em;letter-spacing:var(--mdc-typography-button-letter-spacing, 0.0892857143em);text-decoration:none;text-decoration:var(--mdc-typography-button-text-decoration, none);text-transform:uppercase;text-transform:var(--mdc-typography-button-text-transform, uppercase);border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}:host .mdc-fab--extended .mdc-fab__ripple{border-radius:24px}:host .mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] :host .mdc-fab--extended .mdc-fab__icon,:host .mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}:host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] :host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,:host .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}:host .mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}:host .mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}:host .mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid transparent;border-radius:inherit;content:\"\";pointer-events:none}@media screen and (forced-colors: active){:host .mdc-fab::before{border-color:CanvasText}}:host .mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}:host .mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}:host .mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}:host .mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}:host .mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}:host .mdc-fab .ripple{overflow:hidden}:host .mdc-fab:not(.mdc-fab--extended) .ripple{border-radius:50%}:host .mdc-fab.mdc-fab--extended .ripple{border-radius:24px}:host .mdc-fab .mdc-fab__label{z-index:0}:host .mdc-fab .mdc-fab__icon ::slotted(*){width:inherit;height:inherit;font-size:inherit}:host .mdc-fab--extended.mdc-fab--exited .mdc-fab__icon ::slotted(*){transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}:host .mdc-fab{padding-top:0px;padding-top:max(0px, var(--mdc-fab-focus-outline-width, 0px));padding-right:0px;padding-right:max(0px, var(--mdc-fab-focus-outline-width, 0px));padding-bottom:0px;padding-bottom:max(0px, var(--mdc-fab-focus-outline-width, 0px));padding-left:0px;padding-left:max(0px, var(--mdc-fab-focus-outline-width, 0px));box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-fab-box-shadow, 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12))}:host .mdc-fab:not(:disabled).mdc-ripple-upgraded--background-focused,:host .mdc-fab:not(:disabled):not(.mdc-ripple-upgraded):focus{border-color:initial;border-color:var(--mdc-fab-focus-outline-color, initial)}:host .mdc-fab:not(:disabled).mdc-ripple-upgraded--background-focused,:host .mdc-fab:not(:disabled):not(.mdc-ripple-upgraded):focus{border-style:solid;border-width:var(--mdc-fab-focus-outline-width, 0px);padding-top:0px;padding-top:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-right:0px;padding-right:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-bottom:0px;padding-bottom:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-left:0px;padding-left:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1))}:host .mdc-fab:hover,:host .mdc-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-fab-box-shadow, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}:host .mdc-fab:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-fab-box-shadow, 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12))}:host .mdc-fab .ripple{overflow:hidden}:host .mdc-fab .mdc-fab__label{z-index:0}:host .mdc-fab:not(.mdc-fab--extended) .ripple{border-radius:50%}:host .mdc-fab.mdc-fab--extended .ripple{border-radius:24px}:host .mdc-fab .mdc-fab__icon{width:24px;width:var(--mdc-icon-size, 24px);height:24px;height:var(--mdc-icon-size, 24px);font-size:24px;font-size:var(--mdc-icon-size, 24px);transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform;display:inline-flex;align-items:center;justify-content:center}:host .mdc-fab.mdc-fab--extended{padding-top:0px;padding-top:max(0px, var(--mdc-fab-focus-outline-width, 0px));padding-right:20px;padding-right:max(var(--mdc-fab-extended-label-padding, 20px), var(--mdc-fab-focus-outline-width, 0px));padding-bottom:0px;padding-bottom:max(0px, var(--mdc-fab-focus-outline-width, 0px));padding-left:20px;padding-left:max(var(--mdc-fab-extended-label-padding, 20px), var(--mdc-fab-focus-outline-width, 0px))}:host .mdc-fab.mdc-fab--extended:not(:disabled).mdc-ripple-upgraded--background-focused,:host .mdc-fab.mdc-fab--extended:not(:disabled):not(.mdc-ripple-upgraded):focus{border-style:solid;border-width:var(--mdc-fab-focus-outline-width, 0px);padding-top:0px;padding-top:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-right:20px;padding-right:max(calc(var(--mdc-fab-extended-label-padding, 20px) - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(var(--mdc-fab-extended-label-padding, 20px) - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-bottom:0px;padding-bottom:max(calc(0px - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(0px - var(--mdc-fab-focus-outline-width, 0px)) * -1));padding-left:20px;padding-left:max(calc(var(--mdc-fab-extended-label-padding, 20px) - var(--mdc-fab-focus-outline-width, 0px)), calc(calc(var(--mdc-fab-extended-label-padding, 20px) - var(--mdc-fab-focus-outline-width, 0px)) * -1))}:host .mdc-fab.mdc-fab--extended.icon-end .mdc-fab__icon{margin-left:12px;margin-left:var(--mdc-fab-extended-icon-padding, 12px);margin-right:calc(12px - 20px);margin-right:calc(var(--mdc-fab-extended-icon-padding, 12px) - var(--mdc-fab-extended-label-padding, 20px))}[dir=rtl] :host .mdc-fab.mdc-fab--extended.icon-end .mdc-fab__icon,:host .mdc-fab.mdc-fab--extended.icon-end .mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-left:calc(var(--mdc-fab-extended-icon-padding, 12px) - var(--mdc-fab-extended-label-padding, 20px));margin-right:12px;margin-right:var(--mdc-fab-extended-icon-padding, 12px)}"])));

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/** @soyCompatible */
	let Fab = class Fab extends FabBase {};
	Fab.styles = [styles$1];
	Fab = __decorate([e$8('mwc-fab')], Fab);

	/* src/components/ToTopButton.svelte generated by Svelte v4.2.1 */
	const file$6 = "src/components/ToTopButton.svelte";
	function create_fragment$7(ctx) {
	  let div;
	  let mwc_fab;
	  let mwc_icon;
	  let arrowupward;
	  let current;
	  let mounted;
	  let dispose;
	  arrowupward = new Arrow_upward({
	    props: {
	      size: "2em"
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      mwc_fab = element("mwc-fab");
	      mwc_icon = element("mwc-icon");
	      create_component(arrowupward.$$.fragment);
	      set_custom_element_data(mwc_icon, "slot", "icon");
	      add_location(mwc_icon, file$6, 24, 4, 536);
	      set_custom_element_data(mwc_fab, "label", "toTop");
	      set_custom_element_data(mwc_fab, "class", "greenAndGray svelte-1pmpv6p");
	      set_custom_element_data(mwc_fab, "tabindex", "0");
	      set_custom_element_data(mwc_fab, "role", "button");
	      set_custom_element_data(mwc_fab, "aria-pressed", "false");
	      add_location(mwc_fab, file$6, 17, 2, 330);
	      attr_dev(div, "id", "btn-to-top");
	      attr_dev(div, "class", "svelte-1pmpv6p");
	      add_location(div, file$6, 15, 0, 261);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, mwc_fab);
	      append_dev(mwc_fab, mwc_icon);
	      mount_component(arrowupward, mwc_icon, null);
	      current = true;
	      if (!mounted) {
	        dispose = [listen_dev(mwc_fab, "click", /*click_handler*/ctx[1], false, false, false, false), listen_dev(mwc_fab, "keydown", /*keydown_handler*/ctx[0], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(arrowupward.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(arrowupward.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(arrowupward);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$7.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function toTop() {
	  document.body.scrollTop = 0;
	  document.documentElement.scrollTop = 0;
	}
	function instance$7($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('ToTopButton', slots, []);
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ToTopButton> was created with unknown prop '".concat(key, "'"));
	  });
	  function keydown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  const click_handler = () => toTop();
	  $$self.$capture_state = () => ({
	    ArrowUpward: Arrow_upward,
	    toTop
	  });
	  return [keydown_handler, click_handler];
	}
	class ToTopButton extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "ToTopButton",
	      options,
	      id: create_fragment$7.name
	    });
	  }
	}

	var _templateObject$1, _templateObject2, _templateObject3, _templateObject4;
	/** @soyCompatible */
	class ButtonBase extends s {
	  constructor() {
	    super(...arguments);
	    this.raised = false;
	    this.unelevated = false;
	    this.outlined = false;
	    this.dense = false;
	    this.disabled = false;
	    this.trailingIcon = false;
	    this.fullwidth = false;
	    this.icon = '';
	    this.label = '';
	    this.expandContent = false;
	    this.shouldRenderRipple = false;
	    this.rippleHandlers = new RippleHandlers(() => {
	      this.shouldRenderRipple = true;
	      return this.ripple;
	    });
	  }
	  /** @soyTemplate */
	  renderOverlay() {
	    return x(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteral([""])));
	  }
	  /** @soyTemplate */
	  renderRipple() {
	    const filled = this.raised || this.unelevated;
	    return this.shouldRenderRipple ? x(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral(["<mwc-ripple class=\"ripple\" .primary=\"", "\" .disabled=\"", "\"></mwc-ripple>"])), !filled, this.disabled) : '';
	  }
	  focus() {
	    const buttonElement = this.buttonElement;
	    if (buttonElement) {
	      this.rippleHandlers.startFocus();
	      buttonElement.focus();
	    }
	  }
	  blur() {
	    const buttonElement = this.buttonElement;
	    if (buttonElement) {
	      this.rippleHandlers.endFocus();
	      buttonElement.blur();
	    }
	  }
	  /** @soyTemplate */
	  getRenderClasses() {
	    return {
	      'mdc-button--raised': this.raised,
	      'mdc-button--unelevated': this.unelevated,
	      'mdc-button--outlined': this.outlined,
	      'mdc-button--dense': this.dense
	    };
	  }
	  /**
	   * @soyTemplate
	   * @soyAttributes buttonAttributes: #button
	   * @soyClasses buttonClasses: #button
	   */
	  render() {
	    return x(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral(["\n      <button\n          id=\"button\"\n          class=\"mdc-button ", "\"\n          ?disabled=\"", "\"\n          aria-label=\"", "\"\n          aria-haspopup=\"", "\"\n          @focus=\"", "\"\n          @blur=\"", "\"\n          @mousedown=\"", "\"\n          @mouseenter=\"", "\"\n          @mouseleave=\"", "\"\n          @touchstart=\"", "\"\n          @touchend=\"", "\"\n          @touchcancel=\"", "\">\n        ", "\n        ", "\n        <span class=\"leading-icon\">\n          <slot name=\"icon\">\n            ", "\n          </slot>\n        </span>\n        <span class=\"mdc-button__label\">", "</span>\n        <span class=\"slot-container ", "\">\n          <slot></slot>\n        </span>\n        <span class=\"trailing-icon\">\n          <slot name=\"trailingIcon\">\n            ", "\n          </slot>\n        </span>\n      </button>"])), o$1(this.getRenderClasses()), this.disabled, this.label || this.icon, l(this.ariaHasPopup), this.handleRippleFocus, this.handleRippleBlur, this.handleRippleActivate, this.handleRippleMouseEnter, this.handleRippleMouseLeave, this.handleRippleActivate, this.handleRippleDeactivate, this.handleRippleDeactivate, this.renderOverlay(), this.renderRipple(), this.icon && !this.trailingIcon ? this.renderIcon() : '', this.label, o$1({
	      flex: this.expandContent
	    }), this.icon && this.trailingIcon ? this.renderIcon() : '');
	  }
	  /** @soyTemplate */
	  renderIcon() {
	    return x(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral(["\n    <mwc-icon class=\"mdc-button__icon\">\n      ", "\n    </mwc-icon>"])), this.icon);
	  }
	  handleRippleActivate(evt) {
	    const onUp = () => {
	      window.removeEventListener('mouseup', onUp);
	      this.handleRippleDeactivate();
	    };
	    window.addEventListener('mouseup', onUp);
	    this.rippleHandlers.startPress(evt);
	  }
	  handleRippleDeactivate() {
	    this.rippleHandlers.endPress();
	  }
	  handleRippleMouseEnter() {
	    this.rippleHandlers.startHover();
	  }
	  handleRippleMouseLeave() {
	    this.rippleHandlers.endHover();
	  }
	  handleRippleFocus() {
	    this.rippleHandlers.startFocus();
	  }
	  handleRippleBlur() {
	    this.rippleHandlers.endFocus();
	  }
	}
	ButtonBase.shadowRootOptions = {
	  mode: 'open',
	  delegatesFocus: true
	};
	__decorate([ariaProperty, n$6({
	  type: String,
	  attribute: 'aria-haspopup'
	})], ButtonBase.prototype, "ariaHasPopup", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ButtonBase.prototype, "raised", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ButtonBase.prototype, "unelevated", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ButtonBase.prototype, "outlined", void 0);
	__decorate([n$6({
	  type: Boolean
	})], ButtonBase.prototype, "dense", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ButtonBase.prototype, "disabled", void 0);
	__decorate([n$6({
	  type: Boolean,
	  attribute: 'trailingicon'
	})], ButtonBase.prototype, "trailingIcon", void 0);
	__decorate([n$6({
	  type: Boolean,
	  reflect: true
	})], ButtonBase.prototype, "fullwidth", void 0);
	__decorate([n$6({
	  type: String
	})], ButtonBase.prototype, "icon", void 0);
	__decorate([n$6({
	  type: String
	})], ButtonBase.prototype, "label", void 0);
	__decorate([n$6({
	  type: Boolean
	})], ButtonBase.prototype, "expandContent", void 0);
	__decorate([i$4('#button')], ButtonBase.prototype, "buttonElement", void 0);
	__decorate([e$5('mwc-ripple')], ButtonBase.prototype, "ripple", void 0);
	__decorate([t$3()], ButtonBase.prototype, "shouldRenderRipple", void 0);
	__decorate([e$6({
	  passive: true
	})], ButtonBase.prototype, "handleRippleActivate", null);

	var _templateObject;
	const styles = i$3(_templateObject || (_templateObject = _taggedTemplateLiteral([".mdc-button{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-button-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.875rem;font-size:var(--mdc-typography-button-font-size, 0.875rem);line-height:2.25rem;line-height:var(--mdc-typography-button-line-height, 2.25rem);font-weight:500;font-weight:var(--mdc-typography-button-font-weight, 500);letter-spacing:0.0892857143em;letter-spacing:var(--mdc-typography-button-letter-spacing, 0.0892857143em);text-decoration:none;text-decoration:var(--mdc-typography-button-text-decoration, none);text-transform:uppercase;text-transform:var(--mdc-typography-button-text-transform, uppercase)}.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:0;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff;background-color:var(--mdc-elevation-overlay-color, #fff)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:transparent}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{display:none}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{pointer-events:none;border:2px solid transparent;border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc( 100% + 4px );width:calc( 100% + 4px );display:block}}@media screen and (forced-colors: active)and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring::after,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring::after{content:\"\";border:2px solid transparent;border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}}@media screen and (forced-colors: active)and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring::after,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring::after{border-color:CanvasText}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:transparent}.mdc-button{height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-button:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button .mdc-button__icon{font-size:1.125rem;width:1.125rem;height:1.125rem}.mdc-button .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--raised,.mdc-button--unelevated{height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{background-color:rgba(0, 0, 0, 0.12)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button--raised .mdc-button__icon,.mdc-button--unelevated .mdc-button__icon{font-size:1.125rem;width:1.125rem;height:1.125rem}.mdc-button--raised .mdc-button__ripple,.mdc-button--unelevated .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--outlined{height:36px;border-radius:4px;border-radius:var(--mdc-shape-small, 4px);padding:0 15px 0 15px;border-width:1px}.mdc-button--outlined:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-button--outlined:disabled{color:rgba(0, 0, 0, 0.38)}.mdc-button--outlined .mdc-button__icon{font-size:1.125rem;width:1.125rem;height:1.125rem}.mdc-button--outlined .mdc-button__ripple{border-radius:4px;border-radius:var(--mdc-shape-small, 4px)}.mdc-button--outlined:not(:disabled){border-color:rgba(0, 0, 0, 0.12)}.mdc-button--outlined:disabled{border-color:rgba(0, 0, 0, 0.12)}.mdc-button--outlined.mdc-button--icon-trailing{padding:0 11px 0 15px}.mdc-button--outlined.mdc-button--icon-leading{padding:0 15px 0 11px}.mdc-button--outlined .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:1px}.mdc-button--outlined .mdc-button__touch{left:calc(-1 * 1px);width:calc(100% + 2 * 1px)}.mdc-button--raised{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2),0px 2px 2px 0px rgba(0, 0, 0, 0.14),0px 1px 5px 0px rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--raised:hover,.mdc-button--raised:focus{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12)}.mdc-button--raised:active{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}.mdc-button--raised:disabled{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2),0px 0px 0px 0px rgba(0, 0, 0, 0.14),0px 0px 0px 0px rgba(0,0,0,.12)}:host{display:inline-flex;outline:none;-webkit-tap-highlight-color:transparent;vertical-align:top}:host([fullwidth]){width:100%}:host([raised]),:host([unelevated]){--mdc-ripple-color:#fff;--mdc-ripple-focus-opacity:0.24;--mdc-ripple-hover-opacity:0.08;--mdc-ripple-press-opacity:0.24}.trailing-icon ::slotted(*),.trailing-icon .mdc-button__icon,.leading-icon ::slotted(*),.leading-icon .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .trailing-icon ::slotted(*),[dir=rtl] .trailing-icon .mdc-button__icon,[dir=rtl] .leading-icon ::slotted(*),[dir=rtl] .leading-icon .mdc-button__icon,.trailing-icon ::slotted(*[dir=rtl]),.trailing-icon .mdc-button__icon[dir=rtl],.leading-icon ::slotted(*[dir=rtl]),.leading-icon .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.trailing-icon ::slotted(*),.trailing-icon .mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .trailing-icon ::slotted(*),[dir=rtl] .trailing-icon .mdc-button__icon,.trailing-icon ::slotted(*[dir=rtl]),.trailing-icon .mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}.slot-container{display:inline-flex;align-items:center;justify-content:center}.slot-container.flex{flex:auto}.mdc-button{flex:auto;overflow:hidden;padding-left:8px;padding-left:var(--mdc-button-horizontal-padding, 8px);padding-right:8px;padding-right:var(--mdc-button-horizontal-padding, 8px)}.mdc-button--raised{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:focus{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-focus, var(--mdc-button-raised-box-shadow-hover, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12)))}.mdc-button--raised:hover{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-hover, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:active{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-active, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mdc-button--raised:disabled{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12);box-shadow:var(--mdc-button-raised-box-shadow-disabled, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised,.mdc-button--unelevated{padding-left:16px;padding-left:var(--mdc-button-horizontal-padding, 16px);padding-right:16px;padding-right:var(--mdc-button-horizontal-padding, 16px)}.mdc-button--outlined{border-width:1px;border-width:var(--mdc-button-outline-width, 1px);padding-left:calc(16px - 1px);padding-left:calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px));padding-right:calc(16px - 1px);padding-right:calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px))}.mdc-button--outlined:not(:disabled){border-color:rgba(0, 0, 0, 0.12);border-color:var(--mdc-button-outline-color, rgba(0, 0, 0, 0.12))}.mdc-button--outlined .ripple{top:calc(-1 * 1px);top:calc(-1 * var(--mdc-button-outline-width, 1px));left:calc(-1 * 1px);left:calc(-1 * var(--mdc-button-outline-width, 1px));right:initial;right:initial;border-width:1px;border-width:var(--mdc-button-outline-width, 1px);border-style:solid;border-color:transparent}[dir=rtl] .mdc-button--outlined .ripple,.mdc-button--outlined .ripple[dir=rtl]{left:initial;left:initial;right:calc(-1 * 1px);right:calc(-1 * var(--mdc-button-outline-width, 1px))}.mdc-button--dense{height:28px;margin-top:0;margin-bottom:0}.mdc-button--dense .mdc-button__touch{height:100%}:host([disabled]){pointer-events:none}:host([disabled]) .mdc-button{color:rgba(0, 0, 0, 0.38);color:var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-button--raised,:host([disabled]) .mdc-button--unelevated{background-color:rgba(0, 0, 0, 0.12);background-color:var(--mdc-button-disabled-fill-color, rgba(0, 0, 0, 0.12))}:host([disabled]) .mdc-button--outlined{border-color:rgba(0, 0, 0, 0.12);border-color:var(--mdc-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}"])));

	/**
	 * @license
	 * Copyright 2018 Google LLC
	 * SPDX-License-Identifier: Apache-2.0
	 */
	/** @soyCompatible */
	let Button = class Button extends ButtonBase {};
	Button.styles = [styles];
	Button = __decorate([e$8('mwc-button')], Button);

	const file$5 = "src/pages/Home.svelte";
	function create_fragment$6(ctx) {
	  let div1;
	  let main;
	  let div0;
	  let t0_value = /*presets*/ctx[0].subtitle + "";
	  let t0;
	  let t1;
	  let h1;
	  let t2_value = /*presets*/ctx[0].title + "";
	  let t2;
	  let t3;
	  let button0;
	  let t5;
	  let button1;
	  let t7;
	  let h2;
	  let t14;
	  let br0;
	  let t15;
	  let br1;
	  let t16;
	  let br2;
	  let t17;
	  let br3;
	  let t18;
	  let br4;
	  let t19;
	  let br5;
	  let t20;
	  let br6;
	  let t21;
	  let br7;
	  let t22;
	  let br8;
	  let t23;
	  let br9;
	  let t24;
	  let br10;
	  let t25;
	  let br11;
	  let t26;
	  let br12;
	  let t27;
	  let br13;
	  let t28;
	  let br14;
	  let t29;
	  let br15;
	  let t30;
	  let br16;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      div1 = element("div");
	      main = element("main");
	      div0 = element("div");
	      t0 = text(t0_value);
	      t1 = space();
	      h1 = element("h1");
	      t2 = text(t2_value);
	      t3 = space();
	      button0 = element("button");
	      button0.textContent = "åç´ç·¨";
	      t5 = space();
	      button1 = element("button");
	      button1.textContent = "å¿ç¨ç·¨";
	      t7 = space();
	      h2 = element("h2");
	      h2.textContent = "".concat( /*le*/ctx[1][0].year[0], "\u5E74\u5EA6\n    ").concat( /*le*/ctx[1][0].year[1], "\u6708\u301C").concat( /*le*/ctx[1][0].year[2], "\u6708\u653E\u9001\u5206");
	      t14 = space();
	      br0 = element("br");
	      t15 = space();
	      br1 = element("br");
	      t16 = space();
	      br2 = element("br");
	      t17 = space();
	      br3 = element("br");
	      t18 = space();
	      br4 = element("br");
	      t19 = space();
	      br5 = element("br");
	      t20 = space();
	      br6 = element("br");
	      t21 = space();
	      br7 = element("br");
	      t22 = space();
	      br8 = element("br");
	      t23 = space();
	      br9 = element("br");
	      t24 = space();
	      br10 = element("br");
	      t25 = space();
	      br11 = element("br");
	      t26 = space();
	      br12 = element("br");
	      t27 = space();
	      br13 = element("br");
	      t28 = space();
	      br14 = element("br");
	      t29 = space();
	      br15 = element("br");
	      t30 = space();
	      br16 = element("br");
	      attr_dev(div0, "class", "subtitle svelte-e4x3z5");
	      add_location(div0, file$5, 15, 0, 226);
	      attr_dev(h1, "class", "title svelte-e4x3z5");
	      add_location(h1, file$5, 16, 0, 273);
	      attr_dev(button0, "class", "svelte-e4x3z5");
	      add_location(button0, file$5, 22, 1, 446);
	      attr_dev(button1, "class", "svelte-e4x3z5");
	      add_location(button1, file$5, 25, 1, 516);
	      add_location(h2, file$5, 28, 2, 586);
	      add_location(br0, file$5, 33, 0, 665);
	      add_location(br1, file$5, 34, 0, 670);
	      add_location(br2, file$5, 35, 0, 675);
	      add_location(br3, file$5, 36, 0, 680);
	      add_location(br4, file$5, 37, 0, 685);
	      add_location(br5, file$5, 38, 0, 690);
	      add_location(br6, file$5, 39, 0, 695);
	      add_location(br7, file$5, 40, 0, 700);
	      add_location(br8, file$5, 41, 0, 705);
	      add_location(br9, file$5, 42, 0, 710);
	      add_location(br10, file$5, 43, 0, 715);
	      add_location(br11, file$5, 44, 0, 720);
	      add_location(br12, file$5, 45, 0, 725);
	      add_location(br13, file$5, 46, 0, 730);
	      add_location(br14, file$5, 47, 0, 735);
	      add_location(br15, file$5, 48, 0, 740);
	      add_location(br16, file$5, 49, 0, 745);
	      attr_dev(main, "class", "svelte-e4x3z5");
	      add_location(main, file$5, 14, 0, 219);
	      attr_dev(div1, "class", "container svelte-e4x3z5");
	      add_location(div1, file$5, 12, 0, 192);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div1, anchor);
	      append_dev(div1, main);
	      append_dev(main, div0);
	      append_dev(div0, t0);
	      append_dev(main, t1);
	      append_dev(main, h1);
	      append_dev(h1, t2);
	      append_dev(main, t3);
	      append_dev(main, button0);
	      append_dev(main, t5);
	      append_dev(main, button1);
	      append_dev(main, t7);
	      append_dev(main, h2);
	      append_dev(main, t14);
	      append_dev(main, br0);
	      append_dev(main, t15);
	      append_dev(main, br1);
	      append_dev(main, t16);
	      append_dev(main, br2);
	      append_dev(main, t17);
	      append_dev(main, br3);
	      append_dev(main, t18);
	      append_dev(main, br4);
	      append_dev(main, t19);
	      append_dev(main, br5);
	      append_dev(main, t20);
	      append_dev(main, br6);
	      append_dev(main, t21);
	      append_dev(main, br7);
	      append_dev(main, t22);
	      append_dev(main, br8);
	      append_dev(main, t23);
	      append_dev(main, br9);
	      append_dev(main, t24);
	      append_dev(main, br10);
	      append_dev(main, t25);
	      append_dev(main, br11);
	      append_dev(main, t26);
	      append_dev(main, br12);
	      append_dev(main, t27);
	      append_dev(main, br13);
	      append_dev(main, t28);
	      append_dev(main, br14);
	      append_dev(main, t29);
	      append_dev(main, br15);
	      append_dev(main, t30);
	      append_dev(main, br16);
	      if (!mounted) {
	        dispose = [listen_dev(button0, "click", /*click_handler*/ctx[2], false, false, false, false), listen_dev(button1, "click", /*click_handler_1*/ctx[3], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*presets*/1 && t0_value !== (t0_value = /*presets*/ctx[0].subtitle + "")) set_data_dev(t0, t0_value);
	      if (dirty & /*presets*/1 && t2_value !== (t2_value = /*presets*/ctx[0].title + "")) set_data_dev(t2, t2_value);
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div1);
	      }
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$6.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$6($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Home', slots, []);
	  let {
	    presets
	  } = $$props;
	  let le = mylessons; // ãã¼ã¿èª­ã¿è¾¼ã¿

	  $$self.$$.on_mount.push(function () {
	    if (presets === undefined && !('presets' in $$props || $$self.$$.bound[$$self.$$.props['presets']])) {
	      console.warn("<Home> was created without expected prop 'presets'");
	    }
	  });
	  const writable_props = ['presets'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Home> was created with unknown prop '".concat(key, "'"));
	  });
	  const click_handler = () => location.href = "#/shokyu";
	  const click_handler_1 = () => location.href = "#/ouyou";
	  $$self.$$set = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	  };
	  $$self.$capture_state = () => ({
	    presets,
	    le,
	    Help: Help$1,
	    Info,
	    MenuButton: Menu$1,
	    MoreVert: More_vert
	  });
	  $$self.$inject_state = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	    if ('le' in $$props) $$invalidate(1, le = $$props.le);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [presets, le, click_handler, click_handler_1];
	}
	class Home extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
	      presets: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Home",
	      options,
	      id: create_fragment$6.name
	    });
	  }
	  get presets() {
	    throw new Error("<Home>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set presets(value) {
	    throw new Error("<Home>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$4 = "src/components/AudioPlayer.svelte";
	function create_fragment$5(ctx) {
	  let article;
	  let div;
	  let t0;
	  let t1;
	  let audio_1;
	  let audio_1_src_value;
	  let audio_1_is_paused = true;
	  let mounted;
	  let dispose;
	  const block = {
	    c: function create() {
	      article = element("article");
	      div = element("div");
	      t0 = text( /*title*/ctx[2]);
	      t1 = space();
	      audio_1 = element("audio");
	      add_location(div, file$4, 35, 1, 602);
	      audio_1.controls = true;
	      if (!src_url_equal(audio_1.src, audio_1_src_value = /*src*/ctx[1])) attr_dev(audio_1, "src", audio_1_src_value);
	      attr_dev(audio_1, "class", "svelte-32yrjw");
	      add_location(audio_1, file$4, 36, 1, 622);
	      attr_dev(article, "class", "title svelte-32yrjw");
	      toggle_class(article, "playing", ! /*paused*/ctx[4]);
	      add_location(article, file$4, 34, 0, 553);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, article, anchor);
	      append_dev(article, div);
	      append_dev(div, t0);
	      append_dev(article, t1);
	      append_dev(article, audio_1);
	      /*audio_1_binding*/
	      ctx[6](audio_1);
	      if (!isNaN( /*volume*/ctx[0])) {
	        audio_1.volume = /*volume*/ctx[0];
	      }
	      if (!mounted) {
	        dispose = [listen_dev(audio_1, "play", /*audio_1_play_pause_handler*/ctx[7]), listen_dev(audio_1, "pause", /*audio_1_play_pause_handler*/ctx[7]), listen_dev(audio_1, "play", /*stopOthers*/ctx[5], false, false, false, false), listen_dev(audio_1, "volumechange", /*audio_1_volumechange_handler*/ctx[8])];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*title*/4) set_data_dev(t0, /*title*/ctx[2]);
	      if (dirty & /*src*/2 && !src_url_equal(audio_1.src, audio_1_src_value = /*src*/ctx[1])) {
	        attr_dev(audio_1, "src", audio_1_src_value);
	      }
	      if (dirty & /*paused*/16 && audio_1_is_paused !== (audio_1_is_paused = /*paused*/ctx[4])) {
	        audio_1[audio_1_is_paused ? "pause" : "play"]();
	      }
	      if (dirty & /*volume*/1 && !isNaN( /*volume*/ctx[0])) {
	        audio_1.volume = /*volume*/ctx[0];
	      }
	      if (dirty & /*paused*/16) {
	        toggle_class(article, "playing", ! /*paused*/ctx[4]);
	      }
	    },
	    i: noop$1,
	    o: noop$1,
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(article);
	      }

	      /*audio_1_binding*/
	      ctx[6](null);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$5.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	const elements = new Set();
	function stopAll() {
	  elements.forEach(element => {
	    element.pause();
	  });
	}
	function instance$5($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('AudioPlayer', slots, []);
	  let {
	    src
	  } = $$props;
	  let {
	    title
	  } = $$props;

	  // export let composer;
	  // export let performer;
	  let audio;
	  let paused = true;
	  let {
	    volume
	  } = $$props;
	  onMount(() => {
	    elements.add(audio);
	    return () => elements.delete(audio);
	  });
	  function stopOthers() {
	    elements.forEach(element => {
	      if (element !== audio) element.pause();
	    });
	  }
	  $$self.$$.on_mount.push(function () {
	    if (src === undefined && !('src' in $$props || $$self.$$.bound[$$self.$$.props['src']])) {
	      console.warn("<AudioPlayer> was created without expected prop 'src'");
	    }
	    if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
	      console.warn("<AudioPlayer> was created without expected prop 'title'");
	    }
	    if (volume === undefined && !('volume' in $$props || $$self.$$.bound[$$self.$$.props['volume']])) {
	      console.warn("<AudioPlayer> was created without expected prop 'volume'");
	    }
	  });
	  const writable_props = ['src', 'title', 'volume'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AudioPlayer> was created with unknown prop '".concat(key, "'"));
	  });
	  function audio_1_binding($$value) {
	    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
	      audio = $$value;
	      $$invalidate(3, audio);
	    });
	  }
	  function audio_1_play_pause_handler() {
	    paused = this.paused;
	    $$invalidate(4, paused);
	  }
	  function audio_1_volumechange_handler() {
	    volume = this.volume;
	    $$invalidate(0, volume);
	  }
	  $$self.$$set = $$props => {
	    if ('src' in $$props) $$invalidate(1, src = $$props.src);
	    if ('title' in $$props) $$invalidate(2, title = $$props.title);
	    if ('volume' in $$props) $$invalidate(0, volume = $$props.volume);
	  };
	  $$self.$capture_state = () => ({
	    elements,
	    stopAll,
	    onMount,
	    src,
	    title,
	    audio,
	    paused,
	    volume,
	    stopOthers
	  });
	  $$self.$inject_state = $$props => {
	    if ('src' in $$props) $$invalidate(1, src = $$props.src);
	    if ('title' in $$props) $$invalidate(2, title = $$props.title);
	    if ('audio' in $$props) $$invalidate(3, audio = $$props.audio);
	    if ('paused' in $$props) $$invalidate(4, paused = $$props.paused);
	    if ('volume' in $$props) $$invalidate(0, volume = $$props.volume);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [volume, src, title, audio, paused, stopOthers, audio_1_binding, audio_1_play_pause_handler, audio_1_volumechange_handler];
	}
	class AudioPlayer extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
	      src: 1,
	      title: 2,
	      volume: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "AudioPlayer",
	      options,
	      id: create_fragment$5.name
	    });
	  }
	  get src() {
	    throw new Error("<AudioPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set src(value) {
	    throw new Error("<AudioPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get title() {
	    throw new Error("<AudioPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set title(value) {
	    throw new Error("<AudioPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  get volume() {
	    throw new Error("<AudioPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set volume(value) {
	    throw new Error("<AudioPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const file$3 = "src/pages/Shokyu.svelte";
	function get_each_context$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[3] = list[i].year;
	  child_ctx[4] = list[i].rusLessons;
	  return child_ctx;
	}
	function get_each_context_1$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[7] = list[i].category;
	  child_ctx[8] = list[i].lessons;
	  return child_ctx;
	}
	function get_each_context_2$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[11] = list[i].month;
	  child_ctx[12] = list[i].items;
	  return child_ctx;
	}
	function get_each_context_3$1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[15] = list[i].name;
	  child_ctx[16] = list[i].audio;
	  child_ctx[18] = i;
	  return child_ctx;
	}

	// (24:8) {#if category === "åç´ç·¨" }
	function create_if_block$2(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_2 = ensure_array_like_dev( /*lessons*/ctx[8]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value_2 = ensure_array_like_dev( /*lessons*/ctx[8]);
	        let i;
	        for (i = 0; i < each_value_2.length; i += 1) {
	          const child_ctx = get_each_context_2$1(ctx, each_value_2, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_2$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_2.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$2.name,
	    type: "if",
	    source: "(24:8) {#if category === \\\"åç´ç·¨\\\" }",
	    ctx
	  });
	  return block;
	}

	// (56:26) {#each items as {name,audio}
	function create_each_block_3$1(ctx) {
	  let mwc_list_item;
	  let audioplayer;
	  let t;
	  let current;
	  audioplayer = new AudioPlayer({
	    props: {
	      volume: /*_volume*/ctx[0],
	      src: "./audio/" + /*audio*/ctx[16],
	      title: /*name*/ctx[15]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      mwc_list_item = element("mwc-list-item");
	      create_component(audioplayer.$$.fragment);
	      t = space();
	      set_style(mwc_list_item, "height", "4.4em");
	      add_location(mwc_list_item, file$3, 60, 30, 2031);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, mwc_list_item, anchor);
	      mount_component(audioplayer, mwc_list_item, null);
	      append_dev(mwc_list_item, t);
	      current = true;
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(audioplayer.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(audioplayer.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(mwc_list_item);
	      }
	      destroy_component(audioplayer);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_3$1.name,
	    type: "each",
	    source: "(56:26) {#each items as {name,audio}",
	    ctx
	  });
	  return block;
	}

	// (25:12) {#each lessons as {month,items}}
	function create_each_block_2$1(ctx) {
	  let div5;
	  let div4;
	  let div2;
	  let div0;
	  let span;
	  let t2;
	  let div1;
	  let mwc_icon_button;
	  let cancel;
	  let t3;
	  let div3;
	  let mwc_list;
	  let t4;
	  let current;
	  let mounted;
	  let dispose;
	  cancel = new Cancel({
	    props: {
	      color: "#ba1a1a"
	    },
	    $$inline: true
	  });
	  let each_value_3 = ensure_array_like_dev( /*items*/ctx[12]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_3.length; i += 1) {
	    each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div5 = element("div");
	      div4 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      span = element("span");
	      span.textContent = "".concat( /*month*/ctx[11], "\u6708");
	      t2 = space();
	      div1 = element("div");
	      mwc_icon_button = element("mwc-icon-button");
	      create_component(cancel.$$.fragment);
	      t3 = space();
	      div3 = element("div");
	      mwc_list = element("mwc-list");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t4 = space();
	      attr_dev(span, "class", "month svelte-k844s5");
	      add_location(span, file$3, 36, 24, 1003);
	      attr_dev(div0, "class", "mdc-card__action-buttons");
	      add_location(div0, file$3, 35, 22, 940);
	      set_custom_element_data(mwc_icon_button, "class", "material-icons mdc-icon-button mdc-card__action mdc-card__action--icon");
	      set_custom_element_data(mwc_icon_button, "title", "Stop Audio");
	      set_custom_element_data(mwc_icon_button, "tabindex", "0");
	      set_custom_element_data(mwc_icon_button, "role", "button");
	      set_custom_element_data(mwc_icon_button, "aria-pressed", "false");
	      add_location(mwc_icon_button, file$3, 42, 24, 1226);
	      attr_dev(div1, "class", "mdc-card__action-icons");
	      add_location(div1, file$3, 41, 22, 1165);
	      attr_dev(div2, "class", "mdc-card__actions");
	      add_location(div2, file$3, 34, 20, 886);
	      set_style(mwc_list, "text-align", "center");
	      add_location(mwc_list, file$3, 58, 22, 1904);
	      attr_dev(div3, "class", "mdc-card__primary-action");
	      add_location(div3, file$3, 57, 20, 1843);
	      attr_dev(div4, "class", "mdc-card");
	      set_style(div4, "height", "100%");
	      add_location(div4, file$3, 32, 18, 803);
	      attr_dev(div5, "class", "mdc-layout-grid__cell");
	      add_location(div5, file$3, 30, 16, 748);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div5, anchor);
	      append_dev(div5, div4);
	      append_dev(div4, div2);
	      append_dev(div2, div0);
	      append_dev(div0, span);
	      append_dev(div2, t2);
	      append_dev(div2, div1);
	      append_dev(div1, mwc_icon_button);
	      mount_component(cancel, mwc_icon_button, null);
	      append_dev(div4, t3);
	      append_dev(div4, div3);
	      append_dev(div3, mwc_list);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(mwc_list, null);
	        }
	      }
	      append_dev(div5, t4);
	      current = true;
	      if (!mounted) {
	        dispose = [listen_dev(mwc_icon_button, "click", stopAll, false, false, false, false), listen_dev(mwc_icon_button, "keydown", /*keydown_handler*/ctx[2], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_volume, _mylessons*/3) {
	        each_value_3 = ensure_array_like_dev( /*items*/ctx[12]);
	        let i;
	        for (i = 0; i < each_value_3.length; i += 1) {
	          const child_ctx = get_each_context_3$1(ctx, each_value_3, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_3$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(mwc_list, null);
	          }
	        }
	        group_outros();
	        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(cancel.$$.fragment, local);
	      for (let i = 0; i < each_value_3.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(cancel.$$.fragment, local);
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div5);
	      }
	      destroy_component(cancel);
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_2$1.name,
	    type: "each",
	    source: "(25:12) {#each lessons as {month,items}}",
	    ctx
	  });
	  return block;
	}

	// (23:4) {#each rusLessons as {category,lessons}}
	function create_each_block_1$1(ctx) {
	  let if_block_anchor;
	  let current;
	  let if_block = /*category*/ctx[7] === "åç´ç·¨" && create_if_block$2(ctx);
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if ( /*category*/ctx[7] === "åç´ç·¨") if_block.p(ctx, dirty);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1$1.name,
	    type: "each",
	    source: "(23:4) {#each rusLessons as {category,lessons}}",
	    ctx
	  });
	  return block;
	}

	// (21:2) {#each _mylessons as {year,rusLessons}}
	function create_each_block$1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_1 = ensure_array_like_dev( /*rusLessons*/ctx[4]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value_1 = ensure_array_like_dev( /*rusLessons*/ctx[4]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block$1.name,
	    type: "each",
	    source: "(21:2) {#each _mylessons as {year,rusLessons}}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$4(ctx) {
	  let h1;
	  let t0;
	  let a;
	  let arrowforward;
	  let t1;
	  let div1;
	  let div0;
	  let current;
	  arrowforward = new Arrow_forward({
	    props: {
	      size: "1.4em"
	    },
	    $$inline: true
	  });
	  let each_value = ensure_array_like_dev( /*_mylessons*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      h1 = element("h1");
	      t0 = text("åç´ç·¨ \n  ");
	      a = element("a");
	      create_component(arrowforward.$$.fragment);
	      t1 = space();
	      div1 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(a, "href", "#/ouyou");
	      attr_dev(a, "title", "ãå¿ç¨ç·¨ããéã");
	      add_location(a, file$3, 16, 2, 401);
	      attr_dev(h1, "class", "mdc-typography--headline3 title svelte-k844s5");
	      add_location(h1, file$3, 14, 0, 347);
	      attr_dev(div0, "class", "mdc-layout-grid__inner");
	      add_location(div0, file$3, 22, 2, 516);
	      attr_dev(div1, "class", "mdc-layout-grid");
	      add_location(div1, file$3, 21, 0, 484);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, h1, anchor);
	      append_dev(h1, t0);
	      append_dev(h1, a);
	      mount_component(arrowforward, a, null);
	      insert_dev(target, t1, anchor);
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value = ensure_array_like_dev( /*_mylessons*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context$1(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block$1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div0, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(arrowforward.$$.fragment, local);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(arrowforward.$$.fragment, local);
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(h1);
	        detach_dev(t1);
	        detach_dev(div1);
	      }
	      destroy_component(arrowforward);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$4.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$4($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Shokyu', slots, []);
	  let _volume = volume;
	  let _mylessons = mylessons;
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Shokyu> was created with unknown prop '".concat(key, "'"));
	  });
	  function keydown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  $$self.$capture_state = () => ({
	    _volume,
	    _mylessons,
	    AudioPlayer,
	    stopAll,
	    Cancel,
	    ArrowForward: Arrow_forward
	  });
	  $$self.$inject_state = $$props => {
	    if ('_volume' in $$props) $$invalidate(0, _volume = $$props._volume);
	    if ('_mylessons' in $$props) $$invalidate(1, _mylessons = $$props._mylessons);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [_volume, _mylessons, keydown_handler];
	}
	class Shokyu extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Shokyu",
	      options,
	      id: create_fragment$4.name
	    });
	  }
	}

	const file$2 = "src/pages/Ouyou.svelte";
	function get_each_context(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[3] = list[i].year;
	  child_ctx[4] = list[i].rusLessons;
	  return child_ctx;
	}
	function get_each_context_1(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[7] = list[i].category;
	  child_ctx[8] = list[i].lessons;
	  return child_ctx;
	}
	function get_each_context_2(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[11] = list[i].month;
	  child_ctx[12] = list[i].items;
	  child_ctx[14] = i;
	  return child_ctx;
	}
	function get_each_context_3(ctx, list, i) {
	  const child_ctx = ctx.slice();
	  child_ctx[15] = list[i].name;
	  child_ctx[16] = list[i].audio;
	  child_ctx[18] = i;
	  return child_ctx;
	}

	// (24:6) {#if category === "å¿ç¨ç·¨" }
	function create_if_block$1(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_2 = ensure_array_like_dev( /*lessons*/ctx[8]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_2.length; i += 1) {
	    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value_2 = ensure_array_like_dev( /*lessons*/ctx[8]);
	        let i;
	        for (i = 0; i < each_value_2.length; i += 1) {
	          const child_ctx = get_each_context_2(ctx, each_value_2, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_2(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_2.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block$1.name,
	    type: "if",
	    source: "(24:6) {#if category === \\\"å¿ç¨ç·¨\\\" }",
	    ctx
	  });
	  return block;
	}

	// (55:24) {#each items as {name,audio}
	function create_each_block_3(ctx) {
	  let mwc_list_item;
	  let audioplayer;
	  let t;
	  let current;
	  audioplayer = new AudioPlayer({
	    props: {
	      volume: /*_volume*/ctx[0],
	      src: "./audio/" + /*audio*/ctx[16],
	      title: /*name*/ctx[15]
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      mwc_list_item = element("mwc-list-item");
	      create_component(audioplayer.$$.fragment);
	      t = space();
	      set_style(mwc_list_item, "height", "4.4em");
	      add_location(mwc_list_item, file$2, 60, 28, 1968);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, mwc_list_item, anchor);
	      mount_component(audioplayer, mwc_list_item, null);
	      append_dev(mwc_list_item, t);
	      current = true;
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(audioplayer.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(audioplayer.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(mwc_list_item);
	      }
	      destroy_component(audioplayer);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_3.name,
	    type: "each",
	    source: "(55:24) {#each items as {name,audio}",
	    ctx
	  });
	  return block;
	}

	// (25:10) {#each lessons as {month,items}
	function create_each_block_2(ctx) {
	  let div5;
	  let div4;
	  let div2;
	  let div0;
	  let span;
	  let t2;
	  let div1;
	  let mwc_icon_button;
	  let cancel;
	  let t3;
	  let div3;
	  let mwc_list;
	  let t4;
	  let current;
	  let mounted;
	  let dispose;
	  cancel = new Cancel({
	    props: {
	      color: "#ba1a1a"
	    },
	    $$inline: true
	  });
	  let each_value_3 = ensure_array_like_dev( /*items*/ctx[12]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_3.length; i += 1) {
	    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      div5 = element("div");
	      div4 = element("div");
	      div2 = element("div");
	      div0 = element("div");
	      span = element("span");
	      span.textContent = "".concat( /*month*/ctx[11], "\u6708");
	      t2 = space();
	      div1 = element("div");
	      mwc_icon_button = element("mwc-icon-button");
	      create_component(cancel.$$.fragment);
	      t3 = space();
	      div3 = element("div");
	      mwc_list = element("mwc-list");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      t4 = space();
	      attr_dev(span, "class", "month svelte-9yv90j");
	      add_location(span, file$2, 37, 22, 1013);
	      attr_dev(div0, "class", "mdc-card__action-buttons");
	      add_location(div0, file$2, 36, 20, 952);
	      set_custom_element_data(mwc_icon_button, "class", "material-icons mdc-icon-button mdc-card__action mdc-card__action--icon");
	      set_custom_element_data(mwc_icon_button, "title", "Stop Audio");
	      set_custom_element_data(mwc_icon_button, "tabindex", "0");
	      set_custom_element_data(mwc_icon_button, "role", "button");
	      set_custom_element_data(mwc_icon_button, "aria-pressed", "false");
	      add_location(mwc_icon_button, file$2, 43, 22, 1224);
	      attr_dev(div1, "class", "mdc-card__action-icons");
	      add_location(div1, file$2, 42, 20, 1165);
	      attr_dev(div2, "class", "mdc-card__actions");
	      add_location(div2, file$2, 35, 18, 900);
	      set_style(mwc_list, "text-align", "center");
	      add_location(mwc_list, file$2, 58, 20, 1845);
	      attr_dev(div3, "class", "mdc-card__primary-action");
	      add_location(div3, file$2, 57, 18, 1786);
	      attr_dev(div4, "class", "mdc-card");
	      set_style(div4, "height", "100%");
	      add_location(div4, file$2, 33, 16, 821);
	      attr_dev(div5, "class", "mdc-layout-grid__cell");
	      add_location(div5, file$2, 31, 14, 768);
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div5, anchor);
	      append_dev(div5, div4);
	      append_dev(div4, div2);
	      append_dev(div2, div0);
	      append_dev(div0, span);
	      append_dev(div2, t2);
	      append_dev(div2, div1);
	      append_dev(div1, mwc_icon_button);
	      mount_component(cancel, mwc_icon_button, null);
	      append_dev(div4, t3);
	      append_dev(div4, div3);
	      append_dev(div3, mwc_list);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(mwc_list, null);
	        }
	      }
	      append_dev(div5, t4);
	      current = true;
	      if (!mounted) {
	        dispose = [listen_dev(mwc_icon_button, "click", stopAll, false, false, false, false), listen_dev(mwc_icon_button, "keydown", /*keydown_handler*/ctx[2], false, false, false, false)];
	        mounted = true;
	      }
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_volume, _mylessons*/3) {
	        each_value_3 = ensure_array_like_dev( /*items*/ctx[12]);
	        let i;
	        for (i = 0; i < each_value_3.length; i += 1) {
	          const child_ctx = get_each_context_3(ctx, each_value_3, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_3(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(mwc_list, null);
	          }
	        }
	        group_outros();
	        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(cancel.$$.fragment, local);
	      for (let i = 0; i < each_value_3.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(cancel.$$.fragment, local);
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div5);
	      }
	      destroy_component(cancel);
	      destroy_each(each_blocks, detaching);
	      mounted = false;
	      run_all(dispose);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_2.name,
	    type: "each",
	    source: "(25:10) {#each lessons as {month,items}",
	    ctx
	  });
	  return block;
	}

	// (22:4) {#each rusLessons as {category,lessons}}
	function create_each_block_1(ctx) {
	  let if_block_anchor;
	  let current;
	  let if_block = /*category*/ctx[7] === "å¿ç¨ç·¨" && create_if_block$1(ctx);
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      if_block_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, if_block_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if ( /*category*/ctx[7] === "å¿ç¨ç·¨") if_block.p(ctx, dirty);
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(if_block_anchor);
	      }
	      if (if_block) if_block.d(detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block_1.name,
	    type: "each",
	    source: "(22:4) {#each rusLessons as {category,lessons}}",
	    ctx
	  });
	  return block;
	}

	// (21:2) {#each _mylessons as {year,rusLessons}}
	function create_each_block(ctx) {
	  let each_1_anchor;
	  let current;
	  let each_value_1 = ensure_array_like_dev( /*rusLessons*/ctx[4]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value_1.length; i += 1) {
	    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      each_1_anchor = empty();
	    },
	    m: function mount(target, anchor) {
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(target, anchor);
	        }
	      }
	      insert_dev(target, each_1_anchor, anchor);
	      current = true;
	    },
	    p: function update(ctx, dirty) {
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value_1 = ensure_array_like_dev( /*rusLessons*/ctx[4]);
	        let i;
	        for (i = 0; i < each_value_1.length; i += 1) {
	          const child_ctx = get_each_context_1(ctx, each_value_1, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block_1(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
	          }
	        }
	        group_outros();
	        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      for (let i = 0; i < each_value_1.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(each_1_anchor);
	      }
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_each_block.name,
	    type: "each",
	    source: "(21:2) {#each _mylessons as {year,rusLessons}}",
	    ctx
	  });
	  return block;
	}
	function create_fragment$3(ctx) {
	  let h1;
	  let a;
	  let arrowback;
	  let t0;
	  let t1;
	  let div1;
	  let div0;
	  let current;
	  arrowback = new Arrow_back({
	    props: {
	      size: "1.4em"
	    },
	    $$inline: true
	  });
	  let each_value = ensure_array_like_dev( /*_mylessons*/ctx[1]);
	  let each_blocks = [];
	  for (let i = 0; i < each_value.length; i += 1) {
	    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	  }
	  const out = i => transition_out(each_blocks[i], 1, 1, () => {
	    each_blocks[i] = null;
	  });
	  const block = {
	    c: function create() {
	      h1 = element("h1");
	      a = element("a");
	      create_component(arrowback.$$.fragment);
	      t0 = text("\n  å¿ç¨ç·¨");
	      t1 = space();
	      div1 = element("div");
	      div0 = element("div");
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        each_blocks[i].c();
	      }
	      attr_dev(a, "href", "#/shokyu");
	      attr_dev(a, "title", "ãåç´ç·¨ããéã");
	      attr_dev(a, "class", "svelte-9yv90j");
	      add_location(a, file$2, 16, 2, 389);
	      attr_dev(h1, "class", "mdc-typography--headline3 title svelte-9yv90j");
	      add_location(h1, file$2, 15, 0, 342);
	      attr_dev(div0, "class", "mdc-layout-grid__inner");
	      add_location(div0, file$2, 23, 2, 534);
	      attr_dev(div1, "class", "mdc-layout-grid");
	      set_style(div1, "margin-top", "0px");
	      add_location(div1, file$2, 22, 0, 478);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, h1, anchor);
	      append_dev(h1, a);
	      mount_component(arrowback, a, null);
	      append_dev(h1, t0);
	      insert_dev(target, t1, anchor);
	      insert_dev(target, div1, anchor);
	      append_dev(div1, div0);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        if (each_blocks[i]) {
	          each_blocks[i].m(div0, null);
	        }
	      }
	      current = true;
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*_mylessons, _volume*/3) {
	        each_value = ensure_array_like_dev( /*_mylessons*/ctx[1]);
	        let i;
	        for (i = 0; i < each_value.length; i += 1) {
	          const child_ctx = get_each_context(ctx, each_value, i);
	          if (each_blocks[i]) {
	            each_blocks[i].p(child_ctx, dirty);
	            transition_in(each_blocks[i], 1);
	          } else {
	            each_blocks[i] = create_each_block(child_ctx);
	            each_blocks[i].c();
	            transition_in(each_blocks[i], 1);
	            each_blocks[i].m(div0, null);
	          }
	        }
	        group_outros();
	        for (i = each_value.length; i < each_blocks.length; i += 1) {
	          out(i);
	        }
	        check_outros();
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(arrowback.$$.fragment, local);
	      for (let i = 0; i < each_value.length; i += 1) {
	        transition_in(each_blocks[i]);
	      }
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(arrowback.$$.fragment, local);
	      each_blocks = each_blocks.filter(Boolean);
	      for (let i = 0; i < each_blocks.length; i += 1) {
	        transition_out(each_blocks[i]);
	      }
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(h1);
	        detach_dev(t1);
	        detach_dev(div1);
	      }
	      destroy_component(arrowback);
	      destroy_each(each_blocks, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$3.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$3($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Ouyou', slots, []);
	  let _volume = volume;
	  let _mylessons = mylessons;
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Ouyou> was created with unknown prop '".concat(key, "'"));
	  });
	  function keydown_handler(event) {
	    bubble.call(this, $$self, event);
	  }
	  $$self.$capture_state = () => ({
	    _volume,
	    _mylessons,
	    AudioPlayer,
	    stopAll,
	    Cancel,
	    ArrowBack: Arrow_back
	  });
	  $$self.$inject_state = $$props => {
	    if ('_volume' in $$props) $$invalidate(0, _volume = $$props._volume);
	    if ('_mylessons' in $$props) $$invalidate(1, _mylessons = $$props._mylessons);
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [_volume, _mylessons, keydown_handler];
	}
	class Ouyou extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Ouyou",
	      options,
	      id: create_fragment$3.name
	    });
	  }
	}

	/* src/pages/Help.svelte generated by Svelte v4.2.1 */
	const file$1 = "src/pages/Help.svelte";
	function create_fragment$2(ctx) {
	  let div;
	  let h10;
	  let t1;
	  let h11;
	  let t3;
	  let ul0;
	  let li0;
	  let t4;
	  let a;
	  let code0;
	  let t6;
	  let t7;
	  let li1;
	  let strong0;
	  let t9;
	  let t10;
	  let h12;
	  let t12;
	  let h30;
	  let t14;
	  let ul1;
	  let li2;
	  let t15;
	  let pre;
	  let t17;
	  let h31;
	  let t19;
	  let ul2;
	  let li3;
	  let t20;
	  let br0;
	  let t21;
	  let t22;
	  let h32;
	  let t24;
	  let ul3;
	  let li4;
	  let code1;
	  let t26;
	  let strong1;
	  let t28;
	  let code2;
	  let t30;
	  let t31;
	  let li5;
	  let t32;
	  let strong2;
	  let t34;
	  let t35;
	  let li6;
	  let t37;
	  let h33;
	  let t39;
	  let ul4;
	  let li7;
	  let t40;
	  let br1;
	  let t41;
	  let table0;
	  let tr0;
	  let td0;
	  let code3;
	  let t43;
	  let td1;
	  let t45;
	  let tr1;
	  let td2;
	  let code4;
	  let t47;
	  let td3;
	  let t49;
	  let li8;
	  let t51;
	  let li9;
	  let t52;
	  let code5;
	  let t54;
	  let t55;
	  let li10;
	  let t56;
	  let br2;
	  let t57;
	  let table1;
	  let tr2;
	  let td4;
	  let span5;
	  let t58;
	  let br3;
	  let t59;
	  let span4;
	  let t60;
	  let br4;
	  let t61;
	  let span3;
	  let t62;
	  let br5;
	  let t63;
	  let span2;
	  let t64;
	  let br6;
	  let t65;
	  let span1;
	  let t66;
	  let br7;
	  let t67;
	  let span0;
	  let t68;
	  let br8;
	  let t69;
	  let tr3;
	  let td5;
	  let span11;
	  let t70;
	  let br9;
	  let t71;
	  let span10;
	  let t72;
	  let br10;
	  let t73;
	  let span9;
	  let t74;
	  let br11;
	  let t75;
	  let span8;
	  let t76;
	  let br12;
	  let t77;
	  let span7;
	  let t78;
	  let br13;
	  let t79;
	  let span6;
	  let t80;
	  let br14;
	  let t81;
	  let tr4;
	  let td6;
	  let span12;
	  let br15;
	  let t83;
	  let span13;
	  let br16;
	  let t85;
	  let span14;
	  let br17;
	  let t87;
	  let span15;
	  let br18;
	  let t89;
	  let tr5;
	  let td7;
	  let span16;
	  let br19;
	  let t91;
	  let span17;
	  let br20;
	  let t93;
	  let span18;
	  let br21;
	  let t95;
	  let span19;
	  let t97;
	  let h34;
	  let t99;
	  let ul5;
	  let li11;
	  let span20;
	  let playarrow;
	  let t100;
	  let t101;
	  let li12;
	  let t103;
	  let li13;
	  let t104;
	  let span21;
	  let cancel;
	  let t105;
	  let t106;
	  let h13;
	  let t108;
	  let ul6;
	  let li14;
	  let code6;
	  let t110;
	  let code7;
	  let t112;
	  let t113;
	  let li15;
	  let t114;
	  let code8;
	  let t116;
	  let t117;
	  let br22;
	  let t118;
	  let br23;
	  let t119;
	  let br24;
	  let current;
	  playarrow = new Play_arrow({
	    $$inline: true
	  });
	  cancel = new Cancel({
	    props: {
	      color: "#ba1a1a"
	    },
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      div = element("div");
	      h10 = element("h1");
	      h10.textContent = "è¦è´æ¹æ³";
	      t1 = space();
	      h11 = element("h1");
	      h11.textContent = "ç¹å¾´";
	      t3 = space();
	      ul0 = element("ul");
	      li0 = element("li");
	      t4 = text("ãã®ã¢ããªã¯ã");
	      a = element("a");
	      code0 = element("code");
	      code0.textContent = "nhkradio2-russian-record";
	      t6 = text("ã«ããé²é³ãããé³æºãã¡ã¤ã«ãè¦è´ãããã®ã§ãã");
	      t7 = space();
	      li1 = element("li");
	      strong0 = element("strong");
	      strong0.textContent = "ãªãã©ã¤ã³";
	      t9 = text("ã§åä½ãã¾ãã");
	      t10 = space();
	      h12 = element("h1");
	      h12.textContent = "ç°å¢æ§ç¯";
	      t12 = space();
	      h30 = element("h3");
	      h30.textContent = "ï¼ï¼ï¼ãã¦ã³ã­ã¼ã";
	      t14 = space();
	      ul1 = element("ul");
	      li2 = element("li");
	      t15 = text("ãã¦ã³ã­ã¼ãããããã©ã«ãã¯ä»¥ä¸ã®æ§æã¨ãªã£ã¦ãã¾ãã\n");
	      pre = element("pre");
	      pre.textContent = "âââ docs\n  âââ audio\n  âÂ Â  âââ sample.m4a // ãµã³ãã«ãã¡ã¤ã«\n  âÂ Â  âââ [ç¥]\n  âââ build\n  âÂ Â  âââ bundle.css\n  âÂ Â  âââ bundle.js\n  âââ data\n  âÂ Â  âââ data.js // é²é³ãã¡ã¤ã«ãã¼ã¿\n  âââ favicon.png\n  âââ global.css\n  âââ index2023-4-9.html\n  âââ index2023-10-3.html\n";
	      t17 = space();
	      h31 = element("h3");
	      h31.textContent = "ï¼ï¼ï¼åä½ãã¹ã";
	      t19 = space();
	      ul2 = element("ul");
	      li3 = element("li");
	      t20 = text("ãµã³ãã«ã®é²é³ãã¡ã¤ã«ï¼ãåç´ç·¨ãç¬¬55ã60èª²ããå¿ç¨ç·¨ãç¬¬1ã4èª²ï¼ãåæ¢±ããã¦ãã¾ãã®ã§è©¦è´ãç¢ºèªãã¦ä¸ããã");
	      br0 = element("br");
	      t21 = text("\n  è©¦è´å¾ã¯åé¤ãã¦ä¸ããã");
	      t22 = space();
	      h32 = element("h3");
	      h32.textContent = "ï¼ï¼ï¼é²é³ãã¡ã¤ã«";
	      t24 = space();
	      ul3 = element("ul");
	      li4 = element("li");
	      code1 = element("code");
	      code1.textContent = "nhkradio2-russian-record";
	      t26 = text("ã«ããåèªé²é³ããé³æºãã¡ã¤ã«ï¼");
	      strong1 = element("strong");
	      strong1.textContent = ".m4a";
	      t28 = text("ï¼ã");
	      code2 = element("code");
	      code2.textContent = "audio";
	      t30 = text("ãã©ã«ãåã«åç´ãã¾ãã");
	      t31 = space();
	      li5 = element("li");
	      t32 = text("é³æºã®ãã¡ã¤ã«åã¯ãã¼ã¿åã®ãã¡ã¤ã«åã¨");
	      strong2 = element("strong");
	      strong2.textContent = "æ´åãã¦ãã";
	      t34 = text("å¿è¦ãããã¾ãã");
	      t35 = space();
	      li6 = element("li");
	      li6.textContent = "ããç°ãªãå ´åã¯é³æºãã¡ã¤ã«åãåãããããã¼ã¿ãä¿®æ­£ãã¦ä¸ããã";
	      t37 = space();
	      h33 = element("h3");
	      h33.textContent = "ï¼ï¼ï¼ãã¼ã¿";
	      t39 = space();
	      ul4 = element("ul");
	      li7 = element("li");
	      t40 = text("ãã¼ã¿ãã¡ã¤ã«ã¯å¹´åº¦åã³ã·ãªã¼ãºæ¯ã«åå²ããã¦ãã¾ãã");
	      br1 = element("br");
	      t41 = space();
	      table0 = element("table");
	      tr0 = element("tr");
	      td0 = element("td");
	      code3 = element("code");
	      code3.textContent = "data-2023-4-9.js";
	      t43 = space();
	      td1 = element("td");
	      td1.textContent = "2023å¹´åº¦4æã9ææ¾éå";
	      t45 = space();
	      tr1 = element("tr");
	      td2 = element("td");
	      code4 = element("code");
	      code4.textContent = "data-2023-10-3.js";
	      t47 = space();
	      td3 = element("td");
	      td3.textContent = "2023å¹´åº¦10æãç¿å¹´3ææ¾éå";
	      t49 = space();
	      li8 = element("li");
	      li8.textContent = "ãã¼ã¿ãã¡ã¤ã«ã«ã¯æªæ¾éåãå«ãæ¾éæ¥ã®æ¥ä»ã®ä»ããå¨ãã¼ã¿ãæ ¼ç´ããã¦ãã¾ãã";
	      t51 = space();
	      li9 = element("li");
	      t52 = text("å¹´åº¦åã³ã·ãªã¼ãºã®é¸æã¯");
	      code5 = element("code");
	      code5.textContent = "index2023****.html";
	      t54 = text("ã§è¡ãã¾ãã");
	      t55 = space();
	      li10 = element("li");
	      t56 = text("ä¸é¨çªçµãéè¤ããã¦æ¾éããã¦ããå ´åãããã¾ãã");
	      br2 = element("br");
	      t57 = text("\n  ãã¼ã¿ãåèªã·ã¹ãã ã«ãããé²é³ãã¼ã¿ã¨ã®ç¸éãããå ´åã¯èªç±ã«ç·¨éå¯è½ã§ãã\n  \n\n");
	      table1 = element("table");
	      tr2 = element("tr");
	      td4 = element("td");
	      span5 = element("span");
	      t58 = text("ãåç´ç·¨ãç¬¬10èª² 20230424(æ)");
	      br3 = element("br");
	      t59 = space();
	      span4 = element("span");
	      t60 = text("ãåç´ç·¨ãç¬¬11èª² 20230425(ç«)");
	      br4 = element("br");
	      t61 = space();
	      span3 = element("span");
	      t62 = text("ãåç´ç·¨ãç¬¬12èª² 20230426(æ°´)");
	      br5 = element("br");
	      t63 = space();
	      span2 = element("span");
	      t64 = text("ãåç´ç·¨ãç¬¬10èª² 20230501(æ)");
	      br6 = element("br");
	      t65 = space();
	      span1 = element("span");
	      t66 = text("ãåç´ç·¨ãç¬¬11èª² 20230502(ç«)");
	      br7 = element("br");
	      t67 = space();
	      span0 = element("span");
	      t68 = text("ãåç´ç·¨ãç¬¬12èª² 20230503(æ°´)");
	      br8 = element("br");
	      t69 = space();
	      tr3 = element("tr");
	      td5 = element("td");
	      span11 = element("span");
	      t70 = text("ãåç´ç·¨ãç¬¬52èª² 20230807(æ)");
	      br9 = element("br");
	      t71 = space();
	      span10 = element("span");
	      t72 = text("ãåç´ç·¨ãç¬¬53èª² 20230808(ç«)");
	      br10 = element("br");
	      t73 = space();
	      span9 = element("span");
	      t74 = text("ãåç´ç·¨ãç¬¬54èª² 20230809(æ°´)");
	      br11 = element("br");
	      t75 = space();
	      span8 = element("span");
	      t76 = text("ãåç´ç·¨ãç¬¬52èª² 20230814(æ)");
	      br12 = element("br");
	      t77 = space();
	      span7 = element("span");
	      t78 = text("ãåç´ç·¨ãç¬¬53èª² 20230815(ç«)");
	      br13 = element("br");
	      t79 = space();
	      span6 = element("span");
	      t80 = text("ãåç´ç·¨ãç¬¬54èª² 20230816(æ°´)");
	      br14 = element("br");
	      t81 = space();
	      tr4 = element("tr");
	      td6 = element("td");
	      span12 = element("span");
	      span12.textContent = "ãå¿ç¨ç·¨ãç¬¬7èª² 20230427(æ¨)";
	      br15 = element("br");
	      t83 = space();
	      span13 = element("span");
	      span13.textContent = "ãå¿ç¨ç·¨ãç¬¬8èª² 20230428(é)";
	      br16 = element("br");
	      t85 = space();
	      span14 = element("span");
	      span14.textContent = "ãå¿ç¨ç·¨ãç¬¬7èª² 20230504(æ¨)";
	      br17 = element("br");
	      t87 = space();
	      span15 = element("span");
	      span15.textContent = "ãå¿ç¨ç·¨ãç¬¬8èª² 20230505(é)";
	      br18 = element("br");
	      t89 = space();
	      tr5 = element("tr");
	      td7 = element("td");
	      span16 = element("span");
	      span16.textContent = "ãå¿ç¨ç·¨ãç¬¬35èª² 20230810(æ¨)";
	      br19 = element("br");
	      t91 = space();
	      span17 = element("span");
	      span17.textContent = "ãå¿ç¨ç·¨ãç¬¬36èª² 20230811(é)";
	      br20 = element("br");
	      t93 = space();
	      span18 = element("span");
	      span18.textContent = "ãå¿ç¨ç·¨ãç¬¬35èª² 20230817(æ¨)";
	      br21 = element("br");
	      t95 = space();
	      span19 = element("span");
	      span19.textContent = "ãå¿ç¨ç·¨ãç¬¬36èª² 20230818(é)";
	      t97 = space();
	      h34 = element("h3");
	      h34.textContent = "ï¼ï¼ï¼è¦è´";
	      t99 = space();
	      ul5 = element("ul");
	      li11 = element("li");
	      span20 = element("span");
	      create_component(playarrow.$$.fragment);
	      t100 = text("ãã¯ãªãã¯ãã¾ãã¨ä¸é¨ã®é³æºãã¡ã¤ã«åã®è²ãèµ¤ã«å¤åãåçãå§ã¾ãã¾ãã");
	      t101 = space();
	      li12 = element("li");
	      li12.textContent = "è¤æ°åæè¦è´ã¯åºæ¥ã¾ãããä»¥åã®è¦è´ã¯è§£é¤ããã¾ãã";
	      t103 = space();
	      li13 = element("li");
	      t104 = text("å³ä¸ã®ãã¿ã³ ");
	      span21 = element("span");
	      create_component(cancel.$$.fragment);
	      t105 = text("ã§ãåæ­¢åºæ¥ã¾ãã");
	      t106 = space();
	      h13 = element("h1");
	      h13.textContent = "TIPS";
	      t108 = space();
	      ul6 = element("ul");
	      li14 = element("li");
	      code6 = element("code");
	      code6.textContent = "nhkradio2-russian-record";
	      t110 = text("ã«ããã¦é³æºãã¡ã¤ã«ã®ä¿å­ãã©ã«ãåã");
	      code7 = element("code");
	      code7.textContent = "audio";
	      t112 = text("ã«è¨­å®ãã¦ç½®ãã¨ãã®ã¾ã¾ã§è¦è´å¯è½ã§ãã");
	      t113 = space();
	      li15 = element("li");
	      t114 = text("ãã©ã«ã");
	      code8 = element("code");
	      code8.textContent = "docs";
	      t116 = text("ä»¥ä¸ã¯ãã¡ã¤ã«ã·ã¹ãã ã®èªç±ãªå ´æã«ç½®ããã¨ãåºæ¥ã¾ãï¼åç§°å¤æ´å¯ï¼ã");
	      t117 = space();
	      br22 = element("br");
	      t118 = space();
	      br23 = element("br");
	      t119 = space();
	      br24 = element("br");
	      attr_dev(h10, "class", "mdc-typography--headline4");
	      add_location(h10, file$1, 14, 0, 183);
	      attr_dev(h11, "class", "mdc-typography--headline5");
	      add_location(h11, file$1, 16, 0, 232);
	      add_location(code0, file$1, 19, 110, 394);
	      attr_dev(a, "href", "https://github.com/ru-museum/nhkradio2-russian-record");
	      attr_dev(a, "target", "_blank");
	      attr_dev(a, "rel", "noreferrer");
	      add_location(a, file$1, 19, 13, 297);
	      add_location(li0, file$1, 19, 2, 286);
	      add_location(strong0, file$1, 20, 6, 471);
	      add_location(li1, file$1, 20, 2, 467);
	      add_location(ul0, file$1, 18, 0, 279);
	      attr_dev(h12, "class", "mdc-typography--headline5");
	      add_location(h12, file$1, 23, 0, 513);
	      add_location(h30, file$1, 26, 0, 564);
	      add_location(pre, file$1, 29, 0, 622);
	      add_location(li2, file$1, 28, 2, 590);
	      add_location(ul1, file$1, 27, 0, 583);
	      add_location(h31, file$1, 47, 0, 901);
	      add_location(br0, file$1, 49, 64, 988);
	      add_location(li3, file$1, 49, 2, 926);
	      add_location(ul2, file$1, 48, 0, 919);
	      add_location(h32, file$1, 54, 0, 1027);
	      add_location(code1, file$1, 56, 6, 1057);
	      add_location(strong1, file$1, 56, 59, 1110);
	      add_location(code2, file$1, 56, 82, 1133);
	      add_location(li4, file$1, 56, 2, 1053);
	      add_location(strong2, file$1, 57, 26, 1197);
	      add_location(li5, file$1, 57, 2, 1173);
	      add_location(li6, file$1, 58, 2, 1236);
	      add_location(ul3, file$1, 55, 0, 1046);
	      add_location(h33, file$1, 61, 0, 1288);
	      add_location(br1, file$1, 63, 33, 1342);
	      add_location(code3, file$1, 66, 26, 1412);
	      attr_dev(td0, "valign", "top");
	      add_location(td0, file$1, 66, 9, 1395);
	      add_location(td1, file$1, 67, 9, 1456);
	      add_location(tr0, file$1, 65, 6, 1381);
	      add_location(code4, file$1, 70, 26, 1530);
	      attr_dev(td2, "valign", "top");
	      add_location(td2, file$1, 70, 9, 1513);
	      add_location(td3, file$1, 71, 9, 1575);
	      add_location(tr1, file$1, 69, 6, 1499);
	      attr_dev(table0, "cellpadding", "6");
	      add_location(table0, file$1, 64, 4, 1351);
	      add_location(li7, file$1, 63, 2, 1311);
	      add_location(li8, file$1, 75, 2, 1638);
	      add_location(code5, file$1, 76, 18, 1706);
	      add_location(li9, file$1, 76, 2, 1690);
	      add_location(br2, file$1, 77, 31, 1780);
	      add_location(br3, file$1, 85, 48, 1921);
	      add_location(br4, file$1, 86, 48, 1974);
	      add_location(br5, file$1, 87, 48, 2027);
	      add_location(br6, file$1, 88, 48, 2080);
	      add_location(br7, file$1, 89, 48, 2133);
	      add_location(br8, file$1, 90, 48, 2186);
	      attr_dev(span0, "class", "col2 svelte-8hxn80");
	      add_location(span0, file$1, 90, 8, 2146);
	      attr_dev(span1, "class", "col1 svelte-8hxn80");
	      add_location(span1, file$1, 89, 8, 2093);
	      attr_dev(span2, "class", "col2 svelte-8hxn80");
	      add_location(span2, file$1, 88, 8, 2040);
	      attr_dev(span3, "class", "col1 svelte-8hxn80");
	      add_location(span3, file$1, 87, 8, 1987);
	      attr_dev(span4, "class", "col2 svelte-8hxn80");
	      add_location(span4, file$1, 86, 8, 1934);
	      attr_dev(span5, "class", "col1 svelte-8hxn80");
	      add_location(span5, file$1, 85, 8, 1881);
	      add_location(td4, file$1, 84, 5, 1868);
	      add_location(tr2, file$1, 83, 2, 1858);
	      add_location(br9, file$1, 95, 48, 2276);
	      add_location(br10, file$1, 96, 48, 2329);
	      add_location(br11, file$1, 97, 48, 2382);
	      add_location(br12, file$1, 98, 48, 2435);
	      add_location(br13, file$1, 99, 48, 2488);
	      add_location(br14, file$1, 100, 48, 2541);
	      attr_dev(span6, "class", "col2 svelte-8hxn80");
	      add_location(span6, file$1, 100, 8, 2501);
	      attr_dev(span7, "class", "col1 svelte-8hxn80");
	      add_location(span7, file$1, 99, 8, 2448);
	      attr_dev(span8, "class", "col2 svelte-8hxn80");
	      add_location(span8, file$1, 98, 8, 2395);
	      attr_dev(span9, "class", "col1 svelte-8hxn80");
	      add_location(span9, file$1, 97, 8, 2342);
	      attr_dev(span10, "class", "col2 svelte-8hxn80");
	      add_location(span10, file$1, 96, 8, 2289);
	      attr_dev(span11, "class", "col1 svelte-8hxn80");
	      add_location(span11, file$1, 95, 8, 2236);
	      add_location(td5, file$1, 94, 5, 2223);
	      add_location(tr3, file$1, 93, 2, 2213);
	      attr_dev(span12, "class", "col1 svelte-8hxn80");
	      add_location(span12, file$1, 105, 8, 2591);
	      add_location(br15, file$1, 105, 54, 2637);
	      attr_dev(span13, "class", "col2 svelte-8hxn80");
	      add_location(span13, file$1, 106, 8, 2650);
	      add_location(br16, file$1, 106, 54, 2696);
	      attr_dev(span14, "class", "col1 svelte-8hxn80");
	      add_location(span14, file$1, 107, 8, 2709);
	      add_location(br17, file$1, 107, 54, 2755);
	      attr_dev(span15, "class", "col2 svelte-8hxn80");
	      add_location(span15, file$1, 108, 8, 2768);
	      add_location(br18, file$1, 108, 54, 2814);
	      add_location(td6, file$1, 104, 5, 2578);
	      add_location(tr4, file$1, 103, 2, 2568);
	      attr_dev(span16, "class", "col1 svelte-8hxn80");
	      add_location(span16, file$1, 113, 8, 2864);
	      add_location(br19, file$1, 113, 55, 2911);
	      attr_dev(span17, "class", "col2 svelte-8hxn80");
	      add_location(span17, file$1, 114, 8, 2924);
	      add_location(br20, file$1, 114, 55, 2971);
	      attr_dev(span18, "class", "col1 svelte-8hxn80");
	      add_location(span18, file$1, 115, 8, 2984);
	      add_location(br21, file$1, 115, 55, 3031);
	      attr_dev(span19, "class", "col2 svelte-8hxn80");
	      add_location(span19, file$1, 116, 8, 3044);
	      add_location(td7, file$1, 112, 5, 2851);
	      add_location(tr5, file$1, 111, 2, 2841);
	      attr_dev(table1, "cellpadding", "6");
	      add_location(table1, file$1, 81, 0, 1831);
	      add_location(li10, file$1, 77, 2, 1751);
	      add_location(ul4, file$1, 62, 0, 1304);
	      add_location(h34, file$1, 128, 0, 3144);
	      set_style(span20, "vertical-align", "middle");
	      add_location(span20, file$1, 130, 6, 3170);
	      add_location(li11, file$1, 130, 2, 3166);
	      add_location(li12, file$1, 131, 2, 3273);
	      set_style(span21, "vertical-align", "middle");
	      add_location(span21, file$1, 132, 13, 3324);
	      add_location(li13, file$1, 132, 2, 3313);
	      add_location(ul5, file$1, 129, 0, 3159);
	      attr_dev(h13, "class", "mdc-typography--headline5");
	      add_location(h13, file$1, 137, 0, 3422);
	      add_location(code6, file$1, 140, 4, 3480);
	      add_location(code7, file$1, 140, 60, 3536);
	      add_location(li14, file$1, 140, 0, 3476);
	      add_location(code8, file$1, 142, 8, 3589);
	      add_location(li15, file$1, 142, 0, 3581);
	      add_location(ul6, file$1, 139, 0, 3471);
	      add_location(br22, file$1, 148, 0, 3657);
	      add_location(br23, file$1, 149, 0, 3662);
	      add_location(br24, file$1, 150, 0, 3667);
	      attr_dev(div, "class", "container svelte-8hxn80");
	      add_location(div, file$1, 12, 0, 156);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, div, anchor);
	      append_dev(div, h10);
	      append_dev(div, t1);
	      append_dev(div, h11);
	      append_dev(div, t3);
	      append_dev(div, ul0);
	      append_dev(ul0, li0);
	      append_dev(li0, t4);
	      append_dev(li0, a);
	      append_dev(a, code0);
	      append_dev(li0, t6);
	      append_dev(ul0, t7);
	      append_dev(ul0, li1);
	      append_dev(li1, strong0);
	      append_dev(li1, t9);
	      append_dev(div, t10);
	      append_dev(div, h12);
	      append_dev(div, t12);
	      append_dev(div, h30);
	      append_dev(div, t14);
	      append_dev(div, ul1);
	      append_dev(ul1, li2);
	      append_dev(li2, t15);
	      append_dev(li2, pre);
	      append_dev(div, t17);
	      append_dev(div, h31);
	      append_dev(div, t19);
	      append_dev(div, ul2);
	      append_dev(ul2, li3);
	      append_dev(li3, t20);
	      append_dev(li3, br0);
	      append_dev(li3, t21);
	      append_dev(div, t22);
	      append_dev(div, h32);
	      append_dev(div, t24);
	      append_dev(div, ul3);
	      append_dev(ul3, li4);
	      append_dev(li4, code1);
	      append_dev(li4, t26);
	      append_dev(li4, strong1);
	      append_dev(li4, t28);
	      append_dev(li4, code2);
	      append_dev(li4, t30);
	      append_dev(ul3, t31);
	      append_dev(ul3, li5);
	      append_dev(li5, t32);
	      append_dev(li5, strong2);
	      append_dev(li5, t34);
	      append_dev(ul3, t35);
	      append_dev(ul3, li6);
	      append_dev(div, t37);
	      append_dev(div, h33);
	      append_dev(div, t39);
	      append_dev(div, ul4);
	      append_dev(ul4, li7);
	      append_dev(li7, t40);
	      append_dev(li7, br1);
	      append_dev(li7, t41);
	      append_dev(li7, table0);
	      append_dev(table0, tr0);
	      append_dev(tr0, td0);
	      append_dev(td0, code3);
	      append_dev(tr0, t43);
	      append_dev(tr0, td1);
	      append_dev(table0, t45);
	      append_dev(table0, tr1);
	      append_dev(tr1, td2);
	      append_dev(td2, code4);
	      append_dev(tr1, t47);
	      append_dev(tr1, td3);
	      append_dev(ul4, t49);
	      append_dev(ul4, li8);
	      append_dev(ul4, t51);
	      append_dev(ul4, li9);
	      append_dev(li9, t52);
	      append_dev(li9, code5);
	      append_dev(li9, t54);
	      append_dev(ul4, t55);
	      append_dev(ul4, li10);
	      append_dev(li10, t56);
	      append_dev(li10, br2);
	      append_dev(li10, t57);
	      append_dev(li10, table1);
	      append_dev(table1, tr2);
	      append_dev(tr2, td4);
	      append_dev(td4, span5);
	      append_dev(span5, t58);
	      append_dev(span5, br3);
	      append_dev(span5, t59);
	      append_dev(span5, span4);
	      append_dev(span4, t60);
	      append_dev(span4, br4);
	      append_dev(span4, t61);
	      append_dev(span4, span3);
	      append_dev(span3, t62);
	      append_dev(span3, br5);
	      append_dev(span3, t63);
	      append_dev(span3, span2);
	      append_dev(span2, t64);
	      append_dev(span2, br6);
	      append_dev(span2, t65);
	      append_dev(span2, span1);
	      append_dev(span1, t66);
	      append_dev(span1, br7);
	      append_dev(span1, t67);
	      append_dev(span1, span0);
	      append_dev(span0, t68);
	      append_dev(span0, br8);
	      append_dev(table1, t69);
	      append_dev(table1, tr3);
	      append_dev(tr3, td5);
	      append_dev(td5, span11);
	      append_dev(span11, t70);
	      append_dev(span11, br9);
	      append_dev(span11, t71);
	      append_dev(span11, span10);
	      append_dev(span10, t72);
	      append_dev(span10, br10);
	      append_dev(span10, t73);
	      append_dev(span10, span9);
	      append_dev(span9, t74);
	      append_dev(span9, br11);
	      append_dev(span9, t75);
	      append_dev(span9, span8);
	      append_dev(span8, t76);
	      append_dev(span8, br12);
	      append_dev(span8, t77);
	      append_dev(span8, span7);
	      append_dev(span7, t78);
	      append_dev(span7, br13);
	      append_dev(span7, t79);
	      append_dev(span7, span6);
	      append_dev(span6, t80);
	      append_dev(span6, br14);
	      append_dev(table1, t81);
	      append_dev(table1, tr4);
	      append_dev(tr4, td6);
	      append_dev(td6, span12);
	      append_dev(td6, br15);
	      append_dev(td6, t83);
	      append_dev(td6, span13);
	      append_dev(td6, br16);
	      append_dev(td6, t85);
	      append_dev(td6, span14);
	      append_dev(td6, br17);
	      append_dev(td6, t87);
	      append_dev(td6, span15);
	      append_dev(td6, br18);
	      append_dev(table1, t89);
	      append_dev(table1, tr5);
	      append_dev(tr5, td7);
	      append_dev(td7, span16);
	      append_dev(td7, br19);
	      append_dev(td7, t91);
	      append_dev(td7, span17);
	      append_dev(td7, br20);
	      append_dev(td7, t93);
	      append_dev(td7, span18);
	      append_dev(td7, br21);
	      append_dev(td7, t95);
	      append_dev(td7, span19);
	      append_dev(div, t97);
	      append_dev(div, h34);
	      append_dev(div, t99);
	      append_dev(div, ul5);
	      append_dev(ul5, li11);
	      append_dev(li11, span20);
	      mount_component(playarrow, span20, null);
	      append_dev(li11, t100);
	      append_dev(ul5, t101);
	      append_dev(ul5, li12);
	      append_dev(ul5, t103);
	      append_dev(ul5, li13);
	      append_dev(li13, t104);
	      append_dev(li13, span21);
	      mount_component(cancel, span21, null);
	      append_dev(li13, t105);
	      append_dev(div, t106);
	      append_dev(div, h13);
	      append_dev(div, t108);
	      append_dev(div, ul6);
	      append_dev(ul6, li14);
	      append_dev(li14, code6);
	      append_dev(li14, t110);
	      append_dev(li14, code7);
	      append_dev(li14, t112);
	      append_dev(ul6, t113);
	      append_dev(ul6, li15);
	      append_dev(li15, t114);
	      append_dev(li15, code8);
	      append_dev(li15, t116);
	      append_dev(div, t117);
	      append_dev(div, br22);
	      append_dev(div, t118);
	      append_dev(div, br23);
	      append_dev(div, t119);
	      append_dev(div, br24);
	      current = true;
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(playarrow.$$.fragment, local);
	      transition_in(cancel.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(playarrow.$$.fragment, local);
	      transition_out(cancel.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(div);
	      }
	      destroy_component(playarrow);
	      destroy_component(cancel);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$2.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$2($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('Help', slots, []);
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Help> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$capture_state = () => ({
	    Cancel,
	    PlayArrow: Play_arrow
	  });
	  return [];
	}
	class Help extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$2, create_fragment$2, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "Help",
	      options,
	      id: create_fragment$2.name
	    });
	  }
	}

	/* src/pages/NotFound.svelte generated by Svelte v4.2.1 */
	const file = "src/pages/NotFound.svelte";
	function create_fragment$1(ctx) {
	  let main;
	  let h1;
	  let t1;
	  let h3;
	  let t3;
	  let a;
	  let mwc_icon_button;
	  let mwc_icon;
	  let homebutton;
	  let current;
	  homebutton = new Home$1({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      main = element("main");
	      h1 = element("h1");
	      h1.textContent = "404: ERROR";
	      t1 = space();
	      h3 = element("h3");
	      h3.textContent = "ãã¼ã¸ãããã¾ããã";
	      t3 = space();
	      a = element("a");
	      mwc_icon_button = element("mwc-icon-button");
	      mwc_icon = element("mwc-icon");
	      create_component(homebutton.$$.fragment);
	      attr_dev(h1, "class", "svelte-1uvk41d");
	      add_location(h1, file, 7, 0, 88);
	      add_location(h3, file, 8, 0, 108);
	      add_location(mwc_icon, file, 12, 6, 181);
	      set_custom_element_data(mwc_icon_button, "class", "svelte-1uvk41d");
	      add_location(mwc_icon_button, file, 11, 4, 157);
	      attr_dev(a, "href", "#/home");
	      add_location(a, file, 10, 2, 135);
	      attr_dev(main, "class", "svelte-1uvk41d");
	      add_location(main, file, 6, 0, 81);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      insert_dev(target, main, anchor);
	      append_dev(main, h1);
	      append_dev(main, t1);
	      append_dev(main, h3);
	      append_dev(main, t3);
	      append_dev(main, a);
	      append_dev(a, mwc_icon_button);
	      append_dev(mwc_icon_button, mwc_icon);
	      mount_component(homebutton, mwc_icon, null);
	      current = true;
	    },
	    p: noop$1,
	    i: function intro(local) {
	      if (current) return;
	      transition_in(homebutton.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(homebutton.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(main);
	      }
	      destroy_component(homebutton);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment$1.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance$1($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('NotFound', slots, []);
	  const writable_props = [];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<NotFound> was created with unknown prop '".concat(key, "'"));
	  });
	  $$self.$capture_state = () => ({
	    HomeButton: Home$1
	  });
	  return [];
	}
	class NotFound extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "NotFound",
	      options,
	      id: create_fragment$1.name
	    });
	  }
	}

	const {
	  window: window_1
	} = globals;

	// (55:0) {#if y > 200}
	function create_if_block(ctx) {
	  let totopbutton;
	  let current;
	  totopbutton = new ToTopButton({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      create_component(totopbutton.$$.fragment);
	    },
	    m: function mount(target, anchor) {
	      mount_component(totopbutton, target, anchor);
	      current = true;
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(totopbutton.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(totopbutton.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      destroy_component(totopbutton, detaching);
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_if_block.name,
	    type: "if",
	    source: "(55:0) {#if y > 200}",
	    ctx
	  });
	  return block;
	}
	function create_fragment(ctx) {
	  let scrolling = false;
	  let clear_scrolling = () => {
	    scrolling = false;
	  };
	  let scrolling_timeout;
	  let t0;
	  let navbar;
	  let t1;
	  let switch_instance;
	  let t2;
	  let footer;
	  let current;
	  let mounted;
	  let dispose;
	  add_render_callback( /*onwindowscroll*/ctx[3]);
	  let if_block = /*y*/ctx[1] > 200 && create_if_block(ctx);
	  navbar = new Navbar({
	    props: {
	      presets: /*presets*/ctx[0]
	    },
	    $$inline: true
	  });
	  var switch_value = /*page*/ctx[2];
	  function switch_props(ctx, dirty) {
	    return {
	      props: {
	        presets: /*presets*/ctx[0]
	      },
	      $$inline: true
	    };
	  }
	  if (switch_value) {
	    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	  }
	  footer = new Footer({
	    $$inline: true
	  });
	  const block = {
	    c: function create() {
	      if (if_block) if_block.c();
	      t0 = space();
	      create_component(navbar.$$.fragment);
	      t1 = space();
	      if (switch_instance) create_component(switch_instance.$$.fragment);
	      t2 = space();
	      create_component(footer.$$.fragment);
	    },
	    l: function claim(nodes) {
	      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
	    },
	    m: function mount(target, anchor) {
	      if (if_block) if_block.m(target, anchor);
	      insert_dev(target, t0, anchor);
	      mount_component(navbar, target, anchor);
	      insert_dev(target, t1, anchor);
	      if (switch_instance) mount_component(switch_instance, target, anchor);
	      insert_dev(target, t2, anchor);
	      mount_component(footer, target, anchor);
	      current = true;
	      if (!mounted) {
	        dispose = listen_dev(window_1, "scroll", () => {
	          scrolling = true;
	          clearTimeout(scrolling_timeout);
	          scrolling_timeout = setTimeout(clear_scrolling, 100);
	          /*onwindowscroll*/
	          ctx[3]();
	        });
	        mounted = true;
	      }
	    },
	    p: function update(ctx, _ref) {
	      let [dirty] = _ref;
	      if (dirty & /*y*/2 && !scrolling) {
	        scrolling = true;
	        clearTimeout(scrolling_timeout);
	        scrollTo(window_1.pageXOffset, /*y*/ctx[1]);
	        scrolling_timeout = setTimeout(clear_scrolling, 100);
	      }
	      if ( /*y*/ctx[1] > 200) {
	        if (if_block) {
	          if (dirty & /*y*/2) {
	            transition_in(if_block, 1);
	          }
	        } else {
	          if_block = create_if_block(ctx);
	          if_block.c();
	          transition_in(if_block, 1);
	          if_block.m(t0.parentNode, t0);
	        }
	      } else if (if_block) {
	        group_outros();
	        transition_out(if_block, 1, 1, () => {
	          if_block = null;
	        });
	        check_outros();
	      }
	      const navbar_changes = {};
	      if (dirty & /*presets*/1) navbar_changes.presets = /*presets*/ctx[0];
	      navbar.$set(navbar_changes);
	      if (dirty & /*page*/4 && switch_value !== (switch_value = /*page*/ctx[2])) {
	        if (switch_instance) {
	          group_outros();
	          const old_component = switch_instance;
	          transition_out(old_component.$$.fragment, 1, 0, () => {
	            destroy_component(old_component, 1);
	          });
	          check_outros();
	        }
	        if (switch_value) {
	          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	          create_component(switch_instance.$$.fragment);
	          transition_in(switch_instance.$$.fragment, 1);
	          mount_component(switch_instance, t2.parentNode, t2);
	        } else {
	          switch_instance = null;
	        }
	      } else if (switch_value) {
	        const switch_instance_changes = {};
	        if (dirty & /*presets*/1) switch_instance_changes.presets = /*presets*/ctx[0];
	        switch_instance.$set(switch_instance_changes);
	      }
	    },
	    i: function intro(local) {
	      if (current) return;
	      transition_in(if_block);
	      transition_in(navbar.$$.fragment, local);
	      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	      transition_in(footer.$$.fragment, local);
	      current = true;
	    },
	    o: function outro(local) {
	      transition_out(if_block);
	      transition_out(navbar.$$.fragment, local);
	      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	      transition_out(footer.$$.fragment, local);
	      current = false;
	    },
	    d: function destroy(detaching) {
	      if (detaching) {
	        detach_dev(t0);
	        detach_dev(t1);
	        detach_dev(t2);
	      }
	      if (if_block) if_block.d(detaching);
	      destroy_component(navbar, detaching);
	      if (switch_instance) destroy_component(switch_instance, detaching);
	      destroy_component(footer, detaching);
	      mounted = false;
	      dispose();
	    }
	  };
	  dispatch_dev("SvelteRegisterBlock", {
	    block,
	    id: create_fragment.name,
	    type: "component",
	    source: "",
	    ctx
	  });
	  return block;
	}
	function instance($$self, $$props, $$invalidate) {
	  let {
	    $$slots: slots = {},
	    $$scope
	  } = $$props;
	  validate_slots('App', slots, []);
	  let {
	    presets
	  } = $$props;

	  // import "@material/mwc-components/Navbar.svelte";
	  let y = 0; // ã¹ã¯ã­ã¼ã«ä½ç½®ï¼Yåº§æ¨åæå¤ 

	  // ROUTER 
	  var routes = {};
	  var page = Home; // åæãã¼ã¸

	  function route(path, controller) {
	    routes[path] = {
	      controller
	    };
	  }
	  var el = null;
	  function router() {
	    // Lazy load view element:
	    // Current route url (getting rid of '#' in hash as well):
	    var url = location.hash.slice(1) || '/';

	    // Get route by url:
	    var route = routes[url];

	    // ã¨ã©ã¼ãã¼ã¸ã®è¡¨ç¤º
	    if (route === undefined) {
	      $$invalidate(2, page = NotFound);
	      return;
	    }

	    // Do we have both a view and a route?
	    if (route.controller) {
	      route.controller();
	    }
	  }

	  // Listen on hash change:
	  window.addEventListener('hashchange', router);

	  // Listen on page load:
	  window.addEventListener('load', router);

	  // PAGE è¨­å®
	  route('/', () => {
	    $$invalidate(2, page = Home);
	  });
	  route('/home', () => {
	    $$invalidate(2, page = Home);
	  });
	  route('/help', () => {
	    $$invalidate(2, page = Help);
	  });
	  route('/shokyu', () => {
	    $$invalidate(2, page = Shokyu);
	  });
	  route('/ouyou', () => {
	    $$invalidate(2, page = Ouyou);
	  });
	  $$self.$$.on_mount.push(function () {
	    if (presets === undefined && !('presets' in $$props || $$self.$$.bound[$$self.$$.props['presets']])) {
	      console.warn("<App> was created without expected prop 'presets'");
	    }
	  });
	  const writable_props = ['presets'];
	  Object.keys($$props).forEach(key => {
	    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<App> was created with unknown prop '".concat(key, "'"));
	  });
	  function onwindowscroll() {
	    $$invalidate(1, y = window_1.pageYOffset);
	  }
	  $$self.$$set = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	  };
	  $$self.$capture_state = () => ({
	    presets,
	    Navbar,
	    Footer,
	    ToTopButton,
	    Home,
	    Shokyu,
	    Ouyou,
	    Help,
	    NotFound,
	    y,
	    routes,
	    page,
	    route,
	    el,
	    router
	  });
	  $$self.$inject_state = $$props => {
	    if ('presets' in $$props) $$invalidate(0, presets = $$props.presets);
	    if ('y' in $$props) $$invalidate(1, y = $$props.y);
	    if ('routes' in $$props) routes = $$props.routes;
	    if ('page' in $$props) $$invalidate(2, page = $$props.page);
	    if ('el' in $$props) el = $$props.el;
	  };
	  if ($$props && "$$inject" in $$props) {
	    $$self.$inject_state($$props.$$inject);
	  }
	  return [presets, y, page, onwindowscroll];
	}
	class App extends SvelteComponentDev {
	  constructor(options) {
	    super(options);
	    init(this, options, instance, create_fragment, safe_not_equal, {
	      presets: 0
	    });
	    dispatch_dev("SvelteRegisterComponent", {
	      component: this,
	      tagName: "App",
	      options,
	      id: create_fragment.name
	    });
	  }
	  get presets() {
	    throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	  set presets(value) {
	    throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	  }
	}

	const app = new App({
	    target: document.body,
	    props: {
	        presets: {
	            year: new Date().getFullYear(),
	            name: "Svelte:MWC",
	            title: "ã¾ãã«ã¡ã­ã·ã¢èª",
	            subtitle: "NHKã©ã¸ãªèªå­¦çªçµ",
	            admin: "æµäº èä¸",
	            mail: '<i class="material-icons small-1">mail</i>museum_ru&#64;yahoo.co.jp'
	        }
	    }
	});

	return app;

})();
//# sourceMappingURL=bundle.js.map
